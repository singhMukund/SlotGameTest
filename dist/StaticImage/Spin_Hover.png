 combinedLookup, scope.packageDirectory + "/", state.compilerOptions, state.host, cache, [extensions], redirectedReference);
                        return toSearchResult(result.resolvedModule ? { path: result.resolvedModule.resolvedFileName, extension: result.resolvedModule.extension, packageId: result.resolvedModule.packageId, originalPath: result.resolvedModule.originalPath } : undefined);
                    }
                    if (state.traceEnabled) {
                        trace(state.host, ts.Diagnostics.package_json_scope_0_has_invalid_type_for_target_of_specifier_1, scope.packageDirectory, moduleName);
                    }
                    return toSearchResult(/*value*/ undefined);
                }
                var parts = ts.pathIsRelative(target) ? ts.getPathComponents(target).slice(1) : ts.getPathComponents(target);
                var partsAfterFirst = parts.slice(1);
                if (partsAfterFirst.indexOf("..") >= 0 || partsAfterFirst.indexOf(".") >= 0 || partsAfterFirst.indexOf("node_modules") >= 0) {
                    if (state.traceEnabled) {
                        trace(state.host, ts.Diagnostics.package_json_scope_0_has_invalid_type_for_target_of_specifier_1, scope.packageDirectory, moduleName);
                    }
                    return toSearchResult(/*value*/ undefined);
                }
                var resolvedTarget = ts.combinePaths(scope.packageDirectory, target);
                // TODO: Assert that `resolvedTarget` is actually within the package directory? That's what the spec says.... but I'm not sure we need
                // to be in the business of validating everyone's import and export map correctness.
                var subpathParts = ts.getPathComponents(subpath);
                if (subpathParts.indexOf("..") >= 0 || subpathParts.indexOf(".") >= 0 || subpathParts.indexOf("node_modules") >= 0) {
                    if (state.traceEnabled) {
                        trace(state.host, ts.Diagnostics.package_json_scope_0_has_invalid_type_for_target_of_specifier_1, scope.packageDirectory, moduleName);
                    }
                    return toSearchResult(/*value*/ undefined);
                }
                if (state.traceEnabled) {
                    trace(state.host, ts.Diagnostics.Using_0_subpath_1_with_target_2, isImports ? "imports" : "exports", key, pattern ? target.replace(/\*/g, subpath) : target + subpath);
                }
                var finalPath = toAbsolutePath(pattern ? resolvedTarget.replace(/\*/g, subpath) : resolvedTarget + subpath);
                var inputLink = tryLoadInputFileForPath(finalPath, subpath, ts.combinePaths(scope.packageDirectory, "package.json"), isImports);
                if (inputLink)
                    return inputLink;
                return toSearchResult(withPackageId(scope, loadJSOrExactTSFileName(extensions, finalPath, /*onlyRecordFailures*/ false, state)));
            }
            else if (typeof target === "object" && target !== null) { // eslint-disable-line no-null/no-null
                if (!Array.isArray(target)) {
                    for (var _i = 0, _a = ts.getOwnKeys(target); _i < _a.length; _i++) {
                        var condition = _a[_i];
                        if (condition === "default" || state.conditions.indexOf(condition) >= 0 || isApplicableVersionedTypesKey(state.conditions, condition)) {
                            traceIfEnabled(state, ts.Diagnostics.Matched_0_condition_1, isImports ? "imports" : "exports", condition);
                            var subTarget = target[condition];
                            var result = loadModuleFromTargetImportOrExport(subTarget, subpath, pattern, key);
                            if (result) {
                                return result;
                            }
                        }
                        else {
                            traceIfEnabled(state, ts.Diagnostics.Saw_non_matching_condition_0, condition);
                        }
                    }
                    return undefined;
                }
                else {
                    if (!ts.length(target)) {
                        if (state.traceEnabled) {
                            trace(state.host, ts.Diagnostics.package_json_scope_0_has_invalid_type_for_target_of_specifier_1, scope.packageDirectory, moduleName);
                        }
                        return toSearchResult(/*value*/ undefined);
                    }
                    for (var _b = 0, target_2 = target; _b < target_2.length; _b++) {
                        var elem = target_2[_b];
                        var result = loadModuleFromTargetImportOrExport(elem, subpath, pattern, key);
                        if (result) {
                            return result;
                        }
                    }
                }
            }
            else if (target === null) { // eslint-disable-line no-null/no-null
                if (state.traceEnabled) {
                    trace(state.host, ts.Diagnostics.package_json_scope_0_explicitly_maps_specifier_1_to_null, scope.packageDirectory, moduleName);
                }
                return toSearchResult(/*value*/ undefined);
            }
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.package_json_scope_0_has_invalid_type_for_target_of_specifier_1, scope.packageDirectory, moduleName);
            }
            return toSearchResult(/*value*/ undefined);
            function toAbsolutePath(path) {
                var _a, _b;
                if (path === undefined)
                    return path;
                return ts.getNormalizedAbsolutePath(path, (_b = (_a = state.host).getCurrentDirectory) === null || _b === void 0 ? void 0 : _b.call(_a));
            }
            function combineDirectoryPath(root, dir) {
                return ts.ensureTrailingDirectorySeparator(ts.combinePaths(root, dir));
            }
            function useCaseSensitiveFileNames() {
                return !state.host.useCaseSensitiveFileNames ? true :
                    typeof state.host.useCaseSensitiveFileNames === "boolean" ? state.host.useCaseSensitiveFileNames :
                        state.host.useCaseSensitiveFileNames();
            }
            function tryLoadInputFileForPath(finalPath, entry, packagePath, isImports) {
                var _a, _b, _c, _d;
                // Replace any references to outputs for files in the program with the input files to support package self-names used with outDir
                // PROBLEM: We don't know how to calculate the output paths yet, because the "common source directory" we use as the base of the file structure
                // we reproduce into the output directory is based on the set of input files, which we're still in the process of traversing and resolving!
                // _Given that_, we have to guess what the base of the output directory is (obviously the user wrote the export map, so has some idea what it is!).
                // We are going to probe _so many_ possible paths. We limit where we'll do this to try to reduce the possibilities of false positive lookups.
                if ((extensions === Extensions.TypeScript || extensions === Extensions.JavaScript || extensions === Extensions.Json)
                    && (state.compilerOptions.declarationDir || state.compilerOptions.outDir)
                    && finalPath.indexOf("/node_modules/") === -1
                    && (state.compilerOptions.configFile ? ts.containsPath(scope.packageDirectory, toAbsolutePath(state.compilerOptions.configFile.fileName), !useCaseSensitiveFileNames()) : true)) {
                    // So that all means we'll only try these guesses for files outside `node_modules` in a directory where the `package.json` and `tsconfig.json` are siblings.
                    // Even with all that, we still don't know if the root of the output file structure will be (relative to the package file)
                    // `.`, `./src` or any other deeper directory structure. (If project references are used, it's definitely `.` by fiat, so that should be pretty common.)
                    var getCanonicalFileName = ts.hostGetCanonicalFileName({ useCaseSensitiveFileNames: useCaseSensitiveFileNames });
                    var commonSourceDirGuesses = [];
                    // A `rootDir` compiler option strongly indicates the root location
                    // A `composite` project is using project references and has it's common src dir set to `.`, so it shouldn't need to check any other locations
                    if (state.compilerOptions.rootDir || (state.compilerOptions.composite && state.compilerOptions.configFilePath)) {
                        var commonDir = toAbsolutePath(ts.getCommonSourceDirectory(state.compilerOptions, function () { return []; }, ((_b = (_a = state.host).getCurrentDirectory) === null || _b === void 0 ? void 0 : _b.call(_a)) || "", getCanonicalFileName));
                        commonSourceDirGuesses.push(commonDir);
                    }
                    else if (state.requestContainingDirectory) {
                        // However without either of those set we're in the dark. Let's say you have
                        //
                        // ./tools/index.ts
                        // ./src/index.ts
                        // ./dist/index.js
                        // ./package.json <-- references ./dist/index.js
                        // ./tsconfig.json <-- loads ./src/index.ts
                        //
                        // How do we know `./src` is the common src dir, and not `./tools`, given only the `./dist` out dir and `./dist/index.js` filename?
                        // Answer: We... don't. We know we're looking for an `index.ts` input file, but we have _no clue_ which subfolder it's supposed to be loaded from
                        // without more context.
                        // But we do have more context! Just a tiny bit more! We're resolving an import _for some other input file_! And that input file, too
                        // must be inside the common source directory! So we propagate that tidbit of info all the way to here via state.requestContainingDirectory
                        var requestingFile_1 = toAbsolutePath(ts.combinePaths(state.requestContainingDirectory, "index.ts"));
                        // And we can try every folder above the common folder for the request folder and the config/package base directory
                        // This technically can be wrong - we may load ./src/index.ts when ./src/sub/index.ts was right because we don't
                        // know if only `./src/sub` files were loaded by the program; but this has the best chance to be right of just about anything
                        // else we have. And, given that we're about to load `./src/index.ts` because we choose it as likely correct, there will then
                        // be a file outside of `./src/sub` in the program (the file we resolved to), making us de-facto right. So this fallback lookup
                        // logic may influence what files are pulled in by self-names, which in turn influences the output path shape, but it's all
                        // internally consistent so the paths should be stable so long as we prefer the "most general" (meaning: top-most-level directory) possible results first.
                        var commonDir = toAbsolutePath(ts.getCommonSourceDirectory(state.compilerOptions, function () { return [requestingFile_1, toAbsolutePath(packagePath)]; }, ((_d = (_c = state.host).getCurrentDirectory) === null || _d === void 0 ? void 0 : _d.call(_c)) || "", getCanonicalFileName));
                        commonSourceDirGuesses.push(commonDir);
                        var fragment = ts.ensureTrailingDirectorySeparator(commonDir);
                        while (fragment && fragment.length > 1) {
                            var parts = ts.getPathComponents(fragment);
                            parts.pop(); // remove a directory
                            var commonDir_1 = ts.getPathFromPathComponents(parts);
                            commonSourceDirGuesses.unshift(commonDir_1);
                            fragment = ts.ensureTrailingDirectorySeparator(commonDir_1);
                        }
                    }
                    if (commonSourceDirGuesses.length > 1) {
                        state.reportDiagnostic(ts.createCompilerDiagnostic(isImports
                            ? ts.Diagnostics.The_project_root_is_ambiguous_but_is_required_to_resolve_import_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate
                            : ts.Diagnostics.The_project_root_is_ambiguous_but_is_required_to_resolve_export_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate, entry === "" ? "." : entry, // replace empty string with `.` - the reverse of the operation done when entries are built - so main entrypoint errors don't look weird
                        packagePath));
                    }
                    for (var _i = 0, commonSourceDirGuesses_1 = commonSourceDirGuesses; _i < commonSourceDirGuesses_1.length; _i++) {
                        var commonSourceDirGuess = commonSourceDirGuesses_1[_i];
                        var candidateDirectories = getOutputDirectoriesForBaseDirectory(commonSourceDirGuess);
                        for (var _e = 0, candidateDirectories_1 = candidateDirectories; _e < candidateDirectories_1.length; _e++) {
                            var candidateDir = candidateDirectories_1[_e];
                            if (ts.containsPath(candidateDir, finalPath, !useCaseSensitiveFileNames())) {
                                // The matched export is looking up something in either the out declaration or js dir, now map the written path back into the source dir and source extension
                                var pathFragment = finalPath.slice(candidateDir.length + 1); // +1 to also remove directory seperator
                                var possibleInputBase = ts.combinePaths(commonSourceDirGuess, pathFragment);
                                var jsAndDtsExtensions = [".mjs" /* Extension.Mjs */, ".cjs" /* Extension.Cjs */, ".js" /* Extension.Js */, ".json" /* Extension.Json */, ".d.mts" /* Extension.Dmts */, ".d.cts" /* Extension.Dcts */, ".d.ts" /* Extension.Dts */];
                                for (var _f = 0, jsAndDtsExtensions_1 = jsAndDtsExtensions; _f < jsAndDtsExtensions_1.length; _f++) {
                                    var ext = jsAndDtsExtensions_1[_f];
                                    if (ts.fileExtensionIs(possibleInputBase, ext)) {
                                        var inputExts = ts.getPossibleOriginalInputExtensionForExtension(possibleInputBase);
                                        for (var _g = 0, inputExts_1 = inputExts; _g < inputExts_1.length; _g++) {
                                            var possibleExt = inputExts_1[_g];
                                            var possibleInputWithInputExtension = ts.changeAnyExtension(possibleInputBase, possibleExt, ext, !useCaseSensitiveFileNames());
                                            if ((extensions === Extensions.TypeScript && ts.hasJSFileExtension(possibleInputWithInputExtension)) ||
                                                (extensions === Extensions.JavaScript && ts.hasTSFileExtension(possibleInputWithInputExtension))) {
                                                continue;
                                            }
                                            if (state.host.fileExists(possibleInputWithInputExtension)) {
                                                return toSearchResult(withPackageId(scope, loadJSOrExactTSFileName(extensions, possibleInputWithInputExtension, /*onlyRecordFailures*/ false, state)));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return undefined;
                function getOutputDirectoriesForBaseDirectory(commonSourceDirGuess) {
                    var _a, _b;
                    // Config file ouput paths are processed to be relative to the host's current directory, while
                    // otherwise the paths are resolved relative to the common source dir the compiler puts together
                    var currentDir = state.compilerOptions.configFile ? ((_b = (_a = state.host).getCurrentDirectory) === null || _b === void 0 ? void 0 : _b.call(_a)) || "" : commonSourceDirGuess;
                    var candidateDirectories = [];
                    if (state.compilerOptions.declarationDir) {
                        candidateDirectories.push(toAbsolutePath(combineDirectoryPath(currentDir, state.compilerOptions.declarationDir)));
                    }
                    if (state.compilerOptions.outDir && state.compilerOptions.outDir !== state.compilerOptions.declarationDir) {
                        candidateDirectories.push(toAbsolutePath(combineDirectoryPath(currentDir, state.compilerOptions.outDir)));
                    }
                    return candidateDirectories;
                }
            }
        }
    }
    /* @internal */
    function isApplicableVersionedTypesKey(conditions, key) {
        if (conditions.indexOf("types") === -1)
            return false; // only apply versioned types conditions if the types condition is applied
        if (!ts.startsWith(key, "types@"))
            return false;
        var range = ts.VersionRange.tryParse(key.substring("types@".length));
        if (!range)
            return false;
        return range.test(ts.version);
    }
    ts.isApplicableVersionedTypesKey = isApplicableVersionedTypesKey;
    function loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, directory, state, cache, redirectedReference) {
        return loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName, directory, state, /*typesScopeOnly*/ false, cache, redirectedReference);
    }
    function loadModuleFromNearestNodeModulesDirectoryTypesScope(moduleName, directory, state) {
        // Extensions parameter here doesn't actually matter, because typesOnly ensures we're just doing @types lookup, which is always DtsOnly.
        return loadModuleFromNearestNodeModulesDirectoryWorker(Extensions.DtsOnly, moduleName, directory, state, /*typesScopeOnly*/ true, /*cache*/ undefined, /*redirectedReference*/ undefined);
    }
    function loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
        var perModuleNameCache = cache && cache.getOrCreateCacheForModuleName(moduleName, state.features === 0 ? undefined : state.features & NodeResolutionFeatures.EsmMode ? ts.ModuleKind.ESNext : ts.ModuleKind.CommonJS, redirectedReference);
        return ts.forEachAncestorDirectory(ts.normalizeSlashes(directory), function (ancestorDirectory) {
            if (ts.getBaseFileName(ancestorDirectory) !== "node_modules") {
                var resolutionFromCache = tryFindNonRelativeModuleNameInCache(perModuleNameCache, moduleName, ancestorDirectory, state);
                if (resolutionFromCache) {
                    return resolutionFromCache;
                }
                return toSearchResult(loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, ancestorDirectory, state, typesScopeOnly, cache, redirectedReference));
            }
        });
    }
    function loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
        var nodeModulesFolder = ts.combinePaths(directory, "node_modules");
        var nodeModulesFolderExists = ts.directoryProbablyExists(nodeModulesFolder, state.host);
        if (!nodeModulesFolderExists && state.traceEnabled) {
            trace(state.host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, nodeModulesFolder);
        }
        var packageResult = typesScopeOnly ? undefined : loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesFolder, nodeModulesFolderExists, state, cache, redirectedReference);
        if (packageResult) {
            return packageResult;
        }
        if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {
            var nodeModulesAtTypes_1 = ts.combinePaths(nodeModulesFolder, "@types");
            var nodeModulesAtTypesExists = nodeModulesFolderExists;
            if (nodeModulesFolderExists && !ts.directoryProbablyExists(nodeModulesAtTypes_1, state.host)) {
                if (state.traceEnabled) {
                    trace(state.host, ts.Diagnostics.Directory_0_does_not_exist_skipping_all_lookups_in_it, nodeModulesAtTypes_1);
                }
                nodeModulesAtTypesExists = false;
            }
            return loadModuleFromSpecificNodeModulesDirectory(Extensions.DtsOnly, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes_1, nodeModulesAtTypesExists, state, cache, redirectedReference);
        }
    }
    function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference) {
        var _a;
        var candidate = ts.normalizePath(ts.combinePaths(nodeModulesDirectory, moduleName));
        // First look for a nested package.json, as in `node_modules/foo/bar/package.json`.
        var packageInfo = getPackageJsonInfo(candidate, !nodeModulesDirectoryExists, state);
        // But only if we're not respecting export maps (if we are, we might redirect around this location)
        if (!(state.features & NodeResolutionFeatures.Exports)) {
            if (packageInfo) {
                var fromFile = loadModuleFromFile(extensions, candidate, !nodeModulesDirectoryExists, state);
                if (fromFile) {
                    return noPackageId(fromFile);
                }
                var fromDirectory = loadNodeModuleFromDirectoryWorker(extensions, candidate, !nodeModulesDirectoryExists, state, packageInfo.contents.packageJsonContent, packageInfo.contents.versionPaths);
                return withPackageId(packageInfo, fromDirectory);
            }
        }
        var loader = function (extensions, candidate, onlyRecordFailures, state) {
            var pathAndExtension = loadModuleFromFile(extensions, candidate, onlyRecordFailures, state) ||
                loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, packageInfo && packageInfo.contents.packageJsonContent, packageInfo && packageInfo.contents.versionPaths);
            if (!pathAndExtension && packageInfo
                // eslint-disable-next-line no-null/no-null
                && (packageInfo.contents.packageJsonContent.exports === undefined || packageInfo.contents.packageJsonContent.exports === null)
                && state.features & NodeResolutionFeatures.EsmMode) {
                // EsmMode disables index lookup in `loadNodeModuleFromDirectoryWorker` generally, however non-relative package resolutions still assume
                // a default `index.js` entrypoint if no `main` or `exports` are present
                pathAndExtension = loadModuleFromFile(extensions, ts.combinePaths(candidate, "index.js"), onlyRecordFailures, state);
            }
            return withPackageId(packageInfo, pathAndExtension);
        };
        var _b = parsePackageName(moduleName), packageName = _b.packageName, rest = _b.rest;
        var packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
        if (rest !== "") {
            // Previous `packageInfo` may have been from a nested package.json; ensure we have the one from the package root now.
            packageInfo = getPackageJsonInfo(packageDirectory, !nodeModulesDirectoryExists, state);
        }
        // package exports are higher priority than file/directory/typesVersions lookups and (and, if there's exports present, blocks them)
        if (packageInfo && packageInfo.contents.packageJsonContent.exports && state.features & NodeResolutionFeatures.Exports) {
            return (_a = loadModuleFromExports(packageInfo, extensions, ts.combinePaths(".", rest), state, cache, redirectedReference)) === null || _a === void 0 ? void 0 : _a.value;
        }
        if (rest !== "" && packageInfo && packageInfo.contents.versionPaths) {
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2, packageInfo.contents.versionPaths.version, ts.version, rest);
            }
            var packageDirectoryExists = nodeModulesDirectoryExists && ts.directoryProbablyExists(packageDirectory, state.host);
            var fromPaths = tryLoadModuleUsingPaths(extensions, rest, packageDirectory, packageInfo.contents.versionPaths.paths, /*pathPatterns*/ undefined, loader, !packageDirectoryExists, state);
            if (fromPaths) {
                return fromPaths.value;
            }
        }
        return loader(extensions, candidate, !nodeModulesDirectoryExists, state);
    }
    function tryLoadModuleUsingPaths(extensions, moduleName, baseDirectory, paths, pathPatterns, loader, onlyRecordFailures, state) {
        pathPatterns || (pathPatterns = ts.tryParsePatterns(paths));
        var matchedPattern = ts.matchPatternOrExact(pathPatterns, moduleName);
        if (matchedPattern) {
            var matchedStar_1 = ts.isString(matchedPattern) ? undefined : ts.matchedText(matchedPattern, moduleName);
            var matchedPatternText = ts.isString(matchedPattern) ? matchedPattern : ts.patternText(matchedPattern);
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.Module_name_0_matched_pattern_1, moduleName, matchedPatternText);
            }
            var resolved = ts.forEach(paths[matchedPatternText], function (subst) {
                var path = matchedStar_1 ? subst.replace("*", matchedStar_1) : subst;
                // When baseUrl is not specified, the command line parser resolves relative paths to the config file location.
                var candidate = ts.normalizePath(ts.combinePaths(baseDirectory, path));
                if (state.traceEnabled) {
                    trace(state.host, ts.Diagnostics.Trying_substitution_0_candidate_module_location_Colon_1, subst, path);
                }
                // A path mapping may have an extension, in contrast to an import, which should omit it.
                var extension = ts.tryGetExtensionFromPath(subst);
                if (extension !== undefined) {
                    var path_1 = tryFile(candidate, onlyRecordFailures, state);
                    if (path_1 !== undefined) {
                        return noPackageId({ path: path_1, ext: extension });
                    }
                }
                return loader(extensions, candidate, onlyRecordFailures || !ts.directoryProbablyExists(ts.getDirectoryPath(candidate), state.host), state);
            });
            return { value: resolved };
        }
    }
    /** Double underscores are used in DefinitelyTyped to delimit scoped packages. */
    var mangledScopedPackageSeparator = "__";
    /** For a scoped package, we must look in `@types/foo__bar` instead of `@types/@foo/bar`. */
    function mangleScopedPackageNameWithTrace(packageName, state) {
        var mangled = mangleScopedPackageName(packageName);
        if (state.traceEnabled && mangled !== packageName) {
            trace(state.host, ts.Diagnostics.Scoped_package_detected_looking_in_0, mangled);
        }
        return mangled;
    }
    /* @internal */
    function getTypesPackageName(packageName) {
        return "@types/".concat(mangleScopedPackageName(packageName));
    }
    ts.getTypesPackageName = getTypesPackageName;
    /* @internal */
    function mangleScopedPackageName(packageName) {
        if (ts.startsWith(packageName, "@")) {
            var replaceSlash = packageName.replace(ts.directorySeparator, mangledScopedPackageSeparator);
            if (replaceSlash !== packageName) {
                return replaceSlash.slice(1); // Take off the "@"
            }
        }
        return packageName;
    }
    ts.mangleScopedPackageName = mangleScopedPackageName;
    /* @internal */
    function getPackageNameFromTypesPackageName(mangledName) {
        var withoutAtTypePrefix = ts.removePrefix(mangledName, "@types/");
        if (withoutAtTypePrefix !== mangledName) {
            return unmangleScopedPackageName(withoutAtTypePrefix);
        }
        return mangledName;
    }
    ts.getPackageNameFromTypesPackageName = getPackageNameFromTypesPackageName;
    /* @internal */
    function unmangleScopedPackageName(typesPackageName) {
        return ts.stringContains(typesPackageName, mangledScopedPackageSeparator) ?
            "@" + typesPackageName.replace(mangledScopedPackageSeparator, ts.directorySeparator) :
            typesPackageName;
    }
    ts.unmangleScopedPackageName = unmangleScopedPackageName;
    function tryFindNonRelativeModuleNameInCache(cache, moduleName, containingDirectory, state) {
        var result = cache && cache.get(containingDirectory);
        if (result) {
            if (state.traceEnabled) {
                trace(state.host, ts.Diagnostics.Resolution_for_module_0_was_found_in_cache_from_location_1, moduleName, containingDirectory);
            }
            state.resultFromCache = result;
            return { value: result.resolvedModule && { path: result.resolvedModule.resolvedFileName, originalPath: result.resolvedModule.originalPath || true, extension: result.resolvedModule.extension, packageId: result.resolvedModule.packageId } };
        }
    }
    function classicNameResolver(moduleName, containingFile, compilerOptions, host, cache, redirectedReference) {
        var traceEnabled = isTraceEnabled(compilerOptions, host);
        var failedLookupLocations = [];
        var affectingLocations = [];
        var containingDirectory = ts.getDirectoryPath(containingFile);
        var diagnostics = [];
        var state = {
            compilerOptions: compilerOptions,
            host: host,
            traceEnabled: traceEnabled,
            failedLookupLocations: failedLookupLocations,
            affectingLocations: affectingLocations,
            packageJsonInfoCache: cache,
            features: NodeResolutionFeatures.None,
            conditions: [],
            requestContainingDirectory: containingDirectory,
            reportDiagnostic: function (diag) { return void diagnostics.push(diag); },
        };
        var resolved = tryResolve(Extensions.TypeScript) || tryResolve(Extensions.JavaScript);
        // No originalPath because classic resolution doesn't resolve realPath
        return createResolvedModuleWithFailedLookupLocations(resolved && resolved.value, 
        /*isExternalLibraryImport*/ false, failedLookupLocations, affectingLocations, diagnostics, state.resultFromCache);
        function tryResolve(extensions) {
            var resolvedUsingSettings = tryLoadModuleUsingOptionalResolutionSettings(extensions, moduleName, containingDirectory, loadModuleFromFileNoPackageId, state);
            if (resolvedUsingSettings) {
                return { value: resolvedUsingSettings };
            }
            if (!ts.isExternalModuleNameRelative(moduleName)) {
                var perModuleNameCache_1 = cache && cache.getOrCreateCacheForModuleName(moduleName, /*mode*/ undefined, redirectedReference);
                // Climb up parent directories looking for a module.
                var resolved_3 = ts.forEachAncestorDirectory(containingDirectory, function (directory) {
                    var resolutionFromCache = tryFindNonRelativeModuleNameInCache(perModuleNameCache_1, moduleName, directory, state);
                    if (resolutionFromCache) {
                        return resolutionFromCache;
                    }
                    var searchName = ts.normalizePath(ts.combinePaths(directory, moduleName));
                    return toSearchResult(loadModuleFromFileNoPackageId(extensions, searchName, /*onlyRecordFailures*/ false, state));
                });
                if (resolved_3) {
                    return resolved_3;
                }
                if (extensions === Extensions.TypeScript) {
                    // If we didn't find the file normally, look it up in @types.
                    return loadModuleFromNearestNodeModulesDirectoryTypesScope(moduleName, containingDirectory, state);
                }
            }
            else {
                var candidate = ts.normalizePath(ts.combinePaths(containingDirectory, moduleName));
                return toSearchResult(loadModuleFromFileNoPackageId(extensions, candidate, /*onlyRecordFailures*/ false, state));
            }
        }
    }
    ts.classicNameResolver = classicNameResolver;
    /**
     * A host may load a module from a global cache of typings.
     * This is the minumum code needed to expose that functionality; the rest is in the host.
     */
    /* @internal */
    function loadModuleFromGlobalCache(moduleName, projectName, compilerOptions, host, globalCache, packageJsonInfoCache) {
        var traceEnabled = isTraceEnabled(compilerOptions, host);
        if (traceEnabled) {
            trace(host, ts.Diagnostics.Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2, projectName, moduleName, globalCache);
        }
        var failedLookupLocations = [];
        var affectingLocations = [];
        var diagnostics = [];
        var state = {
            compilerOptions: compilerOptions,
            host: host,
            traceEnabled: traceEnabled,
            failedLookupLocations: failedLookupLocations,
            affectingLocations: affectingLocations,
            packageJsonInfoCache: packageJsonInfoCache,
            features: NodeResolutionFeatures.None,
            conditions: [],
            requestContainingDirectory: undefined,
            reportDiagnostic: function (diag) { return void diagnostics.push(diag); },
        };
        var resolved = loadModuleFromImmediateNodeModulesDirectory(Extensions.DtsOnly, moduleName, globalCache, state, /*typesScopeOnly*/ false, /*cache*/ undefined, /*redirectedReference*/ undefined);
        return createResolvedModuleWithFailedLookupLocations(resolved, 
        /*isExternalLibraryImport*/ true, failedLookupLocations, affectingLocations, diagnostics, state.resultFromCache);
    }
    ts.loadModuleFromGlobalCache = loadModuleFromGlobalCache;
    /**
     * Wraps value to SearchResult.
     * @returns undefined if value is undefined or { value } otherwise
     */
    function toSearchResult(value) {
        return value !== undefined ? { value: value } : undefined;
    }
    function traceIfEnabled(state, diagnostic) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        if (state.traceEnabled) {
            trace.apply(void 0, __spreadArray([state.host, diagnostic], args, false));
        }
    }
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var ModuleInstanceState;
    (function (ModuleInstanceState) {
        ModuleInstanceState[ModuleInstanceState["NonInstantiated"] = 0] = "NonInstantiated";
        ModuleInstanceState[ModuleInstanceState["Instantiated"] = 1] = "Instantiated";
        ModuleInstanceState[ModuleInstanceState["ConstEnumOnly"] = 2] = "ConstEnumOnly";
    })(ModuleInstanceState = ts.ModuleInstanceState || (ts.ModuleInstanceState = {}));
    function getModuleInstanceState(node, visited) {
        if (node.body && !node.body.parent) {
            // getModuleInstanceStateForAliasTarget needs to walk up the parent chain, so parent pointers must be set on this tree already
            ts.setParent(node.body, node);
            ts.setParentRecursive(node.body, /*incremental*/ false);
        }
        return node.body ? getModuleInstanceStateCached(node.body, visited) : 1 /* ModuleInstanceState.Instantiated */;
    }
    ts.getModuleInstanceState = getModuleInstanceState;
    function getModuleInstanceStateCached(node, visited) {
        if (visited === void 0) { visited = new ts.Map(); }
        var nodeId = ts.getNodeId(node);
        if (visited.has(nodeId)) {
            return visited.get(nodeId) || 0 /* ModuleInstanceState.NonInstantiated */;
        }
        visited.set(nodeId, undefined);
        var result = getModuleInstanceStateWorker(node, visited);
        visited.set(nodeId, result);
        return result;
    }
    function getModuleInstanceStateWorker(node, visited) {
        // A module is uninstantiated if it contains only
        switch (node.kind) {
            // 1. interface declarations, type alias declarations
            case 261 /* SyntaxKind.InterfaceDeclaration */:
            case 262 /* SyntaxKind.TypeAliasDeclaration */:
                return 0 /* ModuleInstanceState.NonInstantiated */;
            // 2. const enum declarations
            case 263 /* SyntaxKind.EnumDeclaration */:
                if (ts.isEnumConst(node)) {
                    return 2 /* ModuleInstanceState.ConstEnumOnly */;
                }
                break;
            // 3. non-exported import declarations
            case 269 /* SyntaxKind.ImportDeclaration */:
            case 268 /* SyntaxKind.ImportEqualsDeclaration */:
                if (!(ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */))) {
                    return 0 /* ModuleInstanceState.NonInstantiated */;
                }
                break;
            // 4. Export alias declarations pointing at only uninstantiated modules or things uninstantiated modules contain
            case 275 /* SyntaxKind.ExportDeclaration */:
                var exportDeclaration = node;
                if (!exportDeclaration.moduleSpecifier && exportDeclaration.exportClause && exportDeclaration.exportClause.kind === 276 /* SyntaxKind.NamedExports */) {
                    var state = 0 /* ModuleInstanceState.NonInstantiated */;
                    for (var _i = 0, _a = exportDeclaration.exportClause.elements; _i < _a.length; _i++) {
                        var specifier = _a[_i];
                        var specifierState = getModuleInstanceStateForAliasTarget(specifier, visited);
                        if (specifierState > state) {
                            state = specifierState;
                        }
                        if (state === 1 /* ModuleInstanceState.Instantiated */) {
                            return state;
                        }
                    }
                    return state;
                }
                break;
            // 5. other uninstantiated module declarations.
            case 265 /* SyntaxKind.ModuleBlock */: {
                var state_1 = 0 /* ModuleInstanceState.NonInstantiated */;
                ts.forEachChild(node, function (n) {
                    var childState = getModuleInstanceStateCached(n, visited);
                    switch (childState) {
                        case 0 /* ModuleInstanceState.NonInstantiated */:
                            // child is non-instantiated - continue searching
                            return;
                        case 2 /* ModuleInstanceState.ConstEnumOnly */:
                            // child is const enum only - record state and continue searching
                            state_1 = 2 /* ModuleInstanceState.ConstEnumOnly */;
                            return;
                        case 1 /* ModuleInstanceState.Instantiated */:
                            // child is instantiated - record state and stop
                            state_1 = 1 /* ModuleInstanceState.Instantiated */;
                            return true;
                        default:
                            ts.Debug.assertNever(childState);
                    }
                });
                return state_1;
            }
            case 264 /* SyntaxKind.ModuleDeclaration */:
                return getModuleInstanceState(node, visited);
            case 79 /* SyntaxKind.Identifier */:
                // Only jsdoc typedef definition can exist in jsdoc namespace, and it should
                // be considered the same as type alias
                if (node.isInJSDocNamespace) {
                    return 0 /* ModuleInstanceState.NonInstantiated */;
                }
        }
        return 1 /* ModuleInstanceState.Instantiated */;
    }
    function getModuleInstanceStateForAliasTarget(specifier, visited) {
        var name = specifier.propertyName || specifier.name;
        var p = specifier.parent;
        while (p) {
            if (ts.isBlock(p) || ts.isModuleBlock(p) || ts.isSourceFile(p)) {
                var statements = p.statements;
                var found = void 0;
                for (var _i = 0, statements_2 = statements; _i < statements_2.length; _i++) {
                    var statement = statements_2[_i];
                    if (ts.nodeHasName(statement, name)) {
                        if (!statement.parent) {
                            ts.setParent(statement, p);
                            ts.setParentRecursive(statement, /*incremental*/ false);
                        }
                        var state = getModuleInstanceStateCached(statement, visited);
                        if (found === undefined || state > found) {
                            found = state;
                        }
                        if (found === 1 /* ModuleInstanceState.Instantiated */) {
                            return found;
                        }
                    }
                }
                if (found !== undefined) {
                    return found;
                }
            }
            p = p.parent;
        }
        return 1 /* ModuleInstanceState.Instantiated */; // Couldn't locate, assume could ref