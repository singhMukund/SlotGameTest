(131 /* SyntaxKind.AnyKeyword */));
                        }
                    }
                    if (ts.isTypeReferenceNode(node) && ts.isInJSDoc(node) && (!existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(node, getTypeFromTypeNode(node)) || getIntendedTypeFromJSDocTypeReference(node) || unknownSymbol === resolveTypeReferenceName(node, 788968 /* SymbolFlags.Type */, /*ignoreErrors*/ true))) {
                        return ts.setOriginalNode(typeToTypeNodeHelper(getTypeFromTypeNode(node), context), node);
                    }
                    if (ts.isLiteralImportTypeNode(node)) {
                        var nodeSymbol = getNodeLinks(node).resolvedSymbol;
                        if (ts.isInJSDoc(node) &&
                            nodeSymbol &&
                            (
                            // The import type resolved using jsdoc fallback logic
                            (!node.isTypeOf && !(nodeSymbol.flags & 788968 /* SymbolFlags.Type */)) ||
                                // The import type had type arguments autofilled by js fallback logic
                                !(ts.length(node.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol))))) {
                            return ts.setOriginalNode(typeToTypeNodeHelper(getTypeFromTypeNode(node), context), node);
                        }
                        return ts.factory.updateImportTypeNode(node, ts.factory.updateLiteralTypeNode(node.argument, rewriteModuleSpecifier(node, node.argument.literal)), node.assertions, node.qualifier, ts.visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, ts.isTypeNode), node.isTypeOf);
                    }
                    if (ts.isEntityName(node) || ts.isEntityNameExpression(node)) {
                        var _a = trackExistingEntityName(node, context, includePrivateSymbol), introducesError = _a.introducesError, result = _a.node;
                        hadError = hadError || introducesError;
                        if (result !== node) {
                            return result;
                        }
                    }
                    if (file && ts.isTupleTypeNode(node) && (ts.getLineAndCharacterOfPosition(file, node.pos).line === ts.getLineAndCharacterOfPosition(file, node.end).line)) {
                        ts.setEmitFlags(node, 1 /* EmitFlags.SingleLine */);
                    }
                    return ts.visitEachChild(node, visitExistingNodeTreeSymbols, ts.nullTransformationContext);
                    function getEffectiveDotDotDotForParameter(p) {
                        return p.dotDotDotToken || (p.type && ts.isJSDocVariadicType(p.type) ? ts.factory.createToken(25 /* SyntaxKind.DotDotDotToken */) : undefined);
                    }
                    /** Note that `new:T` parameters are not handled, but should be before calling this function. */
                    function getNameForJSDocFunctionParameter(p, index) {
                        return p.name && ts.isIdentifier(p.name) && p.name.escapedText === "this" ? "this"
                            : getEffectiveDotDotDotForParameter(p) ? "args"
                                : "arg".concat(index);
                    }
                    function rewriteModuleSpecifier(parent, lit) {
                        if (bundled) {
                            if (context.tracker && context.tracker.moduleResolverHost) {
                                var targetFile = getExternalModuleFileFromDeclaration(parent);
                                if (targetFile) {
                                    var getCanonicalFileName = ts.createGetCanonicalFileName(!!host.useCaseSensitiveFileNames);
                                    var resolverHost = {
                                        getCanonicalFileName: getCanonicalFileName,
                                        getCurrentDirectory: function () { return context.tracker.moduleResolverHost.getCurrentDirectory(); },
                                        getCommonSourceDirectory: function () { return context.tracker.moduleResolverHost.getCommonSourceDirectory(); }
                                    };
                                    var newName = ts.getResolvedExternalModuleName(resolverHost, targetFile);
                                    return ts.factory.createStringLiteral(newName);
                                }
                            }
                        }
                        else {
                            if (context.tracker && context.tracker.trackExternalModuleSymbolOfImportTypeNode) {
                                var moduleSym = resolveExternalModuleNameWorker(lit, lit, /*moduleNotFoundError*/ undefined);
                                if (moduleSym) {
                                    context.tracker.trackExternalModuleSymbolOfImportTypeNode(moduleSym);
                                }
                            }
                        }
                        return lit;
                    }
                }
            }
            function symbolTableToDeclarationStatements(symbolTable, context, bundled) {
                var serializePropertySymbolForClass = makeSerializePropertySymbol(ts.factory.createPropertyDeclaration, 171 /* SyntaxKind.MethodDeclaration */, /*useAcessors*/ true);
                var serializePropertySymbolForInterfaceWorker = makeSerializePropertySymbol(function (mods, name, question, type) { return ts.factory.createPropertySignature(mods, name, question, type); }, 170 /* SyntaxKind.MethodSignature */, /*useAcessors*/ false);
                // TODO: Use `setOriginalNode` on original declaration names where possible so these declarations see some kind of
                // declaration mapping
                // We save the enclosing declaration off here so it's not adjusted by well-meaning declaration
                // emit codepaths which want to apply more specific contexts (so we can still refer to the root real declaration
                // we're trying to emit from later on)
                var enclosingDeclaration = context.enclosingDeclaration;
                var results = [];
                var visitedSymbols = new ts.Set();
                var deferredPrivatesStack = [];
                var oldcontext = context;
                context = __assign(__assign({}, oldcontext), { usedSymbolNames: new ts.Set(oldcontext.usedSymbolNames), remappedSymbolNames: new ts.Map(), tracker: __assign(__assign({}, oldcontext.tracker), { trackSymbol: function (sym, decl, meaning) {
                            var accessibleResult = isSymbolAccessible(sym, decl, meaning, /*computeAliases*/ false);
                            if (accessibleResult.accessibility === 0 /* SymbolAccessibility.Accessible */) {
                                // Lookup the root symbol of the chain of refs we'll use to access it and serialize it
                                var chain = lookupSymbolChainWorker(sym, context, meaning);
                                if (!(sym.flags & 4 /* SymbolFlags.Property */)) {
                                    includePrivateSymbol(chain[0]);
                                }
                            }
                            else if (oldcontext.tracker && oldcontext.tracker.trackSymbol) {
                                return oldcontext.tracker.trackSymbol(sym, decl, meaning);
                            }
                            return false;
                        } }) });
                context.tracker = wrapSymbolTrackerToReportForContext(context, context.tracker);
                ts.forEachEntry(symbolTable, function (symbol, name) {
                    var baseName = ts.unescapeLeadingUnderscores(name);
                    void getInternalSymbolName(symbol, baseName); // Called to cache values into `usedSymbolNames` and `remappedSymbolNames`
                });
                var addingDeclare = !bundled;
                var exportEquals = symbolTable.get("export=" /* InternalSymbolName.ExportEquals */);
                if (exportEquals && symbolTable.size > 1 && exportEquals.flags & 2097152 /* SymbolFlags.Alias */) {
                    symbolTable = ts.createSymbolTable();
                    // Remove extraneous elements from root symbol table (they'll be mixed back in when the target of the `export=` is looked up)
                    symbolTable.set("export=" /* InternalSymbolName.ExportEquals */, exportEquals);
                }
                visitSymbolTable(symbolTable);
                return mergeRedundantStatements(results);
                function isIdentifierAndNotUndefined(node) {
                    return !!node && node.kind === 79 /* SyntaxKind.Identifier */;
                }
                function getNamesOfDeclaration(statement) {
                    if (ts.isVariableStatement(statement)) {
                        return ts.filter(ts.map(statement.declarationList.declarations, ts.getNameOfDeclaration), isIdentifierAndNotUndefined);
                    }
                    return ts.filter([ts.getNameOfDeclaration(statement)], isIdentifierAndNotUndefined);
                }
                function flattenExportAssignedNamespace(statements) {
                    var exportAssignment = ts.find(statements, ts.isExportAssignment);
                    var nsIndex = ts.findIndex(statements, ts.isModuleDeclaration);
                    var ns = nsIndex !== -1 ? statements[nsIndex] : undefined;
                    if (ns && exportAssignment && exportAssignment.isExportEquals &&
                        ts.isIdentifier(exportAssignment.expression) && ts.isIdentifier(ns.name) && ts.idText(ns.name) === ts.idText(exportAssignment.expression) &&
                        ns.body && ts.isModuleBlock(ns.body)) {
                        // Pass 0: Correct situations where a module has both an `export = ns` and multiple top-level exports by stripping the export modifiers from
                        //  the top-level exports and exporting them in the targeted ns, as can occur when a js file has both typedefs and `module.export` assignments
                        var excessExports = ts.filter(statements, function (s) { return !!(ts.getEffectiveModifierFlags(s) & 1 /* ModifierFlags.Export */); });
                        var name_3 = ns.name;
                        var body = ns.body;
                        if (ts.length(excessExports)) {
                            ns = ts.factory.updateModuleDeclaration(ns, ns.modifiers, ns.name, body = ts.factory.updateModuleBlock(body, ts.factory.createNodeArray(__spreadArray(__spreadArray([], ns.body.statements, true), [ts.factory.createExportDeclaration(
                                /*modifiers*/ undefined, 
                                /*isTypeOnly*/ false, ts.factory.createNamedExports(ts.map(ts.flatMap(excessExports, function (e) { return getNamesOfDeclaration(e); }), function (id) { return ts.factory.createExportSpecifier(/*isTypeOnly*/ false, /*alias*/ undefined, id); })), 
                                /*moduleSpecifier*/ undefined)], false))));
                            statements = __spreadArray(__spreadArray(__spreadArray([], statements.slice(0, nsIndex), true), [ns], false), statements.slice(nsIndex + 1), true);
                        }
                        // Pass 1: Flatten `export namespace _exports {} export = _exports;` so long as the `export=` only points at a single namespace declaration
                        if (!ts.find(statements, function (s) { return s !== ns && ts.nodeHasName(s, name_3); })) {
                            results = [];
                            // If the namespace contains no export assignments or declarations, and no declarations flagged with `export`, then _everything_ is exported -
                            // to respect this as the top level, we need to add an `export` modifier to everything
                            var mixinExportFlag_1 = !ts.some(body.statements, function (s) { return ts.hasSyntacticModifier(s, 1 /* ModifierFlags.Export */) || ts.isExportAssignment(s) || ts.isExportDeclaration(s); });
                            ts.forEach(body.statements, function (s) {
                                addResult(s, mixinExportFlag_1 ? 1 /* ModifierFlags.Export */ : 0 /* ModifierFlags.None */); // Recalculates the ambient (and export, if applicable from above) flag
                            });
                            statements = __spreadArray(__spreadArray([], ts.filter(statements, function (s) { return s !== ns && s !== exportAssignment; }), true), results, true);
                        }
                    }
                    return statements;
                }
                function mergeExportDeclarations(statements) {
                    // Pass 2: Combine all `export {}` declarations
                    var exports = ts.filter(statements, function (d) { return ts.isExportDeclaration(d) && !d.moduleSpecifier && !!d.exportClause && ts.isNamedExports(d.exportClause); });
                    if (ts.length(exports) > 1) {
                        var nonExports = ts.filter(statements, function (d) { return !ts.isExportDeclaration(d) || !!d.moduleSpecifier || !d.exportClause; });
                        statements = __spreadArray(__spreadArray([], nonExports, true), [ts.factory.createExportDeclaration(
                            /*modifiers*/ undefined, 
                            /*isTypeOnly*/ false, ts.factory.createNamedExports(ts.flatMap(exports, function (e) { return ts.cast(e.exportClause, ts.isNamedExports).elements; })), 
                            /*moduleSpecifier*/ undefined)], false);
                    }
                    // Pass 2b: Also combine all `export {} from "..."` declarations as needed
                    var reexports = ts.filter(statements, function (d) { return ts.isExportDeclaration(d) && !!d.moduleSpecifier && !!d.exportClause && ts.isNamedExports(d.exportClause); });
                    if (ts.length(reexports) > 1) {
                        var groups = ts.group(reexports, function (decl) { return ts.isStringLiteral(decl.moduleSpecifier) ? ">" + decl.moduleSpecifier.text : ">"; });
                        if (groups.length !== reexports.length) {
                            var _loop_9 = function (group_1) {
                                if (group_1.length > 1) {
                                    // remove group members from statements and then merge group members and add back to statements
                                    statements = __spreadArray(__spreadArray([], ts.filter(statements, function (s) { return group_1.indexOf(s) === -1; }), true), [
                                        ts.factory.createExportDeclaration(
                                        /*modifiers*/ undefined, 
                                        /*isTypeOnly*/ false, ts.factory.createNamedExports(ts.flatMap(group_1, function (e) { return ts.cast(e.exportClause, ts.isNamedExports).elements; })), group_1[0].moduleSpecifier)
                                    ], false);
                                }
                            };
                            for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {
                                var group_1 = groups_1[_i];
                                _loop_9(group_1);
                            }
                        }
                    }
                    return statements;
                }
                function inlineExportModifiers(statements) {
                    // Pass 3: Move all `export {}`'s to `export` modifiers where possible
                    var index = ts.findIndex(statements, function (d) { return ts.isExportDeclaration(d) && !d.moduleSpecifier && !d.assertClause && !!d.exportClause && ts.isNamedExports(d.exportClause); });
                    if (index >= 0) {
                        var exportDecl = statements[index];
                        var replacements = ts.mapDefined(exportDecl.exportClause.elements, function (e) {
                            if (!e.propertyName) {
                                // export {name} - look thru `statements` for `name`, and if all results can take an `export` modifier, do so and filter it
                                var indices = ts.indicesOf(statements);
                                var associatedIndices = ts.filter(indices, function (i) { return ts.nodeHasName(statements[i], e.name); });
                                if (ts.length(associatedIndices) && ts.every(associatedIndices, function (i) { return ts.canHaveExportModifier(statements[i]); })) {
                                    for (var _i = 0, associatedIndices_1 = associatedIndices; _i < associatedIndices_1.length; _i++) {
                                        var index_1 = associatedIndices_1[_i];
                                        statements[index_1] = addExportModifier(statements[index_1]);
                                    }
                                    return undefined;
                                }
                            }
                            return e;
                        });
                        if (!ts.length(replacements)) {
                            // all clauses removed, remove the export declaration
                            ts.orderedRemoveItemAt(statements, index);
                        }
                        else {
                            // some items filtered, others not - update the export declaration
                            statements[index] = ts.factory.updateExportDeclaration(exportDecl, exportDecl.modifiers, exportDecl.isTypeOnly, ts.factory.updateNamedExports(exportDecl.exportClause, replacements), exportDecl.moduleSpecifier, exportDecl.assertClause);
                        }
                    }
                    return statements;
                }
                function mergeRedundantStatements(statements) {
                    statements = flattenExportAssignedNamespace(statements);
                    statements = mergeExportDeclarations(statements);
                    statements = inlineExportModifiers(statements);
                    // Not a cleanup, but as a final step: If there is a mix of `export` and non-`export` declarations, but no `export =` or `export {}` add a `export {};` so
                    // declaration privacy is respected.
                    if (enclosingDeclaration &&
                        ((ts.isSourceFile(enclosingDeclaration) && ts.isExternalOrCommonJsModule(enclosingDeclaration)) || ts.isModuleDeclaration(enclosingDeclaration)) &&
                        (!ts.some(statements, ts.isExternalModuleIndicator) || (!ts.hasScopeMarker(statements) && ts.some(statements, ts.needsScopeMarker)))) {
                        statements.push(ts.createEmptyExports(ts.factory));
                    }
                    return statements;
                }
                function addExportModifier(node) {
                    var flags = (ts.getEffectiveModifierFlags(node) | 1 /* ModifierFlags.Export */) & ~2 /* ModifierFlags.Ambient */;
                    return ts.factory.updateModifiers(node, flags);
                }
                function removeExportModifier(node) {
                    var flags = ts.getEffectiveModifierFlags(node) & ~1 /* ModifierFlags.Export */;
                    return ts.factory.updateModifiers(node, flags);
                }
                function visitSymbolTable(symbolTable, suppressNewPrivateContext, propertyAsAlias) {
                    if (!suppressNewPrivateContext) {
                        deferredPrivatesStack.push(new ts.Map());
                    }
                    symbolTable.forEach(function (symbol) {
                        serializeSymbol(symbol, /*isPrivate*/ false, !!propertyAsAlias);
                    });
                    if (!suppressNewPrivateContext) {
                        // deferredPrivates will be filled up by visiting the symbol table
                        // And will continue to iterate as elements are added while visited `deferredPrivates`
                        // (As that's how a map iterator is defined to work)
                        deferredPrivatesStack[deferredPrivatesStack.length - 1].forEach(function (symbol) {
                            serializeSymbol(symbol, /*isPrivate*/ true, !!propertyAsAlias);
                        });
                        deferredPrivatesStack.pop();
                    }
                }
                function serializeSymbol(symbol, isPrivate, propertyAsAlias) {
                    // cache visited list based on merged symbol, since we want to use the unmerged top-level symbol, but
                    // still skip reserializing it if we encounter the merged product later on
                    var visitedSym = getMergedSymbol(symbol);
                    if (visitedSymbols.has(getSymbolId(visitedSym))) {
                        return; // Already printed
                    }
                    visitedSymbols.add(getSymbolId(visitedSym));
                    // Only actually serialize symbols within the correct enclosing declaration, otherwise do nothing with the out-of-context symbol
                    var skipMembershipCheck = !isPrivate; // We only call this on exported symbols when we know they're in the correct scope
                    if (skipMembershipCheck || (!!ts.length(symbol.declarations) && ts.some(symbol.declarations, function (d) { return !!ts.findAncestor(d, function (n) { return n === enclosingDeclaration; }); }))) {
                        var oldContext = context;
                        context = cloneNodeBuilderContext(context);
                        serializeSymbolWorker(symbol, isPrivate, propertyAsAlias);
                        if (context.reportedDiagnostic) {
                            oldcontext.reportedDiagnostic = context.reportedDiagnostic; // hoist diagnostic result into outer context
                        }
                        context = oldContext;
                    }
                }
                // Synthesize declarations for a symbol - might be an Interface, a Class, a Namespace, a Type, a Variable (const, let, or var), an Alias
                // or a merge of some number of those.
                // An interesting challenge is ensuring that when classes merge with namespaces and interfaces, is keeping
                // each symbol in only one of the representations
                // Also, synthesizing a default export of some kind
                // If it's an alias: emit `export default ref`
                // If it's a property: emit `export default _default` with a `_default` prop
                // If it's a class/interface/function: emit a class/interface/function with a `default` modifier
                // These forms can merge, eg (`export default 12; export default interface A {}`)
                function serializeSymbolWorker(symbol, isPrivate, propertyAsAlias) {
                    var _a, _b, _c, _d;
                    var symbolName = ts.unescapeLeadingUnderscores(symbol.escapedName);
                    var isDefault = symbol.escapedName === "default" /* InternalSymbolName.Default */;
                    if (isPrivate && !(context.flags & 131072 /* NodeBuilderFlags.AllowAnonymousIdentifier */) && ts.isStringANonContextualKeyword(symbolName) && !isDefault) {
                        // Oh no. We cannot use this symbol's name as it's name... It's likely some jsdoc had an invalid name like `export` or `default` :(
                        context.encounteredError = true;
                        // TODO: Issue error via symbol tracker?
                        return; // If we need to emit a private with a keyword name, we're done for, since something else will try to refer to it by that name
                    }
                    var needsPostExportDefault = isDefault && !!(symbol.flags & -113 /* SymbolFlags.ExportDoesNotSupportDefaultModifier */
                        || (symbol.flags & 16 /* SymbolFlags.Function */ && ts.length(getPropertiesOfType(getTypeOfSymbol(symbol))))) && !(symbol.flags & 2097152 /* SymbolFlags.Alias */); // An alias symbol should preclude needing to make an alias ourselves
                    var needsExportDeclaration = !needsPostExportDefault && !isPrivate && ts.isStringANonContextualKeyword(symbolName) && !isDefault;
                    // `serializeVariableOrProperty` will handle adding the export declaration if it is run (since `getInternalSymbolName` will create the name mapping), so we need to ensuer we unset `needsExportDeclaration` if it is
                    if (needsPostExportDefault || needsExportDeclaration) {
                        isPrivate = true;
                    }
                    var modifierFlags = (!isPrivate ? 1 /* ModifierFlags.Export */ : 0) | (isDefault && !needsPostExportDefault ? 1024 /* ModifierFlags.Default */ : 0);
                    var isConstMergedWithNS = symbol.flags & 1536 /* SymbolFlags.Module */ &&
                        symbol.flags & (2 /* SymbolFlags.BlockScopedVariable */ | 1 /* SymbolFlags.FunctionScopedVariable */ | 4 /* SymbolFlags.Property */) &&
                        symbol.escapedName !== "export=" /* InternalSymbolName.ExportEquals */;
                    var isConstMergedWithNSPrintableAsSignatureMerge = isConstMergedWithNS && isTypeRepresentableAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol);
                    if (symbol.flags & (16 /* SymbolFlags.Function */ | 8192 /* SymbolFlags.Method */) || isConstMergedWithNSPrintableAsSignatureMerge) {
                        serializeAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol, getInternalSymbolName(symbol, symbolName), modifierFlags);
                    }
                    if (symbol.flags & 524288 /* SymbolFlags.TypeAlias */) {
                        serializeTypeAlias(symbol, symbolName, modifierFlags);
                    }
                    // Need to skip over export= symbols below - json source files get a single `Property` flagged
                    // symbol of name `export=` which needs to be handled like an alias. It's not great, but it is what it is.
                    if (symbol.flags & (2 /* SymbolFlags.BlockScopedVariable */ | 1 /* SymbolFlags.FunctionScopedVariable */ | 4 /* SymbolFlags.Property */)
                        && symbol.escapedName !== "export=" /* InternalSymbolName.ExportEquals */
                        && !(symbol.flags & 4194304 /* SymbolFlags.Prototype */)
                        && !(symbol.flags & 32 /* SymbolFlags.Class */)
                        && !(symbol.flags & 8192 /* SymbolFlags.Method */)
                        && !isConstMergedWithNSPrintableAsSignatureMerge) {
                        if (propertyAsAlias) {
                            var createdExport = serializeMaybeAliasAssignment(symbol);
                            if (createdExport) {
                                needsExportDeclaration = false;
                                needsPostExportDefault = false;
                            }
                        }
                        else {
                            var type = getTypeOfSymbol(symbol);
                            var localName = getInternalSymbolName(symbol, symbolName);
                            if (!(symbol.flags & 16 /* SymbolFlags.Function */) && isTypeRepresentableAsFunctionNamespaceMerge(type, symbol)) {
                                // If the type looks like a function declaration + ns could represent it, and it's type is sourced locally, rewrite it into a function declaration + ns
                                serializeAsFunctionNamespaceMerge(type, symbol, localName, modifierFlags);
                            }
                            else {
                                // A Class + Property merge is made for a `module.exports.Member = class {}`, and it doesn't serialize well as either a class _or_ a property symbol - in fact, _it behaves like an alias!_
                                // `var` is `FunctionScopedVariable`, `const` and `let` are `BlockScopedVariable`, and `module.exports.thing =` is `Property`
                                var flags = !(symbol.flags & 2 /* SymbolFlags.BlockScopedVariable */)
                                    ? ((_a = symbol.parent) === null || _a === void 0 ? void 0 : _a.valueDeclaration) && ts.isSourceFile((_b = symbol.parent) === null || _b === void 0 ? void 0 : _b.valueDeclaration)
                                        ? 2 /* NodeFlags.Const */
                                        : undefined
                                    : isConstVariable(symbol)
                                        ? 2 /* NodeFlags.Const */
                                        : 1 /* NodeFlags.Let */;
                                var name = (needsPostExportDefault || !(symbol.flags & 4 /* SymbolFlags.Property */)) ? localName : getUnusedName(localName, symbol);
                                var textRange = symbol.declarations && ts.find(symbol.declarations, function (d) { return ts.isVariableDeclaration(d); });
                                if (textRange && ts.isVariableDeclarationList(textRange.parent) && textRange.parent.declarations.length === 1) {
                                    textRange = textRange.parent.parent;
                                }
                                var propertyAccessRequire = (_c = symbol.declarations) === null || _c === void 0 ? void 0 : _c.find(ts.isPropertyAccessExpression);
                                if (propertyAccessRequire && ts.isBinaryExpression(propertyAccessRequire.parent) && ts.isIdentifier(propertyAccessRequire.parent.right)
                                    && ((_d = type.symbol) === null || _d === void 0 ? void 0 : _d.valueDeclaration) && ts.isSourceFile(type.symbol.valueDeclaration)) {
                                    var alias = localName === propertyAccessRequire.parent.right.escapedText ? undefined : propertyAccessRequire.parent.right;
                                    addResult(ts.factory.createExportDeclaration(
                                    /*modifiers*/ undefined, 
                                    /*isTypeOnly*/ false, ts.factory.createNamedExports([ts.factory.createExportSpecifier(/*isTypeOnly*/ false, alias, localName)])), 0 /* ModifierFlags.None */);
                                    context.tracker.trackSymbol(type.symbol, context.enclosingDeclaration, 111551 /* SymbolFlags.Value */);
                                }
                                else {
                                    var statement = ts.setTextRange(ts.factory.createVariableStatement(/*modifiers*/ undefined, ts.factory.createVariableDeclarationList([
                                        ts.factory.createVariableDeclaration(name, /*exclamationToken*/ undefined, serializeTypeForDeclaration(context, type, symbol, enclosingDeclaration, includePrivateSymbol, bundled))
                                    ], flags)), textRange);
                                    addResult(statement, name !== localName ? modifierFlags & ~1 /* ModifierFlags.Export */ : modifierFlags);
                                    if (name !== localName && !isPrivate) {
                                        // We rename the variable declaration we generate for Property symbols since they may have a name which
                                        // conflicts with a local declaration. For example, given input:
                                        // ```
                                        // function g() {}
                                        // module.exports.g = g
                                        // ```
                                        // In such a situation, we have a local variable named `g`, and a separate exported variable named `g`.
                                        // Naively, we would emit
                                        // ```
                                        // function g() {}
                                        // export const g: typeof g;
                                        // ```
                                        // That's obviously incorrect - the `g` in the type annotation needs to refer to the local `g`, but
                                        // the export declaration shadows it.
                                        // To work around that, we instead write
                                        // ```
                                        // function g() {}
                                        // const g_1: typeof g;
                                        // export { g_1 as g };
                                        // ```
                                        // To create an export named `g` that does _not_ shadow the local `g`
                                        addResult(ts.factory.createExportDeclaration(
                                        /*modifiers*/ undefined, 
                                        /*isTypeOnly*/ false, ts.factory.createNamedExports([ts.factory.createExportSpecifier(/*isTypeOnly*/ false, name, localName)])), 0 /* ModifierFlags.None */);
                                        needsExportDeclaration = false;
                                        needsPostExportDefault = false;
                                    }
                                }
                            }
                        }
                    }
                    if (symbol.flags & 384 /* SymbolFlags.Enum */) {
                        serializeEnum(symbol, symbolName, modifierFlags);
                    }
                    if (symbol.flags & 32 /* SymbolFlags.Class */) {
                        if (symbol.flags & 4 /* SymbolFlags.Property */
                            && symbol.valueDeclaration
                            && ts.isBinaryExpression(symbol.valueDeclaration.parent)
                            && ts.isClassExpression(symbol.valueDeclaration.parent.right)) {
                            // Looks like a `module.exports.Sub = class {}` - if we serialize `symbol` as a class, the result will have no members,
                            // since the classiness is actually from the target of the effective alias the symbol is. yes. A BlockScopedVariable|Class|Property
                            // _really_ acts like an Alias, and none of a BlockScopedVariable, Class, or Property. This is the travesty of JS binding today.
                            serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags);
                        }
                        else {
                            serializeAsClass(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags);
                        }
                    }
                    if ((symbol.flags & (512 /* SymbolFlags.ValueModule */ | 1024 /* SymbolFlags.NamespaceModule */) && (!isConstMergedWithNS || isTypeOnlyNamespace(symbol))) || isConstMergedWithNSPrintableAsSignatureMerge) {
                        serializeModule(symbol, symbolName, modifierFlags);
                    }
                    // The class meaning serialization should handle serializing all interface members
                    if (symbol.flags & 64 /* SymbolFlags.Interface */ && !(symbol.flags & 32 /* SymbolFlags.Class */)) {
                        serializeInterface(symbol, symbolName, modifierFlags);
                    }
                    if (symbol.flags & 2097152 /* SymbolFlags.Alias */) {
                        serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags);
                    }
                    if (symbol.flags & 4 /* SymbolFlags.Property */ && symbol.escapedName === "export=" /* InternalSymbolName.ExportEquals */) {
                        serializeMaybeAliasAssignment(symbol);
                    }
                    if (symbol.flags & 8388608 /* SymbolFlags.ExportStar */) {
                        // synthesize export * from "moduleReference"
                        // Straightforward - only one thing to do - make an export declaration
                        if (symbol.declarations) {
                            for (var _i = 0, _e = symbol.declarations; _i < _e.length; _i++) {
                                var node = _e[_i];
                                var resolvedModule = resolveExternalModuleName(node, node.moduleSpecifier);
                                if (!resolvedModule)
                                    continue;
                                addResult(ts.factory.createExportDeclaration(/*modifiers*/ undefined, /*isTypeOnly*/ false, /*exportClause*/ undefined, ts.factory.createStringLiteral(getSpecifierForModuleSymbol(resolvedModule, context))), 0 /* ModifierFlags.None */);
                            }
                        }
                    }
                    if (needsPostExportDefault) {
                        addResult(ts.factory.createExportAssignment(/*modifiers*/ undefined, /*isExportAssignment*/ false, ts.factory.createIdentifier(getInternalSymbolName(symbol, symbolName))), 0 /* ModifierFlags.None */);
                    }
                    else if (needsExportDeclaration) {
                        addResult(ts.factory.createExportDeclaration(
                        /*modifiers*/ undefined, 
                        /*isTypeOnly*/ false, ts.factory.createNamedExports([ts.factory.createExportSpecifier(/*isTypeOnly*/ false, getInternalSymbolName(symbol, symbolName), symbolName)])), 0 /* ModifierFlags.None */);
                    }
                }
                function includePrivateSymbol(symbol) {
                    if (ts.some(symbol.declarations, ts.isParameterDeclaration))
                        return;
                    ts.Debug.assertIsDefined(deferredPrivatesStack[deferredPrivatesStack.length - 1]);
                    getUnusedName(ts.unescapeLeadingUnderscores(symbol.escapedName), symbol); // Call to cache unique name for symbol
                    // Blanket moving (import) aliases into the root private context should work, since imports are not valid within namespaces
                    // (so they must have been in the root to begin with if they were real imports) cjs `require` aliases (an upcoming feature)
                    // will throw a wrench in this, since those may have been nested, but we'll need to synthesize them in the outer scope
                    // anyway, as that's the only place the import they translate to is valid. In such a case, we might need to use a unique name
                    // for the moved import; which hopefully the above `getUnusedName` call should produce.
                    var isExternalImportAlias = !!(symbol.flags & 2097152 /* SymbolFlags.Alias */) && !ts.some(symbol.declarations, function (d) {
                        return !!ts.findAncestor(d, ts.isExportDeclaration) ||
                            ts.isNamespaceExport(d) ||
                            (ts.isImportEqualsDeclaration(d) && !ts.isExternalModuleReference(d.moduleReference));
                    });
                    deferredPrivatesStack[isExternalImportAlias ? 0 : (deferredPrivatesStack.length - 1)].set(getSymbolId(symbol), symbol);
                }
                function isExportingScope(enclosingDeclaration) {
                    return ((ts.isSourceFile(enclosingDeclaration) && (ts.isExternalOrCommonJsModule(enclosingDeclaration) || ts.isJsonSourceFile(enclosingDeclaration))) ||
                        (ts.isAmbientModule(enclosingDeclaration) && !ts.isGlobalScopeAugmentation(enclosingDeclaration)));
                }
                // Prepends a `declare` and/or `export` modifier if the context requires it, and then adds `node` to `result` and returns `node`
                function addResult(node, additionalModifierFlags) {
                    if (ts.canHaveModifiers(node)) {
                        var newModifierFlags = 0 /* ModifierFlags.None */;
                        var enclosingDeclaration_1 = context.enclosingDeclaration &&
                            (ts.isJSDocTypeAlias(context.enclosingDeclaration) ? ts.getSourceFileOfNode(context.enclosingDeclaration) : context.enclosingDeclaration);
                        if (additionalModifierFlags & 1 /* ModifierFlags.Export */ &&
                            enclosingDeclaration_1 && (isExportingScope(enclosingDeclaration_1) || ts.isModuleDeclaration(enclosingDeclaration_1)) &&
                            ts.canHaveExportModifier(node)) {
                            // Classes, namespaces, variables, functions, interfaces, and types should all be `export`ed in a module context if not private
                            newModifierFlags |= 1 /* ModifierFlags.Export */;
                        }
                        if (addingDeclare && !(newModifierFlags & 1 /* ModifierFlags.Export */) &&
                            (!enclosingDeclaration_1 || !(enclosingDeclaration_1.flags & 16777216 /* NodeFlags.Ambient */)) &&
                            (ts.isEnumDeclaration(node) || ts.isVariableStatement(node) || ts.isFunctionDeclaration(node) || ts.isClassDeclaration(node) || ts.isModuleDeclaration(node))) {
                            // Classes, namespaces, variables, enums, and functions all need `declare` modifiers to be valid in a declaration file top-level scope
                            newModifierFlags |= 2 /* ModifierFlags.Ambient */;
                        }
                        if ((additionalModifierFlags & 1024 /* ModifierFlags.Default */) && (ts.isClassDeclaration(node) || ts.isInterfaceDeclaration(node) || ts.isFunctionDeclaration(node))) {
                            newModifierFlags |= 1024 /* ModifierFlags.Default */;
                        }
                        if (newModifierFlags) {
                            node = ts.factory.updateModifiers(node, newModifierFlags | ts.getEffectiveModifierFlags(node));
                        }
                    }
                    results.push(node);
                }
                function serializeTypeAlias(symbol, symbolName, modifierFlags) {
                    var _a;
                    var aliasType = getDeclaredTypeOfTypeAlias(symbol);
                    var typeParams = getSymbolLinks(symbol).typeParameters;
                    var typeParamDecls = ts.map(typeParams, function (p) { return typeParameterToDeclaration(p, context); });
                    var jsdocAliasDecl = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isJSDocTypeAlias);
                    var commentText = ts.getTextOfJSDocComment(jsdocAliasDecl ? jsdocAliasDecl.comment || jsdocAliasDecl.parent.comment : undefined);
                    var oldFlags = context.flags;
                    context.flags |= 8388608 /* NodeBuilderFlags.InTypeAlias */;
                    var oldEnclosingDecl = context.enclosingDeclaration;
                    context.enclosingDeclaration = jsdocAliasDecl;
                    var typeNode = jsdocAliasDecl && jsdocAliasDecl.typeExpression
                        && ts.isJSDocTypeExpression(jsdocAliasDecl.typeExpression)
                        && serializeExistingTypeNode(context, jsdocAliasDecl.typeExpression.type, includePrivateSymbol, bundled)
                        || typeToTypeNodeHelper(aliasType, context);
                    addResult(ts.setSyntheticLeadingComments(ts.factory.createTypeAliasDeclaration(/*modifiers*/ undefined, getInternalSymbolName(symbol, symbolName), typeParamDecls, typeNode), !commentText ? [] : [{ kind: 3 /* SyntaxKind.MultiLineCommentTrivia */, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }]), modifierFlags);
                    context.flags = oldFlags;
                    context.enclosingDeclaration = oldEnclosingDecl;
                }
                function serializeInterface(symbol, symbolName, modifierFlags) {
                    var interfaceType = getDeclaredTypeOfClassOrInterface(symbol);
                    var localParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                    var typeParamDecls = ts.map(localParams, function (p) { return typeParameterToDeclaration(p, context); });
                    var baseTypes = getBaseTypes(interfaceType);
                    var baseType = ts.length(baseTypes) ? getIntersectionType(baseTypes) : undefined;
                    var members = ts.flatMap(getPropertiesOfType(interfaceType), function (p) { return serializePropertySymbolForInterface(p, baseType); });
                    var callSignatures = serializeSignatures(0 /* SignatureKind.Call */, interfaceType, baseType, 176 /* SyntaxKind.CallSignature */);
                    var constructSignatures = serializeSignatures(1 /* SignatureKind.Construct */, interfaceType, baseType, 177 /* SyntaxKind.ConstructSignature */);
                    var indexSignatures = serializeIndexSignatures(interfaceType, baseType);
                    var heritageClauses = !ts.length(baseTypes) ? undefined : [ts.factory.createHeritageClause(94 /* SyntaxKind.ExtendsKeyword */, ts.mapDefined(baseTypes, function (b) { return trySerializeAsTypeReference(b, 111551 /* SymbolFlags.Value */); }))];
                    addResult(ts.factory.createInterfaceDeclaration(
                    /*modifiers*/ undefined, getInternalSymbolName(symbol, symbolName), typeParamDecls, heritageClauses, __spreadArray(__spreadArray(__spreadArray(__spreadArray([], indexSignatures, true), constructSignatures, true), callSignatures, true), members, true)), modifierFlags);
                }
                function getNamespaceMembersForSerialization(symbol) {
                    return !symbol.exports ? [] : ts.filter(ts.arrayFrom(symbol.exports.values()), isNamespaceMember);
                }
                function isTypeOnlyNamespace(symbol) {
                    return ts.every(getNamespaceMembersForSerialization(symbol), function (m) { return !(getAllSymbolFlags(resolveSymbol(m)) & 111551 /* SymbolFlags.Value */); });
                }
                function serializeModule(symbol, symbolName, modifierFlags) {
                    var members = getNamespaceMembersForSerialization(symbol);
                    // Split NS members up by declaration - members whose parent symbol is the ns symbol vs those whose is not (but were added in later via merging)
                    var locationMap = ts.arrayToMultiMap(members, function (m) { return m.parent && m.parent === symbol ? "real" : "merged"; });
                    var realMembers = locationMap.get("real") || ts.emptyArray;
                    var mergedMembers = locationMap.get("merged") || ts.emptyArray;
                    // TODO: `suppressNewPrivateContext` is questionable -we need to simply be emitting privates in whatever scope they were declared in, rather
                    // than whatever scope we traverse to them in. That's a bit of a complex rewrite, since we're not _actually_ tracking privates at all in advance,
                    // so we don't even have placeholders to fill in.
                    if (ts.length(realMembers)) {
                        var localName = getInternalSymbolName(symbol, symbolName);
                        serializeAsNamespaceDeclaration(realMembers, localName, modifierFlags, !!(symbol.flags & (16 /* SymbolFlags.Function */ | 67108864 /* SymbolFlags.Assignment */)));
                    }
                    if (ts.length(mergedMembers)) {
                        var containingFile_1 = ts.getSourceFileOfNode(context.enclosingDeclaration);
                        var localName = getInternalSymbolName(symbol, symbolName);
                        var nsBody = ts.factory.createModuleBlock([ts.factory.createExportDeclaration(
                            /*modifiers*/ undefined, 
                            /*isTypeOnly*/ false, ts.factory.createNamedExports(ts.mapDefined(ts.filter(mergedMembers, function (n) { return n.escapedName !== "export=" /* InternalSymbolName.ExportEquals */; }), function (s) {
                                var _a, _b;
                                var name = ts.unescapeLeadingUnderscores(s.escapedName);
                                var localName = getInternalSymbolName(s, name);
                                var aliasDecl = s.declarations && getDeclarationOfAliasSymbol(s);
                                if (containingFile_1 && (aliasDecl ? containingFile_1 !== ts.getSourceFileOfNode(aliasDecl) : !ts.some(s.declarations, function (d) { return ts.getSourceFileOfNode(d) === containingFile_1; }))) {
                                    (_b = (_a = context.tracker) === null || _a === void 0 ? void 0 : _a.reportNonlocalAugmentation) === null || _b === void 0 ? void 0 : _b.call(_a, containingFile_1, symbol, s);
                                    return undefined;
                                }
                                var target = aliasDecl && getTargetOfAliasDeclaration(aliasDecl, /*dontRecursivelyResolve*/ true);
                                includePrivateSymbol(target || s);
                                var targetName = target ? getInternalSymbolName(target, ts.unescapeLeadingUnderscores(target.escapedName)) : localName;
                                return ts.factory.createExportSpecifier(/*isTypeOnly*/ false, name === targetName ? undefined : targetName, name);
                            })))]);
                        addResult(ts.factory.createModuleDeclaration(
                        /*modifiers*/ undefined, ts.factory.createIdentifier(localName), nsBody, 16 /* NodeFlags.Namespace */), 0 /* ModifierFlags.None */);
                    }
                }
                function serializeEnum(symbol, symbolName, modifierFlags) {
                    addResult(ts.factory.createEnumDeclaration(ts.factory.createModifiersFromModifierFlags(isConstEnumSymbol(symbol) ? 2048 /* ModifierFlags.Const */ : 0), getInternalSymbolName(symbol, symbolName), ts.map(ts.filter(getPropertiesOfType(getTypeOfSymbol(symbol)), function (p) { return !!(p.flags & 8 /* SymbolFlags.EnumMember */); }), function (p) {
                        // TODO: Handle computed names
                        // I hate that to get the initialized value we need to walk back to the declarations here; but there's no
                        // other way to get the possible const value of an enum member that I'm aware of, as the value is cached
                        // _on the declaration_, not on the declaration's symbol...
                        var initializedValue = p.declarations && p.declarations[0] && ts.isEnumMember(p.declarations[0]) ? getConstantValue(p.declarations[0]) : undefined;
                        return ts.factory.createEnumMember(ts.unescapeLeadingUnderscores(p.escapedName), initializedValue === undefined ? undefined :
                            typeof initializedValue === "string" ? ts.factory.createStringLiteral(initializedValue) :
                                ts.factory.createNumericLiteral(initializedValue));
                    })), modifierFlags);
                }
                function serializeAsFunctionNamespaceMerge(type, symbol, localName, modifierFlags) {
                    var signatures = getSignaturesOfType(type, 0 /* SignatureKind.Call */);
                    for (var _i = 0, signatures_2 = signatures; _i < signatures_2.length; _i++) {
                        var sig = signatures_2[_i];
                        // Each overload becomes a separate function declaration, in order
                        var decl = signatureToSignatureDeclarationHelper(sig, 259 /* SyntaxKind.FunctionDeclaration */, context, { name: ts.factory.createIdentifier(localName), privateSymbolVisitor: includePrivateSymbol, bundledImports: bundled });
                        addResult(ts.setTextRange(decl, getSignatureTextRangeLocation(sig)), modifierFlags);
                    }
                    // Module symbol emit will take care of module-y members, provided it has exports
                    if (!(symbol.flags & (512 /* SymbolFlags.ValueModule */ | 1024 /* SymbolFlags.NamespaceModule */) && !!symbol.exports && !!symbol.exports.size)) {
                        var props = ts.filter(getPropertiesOfType(type), isNamespaceMember);
                        serializeAsNamespaceDeclaration(props, localName, modifierFlags, /*suppressNewPrivateContext*/ true);
                    }
                }
                function getSignatureTextRangeLocation(signature) {
                    if (signature.declaration && signature.declaration.parent) {
                        if (ts.isBinaryExpression(signature.declaration.parent) && ts.getAssignmentDeclarationKind(signature.declaration.parent) === 5 /* AssignmentDeclarationKind.Property */) {
                            return signature.declaration.parent;
                        }
                        // for expressions assigned to `var`s, use the `var` as the text range
                        if (ts.isVariableDeclaration(signature.declaration.parent) && signature.declaration.parent.parent) {
                            return signature.declaration.parent.parent;
                        }
                    }
                    return signature.declaration;
                }
                function serializeAsNamespaceDeclaration(props, localName, modifierFlags, suppressNewPrivateContext) {
                    if (ts.length(props)) {
                        var localVsRemoteMap = ts.arrayToMultiMap(props, function (p) {
                            return !ts.length(p.declarations) || ts.some(p.declarations, function (d) {
                                return ts.getSourceFileOfNode(d) === ts.getSourceFileOfNode(context.enclosingDeclaration);
                            }) ? "local" : "remote";
                        });
                        var localProps = localVsRemoteMap.get("local") || ts.emptyArray;
                        // handle remote props first - we need to make an `import` declaration that points at the module containing each remote
                        // prop in the outermost scope (TODO: a namespace within a namespace would need to be appropriately handled by this)
                        // Example:
                        // import Foo_1 = require("./exporter");
                        // export namespace ns {
                        //     import Foo = Foo_1.Foo;
                        //     export { Foo };
                        //     export const c: number;
                        // }
                        // This is needed because in JS, statements like `const x = require("./f")` support both type and value lookup, even if they're
                        // normally just value lookup (so it functions kinda like an alias even when it's not an alias)
                        // _Usually_, we'll simply print the top-level as an alias instead of a `var` in such situations, however is is theoretically
                        // possible to encounter a situation where a type has members from both the current file and other files - in those situations,
                        // emit akin to the above would be needed.
                        // Add a namespace
                        // Create namespace as non-synthetic so it is usable as an enclosing declaration
                        var fakespace = ts.parseNodeFactory.createModuleDeclaration(/*modifiers*/ undefined, ts.factory.createIdentifier(localName), ts.factory.createModuleBlock([]), 16 /* NodeFlags.Namespace */);
                        ts.setParent(fakespace, enclosingDeclaration);
                        fakespace.locals = ts.createSymbolTable(props);
                        fakespace.symbol = props[0].parent;
                        var oldResults = results;
                        results = [];
                        var oldAddingDeclare = addingDeclare;
                        addingDeclare = false;
                        var subcontext = __assign(__assign({}, context), { enclosingDeclaration: fakespace });
                        var oldContext = context;
                        context = subcontext;
                        // TODO: implement handling for the localVsRemoteMap.get("remote") - should be difficult to trigger (see comment above), as only interesting cross-file js merges should make this possible
                        visitSymbolTable(ts.createSymbolTable(localProps), suppressNewPrivateContext, /*propertyAsAlias*/ true);
                        context = oldContext;
                        addingDeclare = oldAddingDeclare;
                        var declarations = results;
                        results = oldResults;
                        // replace namespace with synthetic version
                        var defaultReplaced = ts.map(declarations, function (d) { return ts.isExportAssignment(d) && !d.isExportEquals && ts.isIdentifier(d.expression) ? ts.factory.createExportDeclaration(
                        /*modifiers*/ undefined, 
                        /*isTypeOnly*/ false, ts.factory.createNamedExports([ts.factory.createExportSpecifier(/*isTypeOnly*/ false, d.expression, ts.factory.createIdentifier("default" /* InternalSymbolName.Default */))])) : d; });
                        var exportModifierStripped = ts.every(defaultReplaced, function (d) { return ts.hasSyntacticModifier(d, 1 /* ModifierFlags.Export */); }) ? ts.map(defaultReplaced, removeExportModifier) : defaultReplaced;
                        fakespace = ts.factory.updateModuleDeclaration(fakespace, fakespace.modifiers, fakespace.name, ts.factory.createModuleBlock(exportModifierStripped));
                        addResult(fakespace, modifierFlags); // namespaces can never be default exported
                    }
                }
                function isNamespaceMember(p) {
                    return !!(p.flags & (788968 /* SymbolFlags.Type */ | 1920 /* SymbolFlags.Namespace */ | 2097152 /* SymbolFlags.Alias */)) ||
                        !(p.flags & 4194304 /* SymbolFlags.Prototype */ || p.escapedName === "prototype" || p.valueDeclaration && ts.isStatic(p.valueDeclaration) && ts.isClassLike(p.valueDeclaration.parent));
                }
                function sanitizeJSDocImplements(clauses) {
                    var result = ts.mapDefined(clauses, function (e) {
                        var _a;
                        var oldEnclosing = context.enclosingDeclaration;
                        context.enclosingDeclaration = e;
                        var expr = e.expression;
                        if (ts.isEntityNameExpression(expr)) {
                            if (ts.isIdentifier(expr) && ts.idText(expr) === "") {
                                return cleanup(/*result*/ undefined); // Empty heritage clause, should be an error, but prefer emitting no heritage clauses to reemitting the empty one
                            }
                            var introducesError = void 0;
                            (_a = trackExistingEntityName(expr, context, includePrivateSymbol), introducesError = _a.introducesError, expr = _a.node);
                            if (introducesError) {
                                return cleanup(/*result*/ undefined);
                            }
                        }
                        return cleanup(ts.factory.createExpressionWithTypeArguments(expr, ts.map(e.typeArguments, function (a) {
                            return serializeExistingTypeNode(context, a, includePrivateSymbol, bundled)
                                || typeToTypeNodeHelper(getTypeFromTypeNode(a), context);
                        })));
                        function cleanup(result) {
                            context.enclosingDeclaration = oldEnclosing;
                            return result;
                        }
                    });
                    if (result.length === clauses.length) {
                        return result;
                    }
                    return undefined;
                }
                function serializeAsClass(symbol, localName, modifierFlags) {
                    var _a, _b;
                    var originalDecl = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isClassLike);
                    var oldEnclosing = context.enclosingDeclaration;
                    context.enclosingDeclaration = originalDecl || oldEnclosing;
                    var localParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                    var typeParamDecls = ts.map(localParams, function (p) { return typeParameterToDeclaration(p, context); });
                    var classType = getDeclaredTypeOfClassOrInterface(symbol);
                    var baseTypes = getBaseTypes(classType);
                    var originalImplements = originalDecl && ts.getEffectiveImplementsTypeNodes(originalDecl);
                    var implementsExpressions = originalImplements && sanitizeJSDocImplements(originalImplements)
                        || ts.mapDefined(getImplementsTypes(classType), serializeImplementedType);
                    var staticType = getTypeOfSymbol(symbol);
                    var isClass = !!((_b = staticType.symbol) === null || _b === void 0 ? void 0 : _b.valueDeclaration) && ts.isClassLike(staticType.symbol.valueDeclaration);
                    var staticBaseType = isClass
                        ? getBaseConstructorTypeOfClass(staticType)
                        : anyType;
                    var heritageClauses = __spreadArray(__spreadArray([], !ts.length(baseTypes) ? [] : [ts.factory.createHeritageClause(94 /* SyntaxKind.ExtendsKeyword */, ts.map(baseTypes, function (b) { return serializeBaseType(b, staticBaseType, localName); }))], true), !ts.length(implementsExpressions) ? [] : [ts.factory.createHeritageClause(117 /* SyntaxKind.ImplementsKeyword */, implementsExpressions)], true);
                    var symbolProps = getNonInheritedProperties(classType, baseTypes, getPropertiesOfType(classType));
                    var publicSymbolProps = ts.filter(symbolProps, function (s) {
                        // `valueDeclaration` could be undefined if inherited from
                        // a union/intersection base type, but inherited properties
                        // don't matter here.
                        var valueDecl = s.valueDeclaration;
                        return !!valueDecl && !(ts.isNamedDeclaration(valueDecl) && ts.isPrivateIdentifier(valueDecl.name));
                    });
                    var hasPrivateIdentifier = ts.some(symbolProps, function (s) {
                        // `valueDeclaration` could be undefined if inherited from
                        // a union/intersection base type, but inherited properties
                        // don't matter here.
                        var valueDecl = s.valueDeclaration;
                        return !!valueDecl && ts.isNamedDeclaration(valueDecl) && ts.isPrivateIdentifier(valueDecl.name);
                    });
                    // Boil down all private properties into a single one.
                    var privateProperties = hasPrivateIdentifier ?
                        [ts.factory.createPropertyDeclaration(
                            /*modifiers*/ undefined, ts.factory.createPrivateIdentifier("#private"), 
                            /*questionOrExclamationToken*/ undefined, 
                            /*type*/ undefined, 
                            /*initializer*/ undefined)] :
                        ts.emptyArray;
                    var publicProperties = ts.flatMap(publicSymbolProps, function (p) { return serializePropertySymbolForClass(p, /*isStatic*/ false, baseTypes[0]); });
                    // Consider static members empty if symbol also has function or module meaning - function namespacey emit will handle statics
                    var staticMembers = ts.flatMap(ts.filter(getPropertiesOfType(staticType), function (p) { return !(p.flags & 4194304 /* SymbolFlags.Prototype */) && p.escapedName !== "prototype" && !isNamespaceMember(p); }), function (p) { return serializePropertySymbolForClass(p, /*isStatic*/ true, staticBaseType); });
                    // When we encounter an `X.prototype.y` assignment in a JS file, we bind `X` as a class regardless as to whether
                    // the value is ever initialized with a class or function-like value. For cases where `X` could never be
                    // created via `new`, we will inject a `private constructor()` declaration to indicate it is not createable.
                    var isNonConstructableClassLikeInJsFile = !isClass &&
                        !!symbol.valueDeclaration &&
                        ts.isInJSFile(symbol.valueDeclaration) &&
                        !ts.some(getSignaturesOfType(staticType, 1 /* SignatureKind.Construct */));
                    var constructors = isNonConstructableClassLikeInJsFile ?
                        [ts.factory.createConstructorDeclaration(ts.factory.createModifiersFromModifierFlags(8 /* ModifierFlags.Private */), [], /*body*/ undefined)] :
                        serializeSignatures(1 /* SignatureKind.Construct */, staticType, staticBaseType, 173 /* SyntaxKind.Constructor */);
                    var indexSignatures = serializeIndexSignatures(classType, baseTypes[0]);
                    context.enclosingDeclaration = oldEnclosing;
                    addResult(ts.setTextRange(ts.factory.createClassDeclaration(
                    /*modifiers*/ undefined, localName, typeParamDecls, heritageClauses, __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], indexSignatures, true), staticMembers, true), constructors, true), publicProperties, true), privateProperties, true)), symbol.declarations && ts.filter(symbol.declarations, function (d) { return ts.isClassDeclaration(d) || ts.isClassExpression(d); })[0]), modifierFlags);
                }
                function getSomeTargetNameFromDeclarations(declarations) {
                    return ts.firstDefined(declarations, function (d) {
                        if (ts.isImportSpecifier(d) || ts.isExportSpecifier(d)) {
                            return ts.idText(d.propertyName || d.name);
                        }
                        if (ts.isBinaryExpression(d) || ts.isExportAssignment(d)) {
                            var expression = ts.isExportAssignment(d) ? d.expression : d.right;
                            if (ts.isPropertyAccessExpression(expression)) {
                                return ts.idText(expression.name);
                            }
                        }
                        if (isAliasSymbolDeclaration(d)) {
                            // This is... heuristic, at best. But it's probably better than always printing the name of the shorthand ambient module.
                            var name = ts.getNameOfDeclaration(d);
                            if (name && ts.isIdentifier(name)) {
                                return ts.idText(name);
                            }
                        }
                        return undefined;
                    });
                }
                function serializeAsAlias(symbol, localName, modifierFlags) {
                    var _a, _b, _c, _d, _e;
                    // synthesize an alias, eg `export { symbolName as Name }`
                    // need to mark the alias `symbol` points at
                    // as something we need to serialize as a private declaration as well
                    var node = getDeclarationOfAliasSymbol(symbol);
                    if (!node)
                        return ts.Debug.fail();
                    var target = getMergedSymbol(getTargetOfAliasDeclaration(node, /*dontRecursivelyResolve*/ true));
                    if (!target) {
                        return;
                    }
                    // If `target` refers to a shorthand module symbol, the name we're trying to pull out isn;t recoverable from the target symbol
                    // In such a scenario, we must fall back to looking for an alias declaration on `symbol` and pulling the target name from that
                    var verbatimTargetName = ts.isShorthandAmbientModuleSymbol(target) && getSomeTargetNameFromDeclarations(symbol.declarations) || ts.unescapeLeadingUnderscores(target.escapedName);
                    if (verbatimTargetName === "export=" /* InternalSymbolName.ExportEquals */ && (ts.getESModuleInterop(compilerOptions) || compilerOptions.allowSyntheticDefaultImports)) {
                        // target refers to an `export=` symbol that was hoisted into a synthetic default - rename here to match
                        verbatimTargetName = "default" /* InternalSymbolName.Default */;
                    }
                    var targetName = getInternalSymbolName(target, verbatimTargetName);
                    includePrivateSymbol(target); // the target may be within the same scope - attempt to serialize it first
                    switch (node.kind) {
                        case 205 /* SyntaxKind.BindingElement */:
                            if (((_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.kind) === 257 /* SyntaxKind.VariableDeclaration */) {
                                // const { SomeClass } = require('./lib');
                                var specifier_1 = getSpecifierForModuleSymbol(target.parent || target, context); // './lib'
                                var propertyName = node.propertyName;
                                addResult(ts.factory.createImportDeclaration(
                                /*modifiers*/ undefined, ts.factory.createImportClause(/*isTypeOnly*/ false, /*name*/ undefined, ts.factory.createNamedImports([ts.factory.createImportSpecifier(
                                    /*isTypeOnly*/ false, propertyName && ts.isIdentifier(propertyName) ? ts.factory.createIdentifier(ts.idText(propertyName)) : undefined, ts.factory.createIdentifier(localName))])), ts.factory.createStringLiteral(specifier_1), 
                                /*importClause*/ undefined), 0 /* ModifierFlags.None */);
                                break;
                            }
                            // We don't know how to serialize this (nested?) binding element
                            ts.Debug.failBadSyntaxKind(((_c = node.parent) === null || _c === void 0 ? void 0 : _c.parent) || node, "Unhandled binding element grandparent kind in declaration serialization");
                            break;
                        case 300 /* SyntaxKind.ShorthandPropertyAssignment */:
                            if (((_e = (_d = node.parent) === null || _d === void 0 ? void 0 : _d.parent) === null || _e === void 0 ? void 0 : _e.kind) === 223 /* SyntaxKind.BinaryExpression */) {
                                // module.exports = { SomeClass }
                                serializeExportSpecifier(ts.unescapeLeadingUnderscores(symbol.escapedName), targetName);
                            }
                            break;
                        case 257 /* SyntaxKind.VariableDeclaration */:
                            // commonjs require: const x = require('y')
                            if (ts.isPropertyAccessExpression(node.initializer)) {
                                // const x = require('y').z
                                var initializer = node.initializer; // require('y').z
                                var uniqueName = ts.factory.createUniqueName(localName); // _x
                                var specifier_2 = getSpecifierForModuleSymbol(target.parent || target, context); // 'y'
                                // import _x = require('y');
                                addResult(ts.factory.createImportEqualsDeclaration(
                                /*modifiers*/ undefined, 
                                /*isTypeOnly*/ false, uniqueName, ts.factory.createExternalModuleReference(ts.factory.createStringLiteral(specifier_2))), 0 /* ModifierFlags.None */);
                                // import x = _x.z
                                addResult(ts.factory.createImportEqualsDeclaration(
                                /*modifiers*/ undefined, 
                                /*isTypeOnly*/ false, ts.factory.createIdentifier(localName), ts.factory.createQualifiedName(uniqueName, initializer.name)), modifierFlags);
                                break;
                            }
                        // else fall through and treat commonjs require just like import=
                        case 268 /* SyntaxKind.ImportEqualsDeclaration */:
                            // This _specifically_ only exists to handle json declarations - where we make aliases, but since
                            // we emit no declarations for the json document, must not refer to it in the declarations
                            if (target.escapedName === "export=" /* InternalSymbolName.ExportEquals */ && ts.some(target.declarations, ts.isJsonSourceFile)) {
                                serializeMaybeAliasAssignment(symbol);
                                break;
                            }
                            // Could be a local `import localName = ns.member` or
                            // an external `import localName = require("whatever")`
                            var isLocalImport = !(target.flags & 512 /* SymbolFlags.ValueModule */) && !ts.isVariableDeclaration(node);
                            addResult(ts.factory.createImportEqualsDeclaration(
                            /*modifiers*/ undefined, 
                            /*isTypeOnly*/ false, ts.factory.createIdentifier(localName), isLocalImport
                                ? symbolToName(target, context, 67108863 /* SymbolFlags.All */, /*expectsIdentifier*/ false)
                                : ts.factory.createExternalModuleReference(ts.factory.createStringLiteral(getSpecifierForModuleSymbol(target, context)))), isLocalImport ? modifierFlags : 0 /* ModifierFlags.None */);
                            break;
                        case 267 /* SyntaxKind.NamespaceExportDeclaration */:
                            // export as namespace foo
                            // TODO: Not part of a file's local or export symbol tables
                            // Is bound into file.symbol.globalExports instead, which we don't currently traverse
                            addResult(ts.factory.createNamespaceExportDeclaration(ts.idText(node.name)), 0 /* ModifierFlags.None */);
                            break;
                        case 270 /* SyntaxKind.ImportClause */:
                            addResult(ts.factory.createImportDeclaration(
                            /*modifiers*/ undefined, ts.factory.createImportClause(/*isTypeOnly*/ false, ts.factory.createIdentifier(localName), /*namedBindings*/ undefined), 
                            // We use `target.parent || target` below as `target.parent` is unset when the target is a module which has been export assigned
                            // And then made into a default by the `esModuleInterop` or `allowSyntheticDefaultImports` flag
                            // In such cases, the `target` refers to the module itself already
                            ts.factory.createStringLiteral(getSpecifierForModuleSymbol(target.parent || target, context)), 
                            /*assertClause*/ undefined), 0 /* ModifierFlags.None */);
                            break;
                        case 271 /* SyntaxKind.NamespaceImport */:
                            addResult(ts.factory.createImportDeclaration(
                            /*modifiers*/ undefined, ts.factory.createImportClause(/*isTypeOnly*/ false, /*importClause*/ undefined, ts.factory.createNamespaceImport(ts.factory.createIdentifier(localName))), ts.factory.createStringLiteral(getSpecifierForModuleSymbol(target, context)), 
                            /*assertClause*/ undefined), 0 /* ModifierFlags.None */);
                            break;
                        case 277 /* SyntaxKind.NamespaceExport */:
                            addResult(ts.factory.createExportDeclaration(
                            /*modifiers*/ undefined, 
                            /*isTypeOnly*/ false, ts.factory.createNamespaceExport(ts.factory.createIdentifier(localName)), ts.factory.createStringLiteral(getSpecifierForModuleSymbol(target, context))), 0 /* ModifierFlags.None */);
                            break;
                        case 273 /* SyntaxKind.ImportSpecifier */:
                            addResult(ts.factory.createImportDeclaration(
                            /*modifiers*/ undefined, ts.factory.createImportClause(
                            /*isTypeOnly*/ false, 
                            /*importClause*/ undefined, ts.factory.createNamedImports([
                                ts.factory.createImportSpecifier(
                                /*isTypeOnly*/ false, localName !== verbatimTargetName ? ts.factory.createIdentifier(verbatimTargetName) : undefined, ts.factory.createIdentifier(localName))
                            ])), ts.factory.createStringLiteral(getSpecifierForModuleSymbol(target.parent || target, context)), 
                            /*assertClause*/ undefined), 0 /* ModifierFlags.None */);
                            break;
                        case 278 /* SyntaxKind.ExportSpecifier */:
                            // does not use localName because the symbol name in this case refers to the name in the exports table,
                            // which we must exactly preserve
                            var specifier = node.parent.parent.moduleSpecifier;
                            // targetName is only used when the target is local, as otherwise the target is an alias that points at
                            // another file
                            serializeExportSpecifier(ts.unescapeLeadingUnderscores(symbol.escapedName), specifier ? verbatimTargetName : targetName, specifier && ts.isStringLiteralLike(specifier) ? ts.factory.createStringLiteral(specifier.text) : undefined);
                            break;
                        case 274 /* SyntaxKind.ExportAssignment */:
                            serializeMaybeAliasAssignment(symbol);
                            break;
                        case 223 /* SyntaxKind.BinaryExpression */:
                        case 208 /* SyntaxKind.PropertyAccessExpression */:
                        case 209 /* SyntaxKind.ElementAccessExpression */:
                            // Could be best encoded as though an export specifier or as though an export assignment
                            // If name is default or export=, do an export assignment
                            // Otherwise do an export specifier
                            if (symbol.escapedName === "default" /* InternalSymbolName.Default */ || symbol.escapedName === "export=" /* InternalSymbolName.ExportEquals */) {
                                serializeMaybeAliasAssignment(symbol);
                            }
                            else {
                                serializeExportSpecifier(localName, targetName);
                            }
                            break;
                        default:
                            return ts.Debug.failBadSyntaxKind(node, "Unhandled alias declaration kind in symbol serializer!");
                    }
                }
                function serializeExportSpecifier(localName, targetName, specifier) {
                    addResult(ts.factory.createExportDeclaration(
                    /*modifiers*/ undefined, 
                    /*isTypeOnly*/ false, ts.factory.createNamedExports([ts.factory.createExportSpecifier(/*isTypeOnly*/ false, localName !== targetName ? targetName : undefined, localName)]), specifier), 0 /* ModifierFlags.None */);
                }
                /**
                 * Returns `true` if an export assignment or declaration was produced for the symbol
                 */
                function serializeMaybeAliasAssignment(symbol) {
                    if (symbol.flags & 4194304 /* SymbolFlags.Prototype */) {
                        return false;
                    }
                    var name = ts.unescapeLeadingUnderscores(symbol.escapedName);
                    var isExportEquals = name === "export=" /* InternalSymbolName.ExportEquals */;
                    var isDefault = name === "default" /* InternalSymbolName.Default */;
                    var isExportAssignmentCompatibleSymbolName = isExportEquals || isDefault;
                    // synthesize export = ref
                    // ref should refer to either be a locally scoped symbol which we need to emit, or
                    // a reference to another namespace/module which we may need to emit an `import` statement for
                    var aliasDecl = symbol.declarations && getDeclarationOfAliasSymbol(symbol);
                    // serialize what the alias points to, preserve the declaration's initializer
                    var target = aliasDecl && getTargetOfAliasDeclaration(aliasDecl, /*dontRecursivelyResolve*/ true);
                    // If the target resolves and resolves to a thing defined in this file, emit as an alias, otherwise emit as a const
                    if (target && ts.length(target.declarations) && ts.some(target.declarations, function (d) { return ts.getSourceFileOfNode(d) === ts.getSourceFileOfNode(enclosingDeclaration); })) {
                        // In case `target` refers to a namespace member, look at the declaration and serialize the leftmost symbol in it
                        // eg, `namespace A { export class B {} }; exports = A.B;`
                        // Technically, this is all that's required in the case where the assignment is an entity name expression
                        var expr = aliasDecl && ((ts.isExportAssignment(aliasDecl) || ts.isBinaryExpression(aliasDecl)) ? ts.getExportAssignmentExpression(aliasDecl) : ts.getPropertyAssignmentAliasLikeExpression(aliasDecl));
                        var first_1 = expr && ts.isEntityNameExpression(expr) ? getFirstNonModuleExportsIdentifier(expr) : undefined;
                        var referenced = first_1 && resolveEntityName(first_1, 67108863 /* SymbolFlags.All */, /*ignoreErrors*/ true, /*dontResolveAlias*/ true, enclosingDeclaration);
                        if (referenced || target) {
                            includePrivateSymbol(referenced || target);
                        }
                        // We disable the context's symbol tracker for the duration of this name serialization
                        // as, by virtue of being here, the name is required to print something, and we don't want to
                        // issue a visibility error on it. Only anonymous classes that an alias points at _would_ issue
                        // a visibility error here (as they're not visible within any scope), but we want to hoist them
                        // into the containing scope anyway, so we want to skip the visibility checks.
                        var oldTrack = context.tracker.trackSymbol;
                        context.tracker.trackSymbol = function () { return false; };
                        if (isExportAssignmentCompatibleSymbolName) {
                            results.push(ts.factory.createExportAssignment(
                            /*modifiers*/ undefined, isExportEquals, symbolToExpression(target, context, 67108863 /* SymbolFlags.All */)));
                        }
                        else {
                            if (first_1 === expr && first_1) {
                                // serialize as `export {target as name}`
                                serializeExportSpecifier(name, ts.idText(first_1));
                            }
                            else if (expr && ts.isClassExpression(expr)) {
                                serializeExportSpecifier(name, getInternalSymbolName(target, ts.symbolName(target)));
                            }
                            else {
                                // serialize as `import _Ref = t.arg.et; export { _Ref as name }`
                                var varName = getUnusedName(name, symbol);
                                addResult(ts.factory.createImportEqualsDeclaration(
                                /*modifiers*/ undefined, 
                                /*isTypeOnly*/ false, ts.factory.createIdentifier(varName), symbolToName(target, context, 67108863 /* SymbolFlags.All */, /*expectsIdentifier*/ false)), 0 /* ModifierFlags.None */);
                                serializeExportSpecifier(name, varName);
                            }
                        }
                        context.tracker.trackSymbol = oldTrack;
                        return true;
                    }
                    else {
                        // serialize as an anonymous property declaration
                        var varName = getUnusedName(name, symbol);
                        // We have to use `getWidenedType` here since the object within a json file is unwidened within the file
                        // (Unwidened types can only exist in expression contexts and should never be serialized)
                        var typeToSerialize = getWidenedType(getTypeOfSymbol(getMergedSymbol(symbol)));
                        if (isTypeRepresentableAsFunctionNamespaceMerge(typeToSerialize, symbol)) {
                            // If there are no index signatures and `typeToSerialize` is an object type, emit as a namespace instead of a const
                            serializeAsFunctionNamespaceMerge(typeToSerialize, symbol, varName, isExportAssignmentCompatibleSymbolName ? 0 /* ModifierFlags.None */ : 1 /* ModifierFlags.Export */);
                        }
                        else {
                            var statement = ts.factory.createVariableStatement(/*modifiers*/ undefined, ts.factory.createVariableDeclarationList([
                                ts.factory.createVariableDeclaration(varName, /*exclamationToken*/ undefined, serializeTypeForDeclaration(context, typeToSerialize, symbol, enclosingDeclaration, includePrivateSymbol, bundled))
                            ], 2 /* NodeFlags.Const */));
                            // Inlined JSON types exported with [module.]exports= will already emit an export=, so should use `declare`.
                            // Otherwise, the type itself should be exported.
                            addResult(statement, target && target.flags & 4 /* SymbolFlags.Property */ && target.escapedName === "export=" /* InternalSymbolName.ExportEquals */ ? 2 /* ModifierFlags.Ambient */
                                : name === varName ? 1 /* ModifierFlags.Export */
                                    : 0 /* ModifierFlags.None */);
                        }
                        if (isExportAssignmentCompatibleSymbolName) {
                            results.push(ts.factory.createExportAssignment(
                            /*modifiers*/ undefined, isExportEquals, ts.factory.createIdentifier(varName)));
                            return true;
                        }
                        else if (name !== varName) {
                            serializeExportSpecifier(name, varName);
                            return true;
                        }
                        return false;
                    }
                }
                function isTypeRepresentableAsFunctionNamespaceMerge(typeToSerialize, hostSymbol) {
                    // Only object types which are not constructable, or indexable, whose members all come from the
                    // context source file, and whose property names are all valid identifiers and not late-bound, _and_
                    // whose input is not type annotated (if the input symbol has an annotation we can reuse, we should prefer it)
                    var ctxSrc = ts.getSourceFileOfNode(context.enclosingDeclaration);
                    return ts.getObjectFlags(typeToSerialize) & (16 /* ObjectFlags.Anonymous */ | 32 /* ObjectFlags.Mapped */) &&
                        !ts.length(getIndexInfosOfType(typeToSerialize)) &&
                        !isClassInstanceSide(typeToSerialize) && // While a class instance is potentially representable as a NS, prefer printing a reference to the instance type and serializing the class
                        !!(ts.length(ts.filter(getPropertiesOfType(typeToSerialize), isNamespaceMember)) || ts.length(getSignaturesOfType(typeToSerialize, 0 /* SignatureKind.Call */))) &&
                        !ts.length(getSignaturesOfType(typeToSerialize, 1 /* SignatureKind.Construct */)) && // TODO: could probably serialize as function + ns + class, now that that's OK
                        !getDeclarationWithTypeAnnotation(hostSymbol, enclosingDeclaration) &&
                        !(typeToSerialize.symbol && ts.some(typeToSerialize.symbol.declarations, function (d) { return ts.getSourceFileOfNode(d) !== ctxSrc; })) &&
                        !ts.some(getPropertiesOfType(typeToSerialize), function (p) { return isLateBoundName(p.escapedName); }) &&
                        !ts.some(getPropertiesOfType(typeToSerialize), function (p) { return ts.some(p.declarations, function (d) { return ts.getSourceFileOfNode(d) !== ctxSrc; }); }) &&
                        ts.every(getPropertiesOfType(typeToSerialize), function (p) { return ts.isIdentifierText(ts.symbolName(p), languageVersion); });
                }
                function makeSerializePropertySymbol(createProperty, methodKind, useAccessors) {
                    return function serializePropertySymbol(p, isStatic, baseType) {
                        var _a, _b, _c, _d, _e;
                        var modifierFlags = ts.getDeclarationModifierFlagsFromSymbol(p);
                        var isPrivate = !!(modifierFlags & 8 /* ModifierFlags.Private */);
                        if (isStatic && (p.flags & (788968 /* SymbolFlags.Type */ | 1920 /* SymbolFlags.Namespace */ | 2097152 /* SymbolFlags.Alias */))) {
                            // Only value-only-meaning symbols can be correctly encoded as class statics, type/namespace/alias meaning symbols
                            // need to be merged namespace members
                            return [];
                        }
                        if (p.flags & 4194304 /* SymbolFlags.Prototype */ ||
                            (baseType && getPropertyOfType(baseType, p.escapedName)
                                && isReadonlySymbol(getPropertyOfType(baseType, p.escapedName)) === isReadonlySymbol(p)
                                && (p.flags & 16777216 /* SymbolFlags.Optional */) === (getPropertyOfType(baseType, p.escapedName).flags & 16777216 /* SymbolFlags.Optional */)
                                && isTypeIdenticalTo(getTypeOfSymbol(p), getTypeOfPropertyOfType(baseType, p.escapedName)))) {
                            return [];
                        }
                        var flag = (modifierFlags & ~512 /* ModifierFlags.Async */) | (isStatic ? 32 /* ModifierFlags.Static */ : 0);
                        var name = getPropertyNameNodeForSymbol(p, context);
                        var firstPropertyLikeDecl = (_a = p.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.or(ts.isPropertyDeclaration, ts.isAccessor, ts.isVariableDeclaration, ts.isPropertySignature, ts.isBinaryExpression, ts.isPropertyAccessExpression));
                        if (p.flags & 98304 /* SymbolFlags.Accessor */ && useAccessors) {
                            var result = [];
                            if (p.flags & 65536 /* SymbolFlags.SetAccessor */) {
                                result.push(ts.setTextRange(ts.factory.createSetAccessorDeclaration(ts.factory.createModifiersFromModifierFlags(flag), name, [ts.factory.createParameterDeclaration(
                                    /*modifiers*/ undefined, 
                                    /*dotDotDotToken*/ undefined, "arg", 
                                    /*questionToken*/ undefined, isPrivate ? undefined : serializeTypeForDeclaration(context, getTypeOfSymbol(p), p, enclosingDeclaration, includePrivateSymbol, bundled))], 
                                /*body*/ undefined), ((_b = p.declarations) === null || _b === void 0 ? void 0 : _b.find(ts.isSetAccessor)) || firstPropertyLikeDecl));
                            }
                            if (p.flags & 32768 /* SymbolFlags.GetAccessor */) {
                                var isPrivate_1 = modifierFlags & 8 /* ModifierFlags.Private */;
                                result.push(ts.setTextRange(ts.factory.createGetAccessorDeclaration(ts.factory.createModifiersFromModifierFlags(flag), name, [], isPrivate_1 ? undefined : serializeTypeForDeclaration(context, getTypeOfSymbol(p), p, enclosingDeclaration, includePrivateSymbol, bundled), 
                                /*body*/ undefined), ((_c = p.declarations) === null || _c === void 0 ? void 0 : _c.find(ts.isGetAccessor)) || firstPropertyLikeDecl));
                            }
                            return result;
                        }
                        // This is an else/if as accessors and properties can't merge in TS, but might in JS
                        // If this happens, we assume the accessor takes priority, as it imposes more constraints
                        else if (p.flags & (4 /* SymbolFlags.Property */ | 3 /* SymbolFlags.Variable */ | 98304 /* SymbolFlags.Accessor */)) {
                            return ts.setTextRange(createProperty(ts.factory.createModifiersFromModifierFlags((isReadonlySymbol(p) ? 64 /* ModifierFlags.Readonly */ : 0) | flag), name, p.flags & 16777216 /* SymbolFlags.Optional */ ? ts.factory.createToken(57 /* SyntaxKind.QuestionToken */) : undefined, isPrivate ? undefined : serializeTypeForDeclaration(context, getWriteTypeOfSymbol(p), p, enclosingDeclaration, includePrivateSymbol, bundled), 
                            // TODO: https://github.com/microsoft/TypeScript/pull/32372#discussion_r328386357
                            // interface members can't have initializers, however class members _can_
                            /*initializer*/ undefined), ((_d = p.declarations) === null || _d === void 0 ? void 0 : _d.find(ts.or(ts.isPropertyDeclaration, ts.isVariableDeclaration))) || firstPropertyLikeDecl);
                        }
                        if (p.flags & (8192 /* SymbolFlags.Method */ | 16 /* SymbolFlags.Function */)) {
                            var type = getTypeOfSymbol(p);
                            var signatures = getSignaturesOfType(type, 0 /* SignatureKind.Call */);
                            if (flag & 8 /* ModifierFlags.Private */) {
                                return ts.setTextRange(createProperty(ts.factory.createModifiersFromModifierFlags((isReadonlySymbol(p) ? 64 /* ModifierFlags.Readonly */ : 0) | flag), name, p.flags & 16777216 /* SymbolFlags.Optional */ ? ts.factory.createToken(57 /* SyntaxKind.QuestionToken */) : undefined, 
                                /*type*/ undefined, 
                                /*initializer*/ undefined), ((_e = p.declarations) === null || _e === void 0 ? void 0 : _e.find(ts.isFunctionLikeDeclaration)) || signatures[0] && signatures[0].declaration || p.declarations && p.declarations[0]);
                            }
                            var results_1 = [];
                            for (var _i = 0, signatures_3 = signatures; _i < signatures_3.length; _i++) {
                                var sig = signatures_3[_i];
                                // Each overload becomes a separate method declaration, in order
                                var decl = signatureToSignatureDeclarationHelper(sig, methodKind, context, {
                                    name: name,
                                    questionToken: p.flags & 16777216 /* SymbolFlags.Optional */ ? ts.factory.createToken(57 /* SyntaxKind.QuestionToken */) : undefined,
                                    modifiers: flag ? ts.factory.createModifiersFromModifierFlags(flag) : undefined
                                });
                                var location = sig.declaration && ts.isPrototypePropertyAssignment(sig.declaration.parent) ? sig.declaration.parent : sig.declaration;
                                results_1.push(ts.setTextRange(decl, location));
                            }
                            return results_1;
                        }
                        // The `Constructor`'s symbol isn't in the class's properties lists, obviously, since it's a signature on the static
                        return ts.Debug.fail("Unhandled class member kind! ".concat(p.__debugFlags || p.flags));
                    };
                }
                function serializePropertySymbolForInterface(p, baseType) {
                    return serializePropertySymbolForInterfaceWorker(p, /*isStatic*/ false, baseType);
                }
                function serializeSignatures(kind, input, baseType, outputKind) {
                    var signatures = getSignaturesOfType(input, kind);
                    if (kind === 1 /* SignatureKind.Construct */) {
                        if (!baseType && ts.every(signatures, function (s) { return ts.length(s.parameters) === 0; })) {
                            return []; // No base type, every constructor is empty - elide the extraneous `constructor()`
                        }
                        if (baseType) {
                            // If there is a base type, if every signature in the class is identical to a signature in the baseType, elide all the declarations
                            var baseSigs = getSignaturesOfType(baseType, 1 /* SignatureKind.Construct */);
                            if (!ts.length(baseSigs) && ts.every(signatures, function (s) { return ts.length(s.parameters) === 0; })) {
                                return []; // Base had no explicit signatures, if all our signatures are also implicit, return an empty list
                            }
                            if (baseSigs.length === signatures.length) {
                                var failed = false;
                                for (var i = 0; i < baseSigs.length; i++) {
                                    if (!compareSignaturesIdentical(signatures[i], baseSigs[i], /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ true, compareTypesIdentical)) {
                                        failed = true;
                                        break;
                                    }
                                }
                                if (!failed) {
                                    return []; // Every signature was identical - elide constructor list as it is inherited
                                }
                            }
                        }
                        var privateProtected = 0;
                        for (var _i = 0, signatures_4 = signatures; _i < signatures_4.length; _i++) {
                            var s = signatures_4[_i];
                            if (s.declaration) {
                                privateProtected |= ts.getSelectedEffectiveModifierFlags(s.declaration, 8 /* ModifierFlags.Private */ | 16 /* ModifierFlags.Protected */);
                            }
                        }
                        if (privateProtected) {
                            return [ts.setTextRange(ts.factory.createConstructorDeclaration(ts.factory.createModifiersFromModifierFlags(privateProtected), 
                                /*parameters*/ [], 
                                /*body*/ undefined), signatures[0].declaration)];
                        }
                    }
                    var results = [];
                    for (var _a = 0, signatures_5 = signatures; _a < signatures_5.length; _a++) {
                        var sig = signatures_5[_a];
                        // Each overload becomes a separate constructor declaration, in order
                        var decl = signatureToSignatureDeclarationHelper(sig, outputKind, context);
                        results.push(ts.setTextRange(decl, sig.declaration));
                    }
                    return results;
                }
                function serializeIndexSignatures(input, baseType) {
                    var results = [];
                    for (var _i = 0, _a = getIndexInfosOfType(input); _i < _a.length; _i++) {
                        var info = _a[_i];
                        if (baseType) {
                            var baseInfo = getIndexInfoOfType(baseType, info.keyType);
                            if (baseInfo) {
                                if (isTypeIdenticalTo(info.type, baseInfo.type)) {
                                    continue; // elide identical index signatures
                                }
                            }
                        }
                        results.push(indexInfoToIndexSignatureDeclarationHelper(info, context, /*typeNode*/ undefined));
                    }
                    return results;
                }
                function serializeBaseType(t, staticType, rootName) {
                    var ref = trySerializeAsTypeReference(t, 111551 /* SymbolFlags.Value */);
                    if (ref) {
                        return ref;
                    }
                    var tempName = getUnusedName("".concat(rootName, "_base"));
                    var statement = ts.factory.createVariableStatement(/*modifiers*/ undefined, ts.factory.createVariableDeclarationList([
                        ts.factory.createVariableDeclaration(tempName, /*exclamationToken*/ undefined, typeToTypeNodeHelper(staticType, context))
                    ], 2 /* NodeFlags.Const */));
                    addResult(statement, 0 /* ModifierFlags.None */);
                    return ts.factory.createExpressionWithTypeArguments(ts.factory.createIdentifier(tempName), /*typeArgs*/ undefined);
                }
                function trySerializeAsTypeReference(t, flags) {
                    var typeArgs;
                    var reference;
                    // We don't use `isValueSymbolAccessible` below. since that considers alternative containers (like modules)
                    // which we can't write out in a syntactically valid way as an expression
                    if (t.target && isSymbolAccessibleByFlags(t.target.symbol, enclosingDeclaration, flags)) {
                        typeArgs = ts.map(getTypeArguments(t), function (t) { return typeToTypeNodeHelper(t, context); });
                        reference = symbolToExpression(t.target.symbol, context, 788968 /* SymbolFlags.Type */);
                    }
                    else if (t.symbol && isSymbolAccessibleByFlags(t.symbol, enclosingDeclaration, flags)) {
                        reference = symbolToExpression(t.symbol, context, 788968 /* SymbolFlags.Type */);
                    }
                    if (reference) {
                        return ts.factory.createExpressionWithTypeArguments(reference, typeArgs);
                    }
                }
                function serializeImplementedType(t) {
                    var ref = trySerializeAsTypeReference(t, 788968 /* SymbolFlags.Type */);
                    if (ref) {
                        return ref;
                    }
                    if (t.symbol) {
                        return ts.factory.createExpressionWithTypeArguments(symbolToExpression(t.symbol, context, 788968 /* SymbolFlags.Type */), /*typeArgs*/ undefined);
                    }
                }
                function getUnusedName(input, symbol) {
                    var _a, _b;
                    var id = symbol ? getSymbolId(symbol) : undefined;
                    if (id) {
                        if (context.remappedSymbolNames.has(id)) {
                            return context.remappedSymbolNames.get(id);
                        }
                    }
                    if (symbol) {
                        input = getNameCandidateWorker(symbol, input);
                    }
                    var i = 0;
                    var original = input;
                    while ((_a = context.usedSymbolNames) === null || _a === void 0 ? void 0 : _a.has(input)) {
                        i++;
                        input = "".concat(original, "_").concat(i);
                    }
                    (_b = context.usedSymbolNames) === null || _b === void 0 ? void 0 : _b.add(input);
                    if (id) {
                        context.remappedSymbolNames.set(id, input);
                    }
                    return input;
                }
                function getNameCandidateWorker(symbol, localName) {
                    if (localName === "default" /* InternalSymbolName.Default */ || localName === "__class" /* InternalSymbolName.Class */ || localName === "__function" /* InternalSymbolName.Function */) {
                        var flags = context.flags;
                        context.flags |= 16777216 /* NodeBuilderFlags.InInitialEntityName */;
                        var nameCandidate = getNameOfSymbolAsWritten(symbol, context);
                        context.flags = flags;
                        localName = nameCandidate.length > 0 && ts.isSingleOrDoubleQuote(nameCandidate.charCodeAt(0)) ? ts.stripQuotes(nameCandidate) : nameCandidate;
                    }
                    if (localName === "default" /* InternalSymbolName.Default */) {
                        localName = "_default";
                    }
                    else if (localName === "export=" /* InternalSymbolName.ExportEquals */) {
                        localName = "_exports";
                    }
                    localName = ts.isIdentifierText(localName, languageVersion) && !ts.isStringANonContextualKeyword(localName) ? localName : "_" + localName.replace(/[^a-zA-Z0-9]/g, "_");
                    return localName;
                }
                function getInternalSymbolName(symbol, localName) {
                    var id = getSymbolId(symbol);
                    if (context.remappedSymbolNames.has(id)) {
                        return context.remappedSymbolNames.get(id);
                    }
                    localName = getNameCandidateWorker(symbol, localName);
                    // The result of this is going to be used as the symbol's name - lock it in, so `getUnusedName` will also pick it up
                    context.remappedSymbolNames.set(id, localName);
                    return localName;
                }
            }
        }
        function typePredicateToString(typePredicate, enclosingDeclaration, flags, writer) {
            if (flags === void 0) { flags = 16384 /* TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */; }
            return writer ? typePredicateToStringWorker(writer).getText() : ts.usingSingleLineStringWriter(typePredicateToStringWorker);
            function typePredicateToStringWorker(writer) {
                var predicate = ts.factory.createTypePredicateNode(typePredicate.kind === 2 /* TypePredicateKind.AssertsThis */ || typePredicate.kind === 3 /* TypePredicateKind.AssertsIdentifier */ ? ts.factory.createToken(129 /* SyntaxKind.AssertsKeyword */) : undefined, typePredicate.kind === 1 /* TypePredicateKind.Identifier */ || typePredicate.kind === 3 /* TypePredicateKind.AssertsIdentifier */ ? ts.factory.createIdentifier(typePredicate.parameterName) : ts.factory.createThisTypeNode(), typePredicate.type && nodeBuilder.typeToTypeNode(typePredicate.type, enclosingDeclaration, toNodeBuilderFlags(flags) | 70221824 /* NodeBuilderFlags.IgnoreErrors */ | 512 /* NodeBuilderFlags.WriteTypeParametersInQualifiedName */) // TODO: GH#18217
                );
                var printer = ts.createPrinter({ removeComments: true });
                var sourceFile = enclosingDeclaration && ts.getSourceFileOfNode(enclosingDeclaration);
                printer.writeNode(4 /* EmitHint.Unspecified */, predicate, /*sourceFile*/ sourceFile, writer);
                return writer;
            }
        }
        function formatUnionTypes(types) {
            var result = [];
            var flags = 0;
            for (var i = 0; i < types.length; i++) {
                var t = types[i];
                flags |= t.flags;
                if (!(t.flags & 98304 /* TypeFlags.Nullable */)) {
                    if (t.flags & (512 /* TypeFlags.BooleanLiteral */ | 1024 /* TypeFlags.EnumLiteral */)) {
                        var baseType = t.flags & 512 /* TypeFlags.BooleanLiteral */ ? booleanType : getBaseTypeOfEnumLiteralType(t);
                        if (baseType.flags & 1048576 /* TypeFlags.Union */) {
                            var count = baseType.types.length;
                            if (i + count <= types.length && getRegularTypeOfLiteralType(types[i + count - 1]) === getRegularTypeOfLiteralType(baseType.types[count - 1])) {
                                result.push(baseType);
                                i += count - 1;
                                continue;
                            }
                        }
                    }
                    result.push(t);
                }
            }
            if (flags & 65536 /* TypeFlags.Null */)
                result.push(nullType);
            if (flags & 32768 /* TypeFlags.Undefined */)
                result.push(undefinedType);
            return result || types;
        }
        function visibilityToString(flags) {
            if (flags === 8 /* ModifierFlags.Private */) {
                return "private";
            }
            if (flags === 16 /* ModifierFlags.Protected */) {
                return "protected";
            }
            return "public";
        }
        function getTypeAliasForTypeLiteral(type) {
            if (type.symbol && type.symbol.flags & 2048 /* SymbolFlags.TypeLiteral */ && type.symbol.declarations) {
                var node = ts.walkUpParenthesizedTypes(type.symbol.declarations[0].parent);
                if (node.kind === 262 /* SyntaxKind.TypeAliasDeclaration */) {
                    return getSymbolOfNode(node);
                }
            }
            return undefined;
        }
        function isTopLevelInExternalModuleAugmentation(node) {
            return node && node.parent &&
                node.parent.kind === 265 /* SyntaxKind.ModuleBlock */ &&
                ts.isExternalModuleAugmentation(node.parent.parent);
        }
        function isDefaultBindingContext(location) {
            return location.kind === 308 /* SyntaxKind.SourceFile */ || ts.isAmbientModule(location);
        }
        function getNameOfSymbolFromNameType(symbol, context) {
            var nameType = getSymbolLinks(symbol).nameType;
            if (nameType) {
                if (nameType.flags & 384 /* TypeFlags.StringOrNumberLiteral */) {
                    var name = "" + nameType.value;
                    if (!ts.isIdentifierText(name, ts.getEmitScriptTarget(compilerOptions)) && !ts.isNumericLiteralName(name)) {
                        return "\"".concat(ts.escapeString(name, 34 /* CharacterCodes.doubleQuote */), "\"");
                    }
                    if (ts.isNumericLiteralName(name) && ts.startsWith(name, "-")) {
                        return "[".concat(name, "]");
                    }
                    return name;
                }
                if (nameType.flags & 8192 /* TypeFlags.UniqueESSymbol */) {
                    return "[".concat(getNameOfSymbolAsWritten(nameType.symbol, context), "]");
                }
            }
        }
        /**
         * Gets a human-readable name for a symbol.
         * Should *not* be used for the right-hand side of a `.` -- use `symbolName(symbol)` for that instead.
         *
         * Unlike `symbolName(symbol)`, this will include quotes if the name is from a string literal.
         * It will also use a representation of a number as written instead of a decimal form, e.g. `0o11` instead of `9`.
         */
        function getNameOfSymbolAsWritten(symbol, context) {
            if (context && symbol.escapedName === "default" /* InternalSymbolName.Default */ && !(context.flags & 16384 /* NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope */) &&
                // If it's not the first part of an entity name, it must print as `default`
                (!(context.flags & 16777216 /* NodeBuilderFlags.InInitialEntityName */) ||
                    // if the symbol is synthesized, it will only be referenced externally it must print as `default`
                    !symbol.declarations ||
                    // if not in the same binding context (source file, module declaration), it must print as `default`
                    (context.enclosingDeclaration && ts.findAncestor(symbol.declarations[0], isDefaultBindingContext) !== ts.findAncestor(context.enclosingDeclaration, isDefaultBindingContext)))) {
                return "default";
            }
            if (symbol.declarations && symbol.declarations.length) {
                var declaration = ts.firstDefined(symbol.declarations, function (d) { return ts.getNameOfDeclaration(d) ? d : undefined; }); // Try using a declaration with a name, first
                var name_4 = declaration && ts.getNameOfDeclaration(declaration);
                if (declaration && name_4) {
                    if (ts.isCallExpression(declaration) && ts.isBindableObjectDefinePropertyCall(declaration)) {
                        return ts.symbolName(symbol);
                    }
                    if (ts.isComputedPropertyName(name_4) && !(ts.getCheckFlags(symbol) & 4096 /* CheckFlags.Late */)) {
                        var nameType = getSymbolLinks(symbol).nameType;
                        if (nameType && nameType.flags & 384 /* TypeFlags.StringOrNumberLiteral */) {
                            // Computed property name isn't late bound, but has a well-known name type - use name type to generate a symbol name
                            var result = getNameOfSymbolFromNameType(symbol, context);
                            if (result !== undefined) {
                                return result;
                            }
                        }
                    }
                    return ts.declarationNameToString(name_4);
                }
                if (!declaration) {
                    declaration = symbol.declarations[0]; // Declaration may be nameless, but we'll try anyway
                }
                if (declaration.parent && declaration.parent.kind === 257 /* SyntaxKind.VariableDeclaration */) {
                    return ts.declarationNameToString(declaration.parent.name);
                }
                switch (declaration.kind) {
                    case 228 /* SyntaxKind.ClassExpression */:
                    case 215 /* SyntaxKind.FunctionExpression */:
                    case 216 /* SyntaxKind.ArrowFunction */:
                        if (context && !context.encounteredError && !(context.flags & 131072 /* NodeBuilderFlags.AllowAnonymousIdentifier */)) {
                            context.encounteredError = true;
                        }
                        return declaration.kind === 228 /* SyntaxKind.ClassExpression */ ? "(Anonymous class)" : "(Anonymous function)";
                }
            }
            var name = getNameOfSymbolFromNameType(symbol, context);
            return name !== undefined ? name : ts.symbolName(symbol);
        }
        function isDeclarationVisible(node) {
            if (node) {
                var links = getNodeLinks(node);
                if (links.isVisible === undefined) {
                    links.isVisible = !!determineIfDeclarationIsVisible();
                }
                return links.isVisible;
            }
            return false;
            function determineIfDeclarationIsVisible() {
                switch (node.kind) {
                    case 341 /* SyntaxKind.JSDocCallbackTag */:
                    case 348 /* SyntaxKind.JSDocTypedefTag */:
                    case 342 /* SyntaxKind.JSDocEnumTag */:
                        // Top-level jsdoc type aliases are considered exported
                        // First parent is comment node, second is hosting declaration or token; we only care about those tokens or declarations whose parent is a source file
                        return !!(node.parent && node.parent.parent && node.parent.parent.parent && ts.isSourceFile(node.parent.parent.parent));
                    case 205 /* SyntaxKind.BindingElement */:
                        return isDeclarationVisible(node.parent.parent);
                    case 257 /* SyntaxKind.VariableDeclaration */:
                        if (ts.isBindingPattern(node.name) &&
                            !node.name.elements.length) {
                            // If the binding pattern is empty, this variable declaration is not visible
                            return false;
                        }
                    // falls through
                    case 264 /* SyntaxKind.ModuleDeclaration */:
                    case 260 /* SyntaxKind.ClassDeclaration */:
                    case 261 /* SyntaxKind.InterfaceDeclaration */:
                    case 262 /* SyntaxKind.TypeAliasDeclaration */:
                    case 259 /* SyntaxKind.FunctionDeclaration */:
                    case 263 /* SyntaxKind.EnumDeclaration */:
                    case 268 /* SyntaxKind.ImportEqualsDeclaration */:
                        // external module augmentation is always visible
                        if (ts.isExternalModuleAugmentation(node)) {
                            return true;
                        }
                        var parent = getDeclarationContainer(node);
                        // If the node is not exported or it is not ambient module element (except import declaration)
                        if (!(ts.getCombinedModifierFlags(node) & 1 /* ModifierFlags.Export */) &&
                            !(node.kind !== 268 /* SyntaxKind.ImportEqualsDeclaration */ && parent.kind !== 308 /* SyntaxKind.SourceFile */ && parent.flags & 16777216 /* NodeFlags.Ambient */)) {
                            return isGlobalSourceFile(parent);
                        }
                        // Exported members/ambient module elements (exception import declaration) are visible if parent is visible
                        return isDeclarationVisible(parent);
                    case 169 /* SyntaxKind.PropertyDeclaration */:
                    case 168 /* SyntaxKind.PropertySignature */:
                    case 174 /* SyntaxKind.GetAccessor */:
                    case 175 /* SyntaxKind.SetAccessor */:
                    case 171 /* SyntaxKind.MethodDeclaration */:
                    case 170 /* SyntaxKind.MethodSignature */:
                        if (ts.hasEffectiveModifier(node, 8 /* ModifierFlags.Private */ | 16 /* ModifierFlags.Protected */)) {
                            // Private/protected properties/methods are not visible
                            return false;
                        }
                    // Public properties/methods are visible if its parents are visible, so:
                    // falls through
                    case 173 /* SyntaxKind.Constructor */:
                    case 177 /* SyntaxKind.ConstructSignature */:
                    case 176 /* SyntaxKind.CallSignature */:
                    case 178 /* SyntaxKind.IndexSignature */:
                    case 166 /* SyntaxKind.Parameter */:
                    case 265 /* SyntaxKind.ModuleBlock */:
                    case 181 /* SyntaxKind.FunctionType */:
                    case 182 /* SyntaxKind.ConstructorType */:
                    case 184 /* SyntaxKind.TypeLiteral */:
                    case 180 /* SyntaxKind.TypeReference */:
                    case 185 /* SyntaxKind.ArrayType */:
                    case 186 /* SyntaxKind.TupleType */:
                    case 189 /* SyntaxKind.UnionType */:
                    case 190 /* SyntaxKind.IntersectionType */:
                    case 193 /* SyntaxKind.ParenthesizedType */:
                    case 199 /* SyntaxKind.NamedTupleMember */:
                        return isDeclarationVisible(node.parent);
                    // Default binding, import specifier and namespace import is visible
                    // only on demand so by default it is not visible
                    case 270 /* SyntaxKind.ImportClause */:
                    case 271 /* SyntaxKind.NamespaceImport */:
                    case 273 /* SyntaxKind.ImportSpecifier */:
                        return false;
                    // Type parameters are always visible
                    case 165 /* SyntaxKind.TypeParameter */:
                    // Source file and namespace export are always visible
                    // falls through
                    case 308 /* SyntaxKind.SourceFile */:
                    case 267 /* SyntaxKind.NamespaceExportDeclaration */:
                        return true;
                    // Export assignments do not create name bindings outside the module
                    case 274 /* SyntaxKind.ExportAssignment */:
                        return false;
                    default:
                        return false;
                }
            }
        }
        function collectLinkedAliases(node, setVisibility) {
            var exportSymbol;
            if (node.parent && node.parent.kind === 274 /* SyntaxKind.ExportAssignment */) {
                exportSymbol = resolveName(node, node.escapedText, 111551 /* SymbolFlags.Value */ | 788968 /* SymbolFlags.Type */ | 1920 /* SymbolFlags.Namespace */ | 2097152 /* SymbolFlags.Alias */, /*nameNotFoundMessage*/ undefined, node, /*isUse*/ false);
            }
            else if (node.parent.kind === 278 /* SyntaxKind.ExportSpecifier */) {
                exportSymbol = getTargetOfExportSpecifier(node.parent, 111551 /* SymbolFlags.Value */ | 788968 /* SymbolFlags.Type */ | 1920 /* SymbolFlags.Namespace */ | 2097152 /* SymbolFlags.Alias */);
            }
            var result;
            var visited;
            if (exportSymbol) {
                visited = new ts.Set();
                visited.add(getSymbolId(exportSymbol));
                buildVisibleNodeList(exportSymbol.declarations);
            }
            return result;
            function buildVisibleNodeList(declarations) {
                ts.forEach(declarations, function (declaration) {
                    var resultNode = getAnyImportSyntax(declaration) || declaration;
                    if (setVisibility) {
                        getNodeLinks(declaration).isVisible = true;
                    }
                    else {
                        result = result || [];
                        ts.pushIfUnique(result, resultNode);
                    }
                    if (ts.isInternalModuleImportEqualsDeclaration(declaration)) {
                        // Add the referenced top container visible
                        var internalModuleReference = declaration.moduleReference;
                        var firstIdentifier = ts.getFirstIdentifier(internalModuleReference);
                        var importSymbol = resolveName(declaration, firstIdentifier.escapedText, 111551 /* SymbolFlags.Value */ | 788968 /* SymbolFlags.Type */ | 1920 /* SymbolFlags.Namespace */, undefined, undefined, /*isUse*/ false);
                        if (importSymbol && visited) {
                            if (ts.tryAddToSet(visited, getSymbolId(importSymbol))) {
                                buildVisibleNodeList(importSymbol.declarations);
                            }
                        }
                    }
                });
            }
        }
        /**
         * Push an entry on the type resolution stack. If an entry with the given target and the given property name
         * is already on the stack, and no entries in between already have a type, then a circularity has occurred.
         * In this case, the result values of the existing entry and all entries pushed after it are changed to false,
         * and the value false is returned. Otherwise, the new entry is just pushed onto the stack, and true is returned.
         * In order to see if the same query has already been done before, the target object and the propertyName both
         * must match the one passed in.
         *
         * @param target The symbol, type, or signature whose type is being queried
         * @param propertyName The property name that should be used to query the target for its type
         */
        function pushTypeResolution(target, propertyName) {
            var resolutionCycleStartIndex = findResolutionCycleStartIndex(target, propertyName);
            if (resolutionCycleStartIndex >= 0) {
                // A cycle was found
                var length_3 = resolutionTargets.length;
                for (var i = resolutionCycleStartIndex; i < length_3; i++) {
                    resolutionResults[i] = false;
                }
                return false;
            }
            resolutionTargets.push(target);
            resolutionResults.push(/*items*/ true);
            resolutionPropertyNames.push(propertyName);
            return true;
        }
        function findResolutionCycleStartIndex(target, propertyName) {
            for (var i = resolutionTargets.length - 1; i >= 0; i--) {
                if (hasType(resolutionTargets[i], resolutionPropertyNames[i])) {
                    return -1;
                }
                if (resolutionTargets[i] === target && resolutionPropertyNames[i] === propertyName) {
                    return i;
                }
            }
            return -1;
        }
        function hasType(target, propertyName) {
            switch (propertyName) {
                case 0 /* TypeSystemPropertyName.Type */:
                    return !!getSymbolLinks(target).type;
                case 5 /* TypeSystemPropertyName.EnumTagType */:
                    return !!(getNodeLinks(target).resolvedEnumType);
                case 2 /* TypeSystemPropertyName.DeclaredType */:
                    return !!getSymbolLinks(target).declaredType;
                case 1 /* TypeSystemPropertyName.ResolvedBaseConstructorType */:
                    return !!target.resolvedBaseConstructorType;
                case 3 /* TypeSystemPropertyName.ResolvedReturnType */:
                    return !!target.resolvedReturnType;
                case 4 /* TypeSystemPropertyName.ImmediateBaseConstraint */:
                    return !!target.immediateBaseConstraint;
                case 6 /* TypeSystemPropertyName.ResolvedTypeArguments */:
                    return !!target.resolvedTypeArguments;
                case 7 /* TypeSystemPropertyName.ResolvedBaseTypes */:
                    return !!target.baseTypesResolved;
                case 8 /* TypeSystemPropertyName.WriteType */:
                    return !!getSymbolLinks(target).writeType;
            }
            return ts.Debug.assertNever(propertyName);
        }
        /**
         * Pop an entry from the type resolution stack and return its associated result value. The result value will
         * be true if no circularities were detected, or false if a circularity was found.
         */
        function popTypeResolution() {
            resolutionTargets.pop();
            resolutionPropertyNames.pop();
            return resolutionResults.pop();
        }
        function getDeclarationContainer(node) {
            return ts.findAncestor(ts.getRootDeclaration(node), function (node) {
                switch (node.kind) {
                    case 257 /* SyntaxKind.VariableDeclaration */:
                    case 258 /* SyntaxKind.VariableDeclarationList */:
                    case 273 /* SyntaxKind.ImportSpecifier */:
                    case 272 /* SyntaxKind.NamedImports */:
                    case 271 /* SyntaxKind.NamespaceImport */:
                    case 270 /* SyntaxKind.ImportClause */:
                        return false;
                    default:
                        return true;
                }
            }).parent;
        }
        function getTypeOfPrototypeProperty(prototype) {
            // TypeScript 1.0 spec (April 2014): 8.4
            // Every class automatically contains a static property member named 'prototype',
            // the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.
            // It is an error to explicitly declare a static property member with the name 'prototype'.
            var classType = getDeclaredTypeOfSymbol(getParentOfSymbol(prototype));
            return classType.typeParameters ? createTypeReference(classType, ts.map(classType.typeParameters, function (_) { return anyType; })) : classType;
        }
        // Return the type of the given property in the given type, or undefined if no such property exists
        function getTypeOfPropertyOfType(type, name) {
            var prop = getPropertyOfType(type, name);
            return prop ? getTypeOfSymbol(prop) : undefined;
        }
        function getTypeOfPropertyOrIndexSignature(type, name) {
            var _a;
            return getTypeOfPropertyOfType(type, name) || ((_a = getApplicableIndexInfoForName(type, name)) === null || _a === void 0 ? void 0 : _a.type) || unknownType;
        }
        function isTypeAny(type) {
            return type && (type.flags & 1 /* TypeFlags.Any */) !== 0;
        }
        function isErrorType(type) {
            // The only 'any' types that have alias symbols are those manufactured by getTypeFromTypeAliasReference for
            // a reference to an unresolved symbol. We want those to behave like the errorType.
            return type === errorType || !!(type.flags & 1 /* TypeFlags.Any */ && type.aliasSymbol);
        }
        // Return the type of a binding element parent. We check SymbolLinks first to see if a type has been
        // assigned by contextual typing.
        function getTypeForBindingElementParent(node, checkMode) {
            if (checkMode !== 0 /* CheckMode.Normal */) {
                return getTypeForVariableLikeDeclaration(node, /*includeOptionality*/ false, checkMode);
            }
            var symbol = getSymbolOfNode(node);
            return symbol && getSymbolLinks(symbol).type || getTypeForVariableLikeDeclaration(node, /*includeOptionality*/ false, checkMode);
        }
        function getRestType(source, properties, symbol) {
            source = filterType(source, function (t) { return !(t.flags & 98304 /* TypeFlags.Nullable */); });
            if (source.flags & 131072 /* TypeFlags.Never */) {
                return emptyObjectType;
            }
            if (source.flags & 1048576 /* TypeFlags.Union */) {
                return mapType(source, function (t) { return getRestType(t, properties, symbol); });
            }
            var omitKeyType = getUnionType(ts.map(properties, getLiteralTypeFromPropertyName));
            var spreadableProperties = [];
            var unspreadableToRestKeys = [];
            for (var _i = 0, _a = getPropertiesOfType(source); _i < _a.length; _i++) {
                var prop = _a[_i];
                var literalTypeFromProperty = getLiteralTypeFromProperty(prop, 8576 /* TypeFlags.StringOrNumberLiteralOrUnique */);
                if (!isTypeAssignableTo(literalTypeFromProperty, omitKeyType)
                    && !(ts.getDeclarationModifierFlagsFromSymbol(prop) & (8 /* ModifierFlags.Private */ | 16 /* ModifierFlags.Protected */))
                    && isSpreadableProperty(prop)) {
                    spreadableProperties.push(prop);
                }
                else {
                    unspreadableToRestKeys.push(literalTypeFromProperty);
                }
            }
            if (isGenericObjectType(source) || isGenericIndexType(omitKeyType)) {
                if (unspreadableToRestKeys.length) {
                    // If the type we're spreading from has properties that cannot
                    // be spread into the rest type (e.g. getters, methods), ensure
                    // they are explicitly omitted, as they would in the non-generic case.
                    omitKeyType = getUnionType(__spreadArray([omitKeyType], unspreadableToRestKeys, true));
                }
                if (omitKeyType.flags & 131072 /* TypeFlags.Never */) {
                    return source;
                }
                var omitTypeAlias = getGlobalOmitSymbol();
                if (!omitTypeAlias) {
                    return errorType;
                }
                return getTypeAliasInstantiation(omitTypeAlias, [source, omitKeyType]);
            }
            var members = ts.createSymbolTable();
            for (var _b = 0, spreadableProperties_1 = spreadableProperties; _b < spreadableProperties_1.length; _b++) {
                var prop = spreadableProperties_1[_b];
                members.set(prop.escapedName, getSpreadSymbol(prop, /*readonly*/ false));
            }
            var result = createAnonymousType(symbol, members, ts.emptyArray, ts.emptyArray, getIndexInfosOfType(source));
            result.objectFlags |= 4194304 /* ObjectFlags.ObjectRestType */;
            return result;
        }
        function isGenericTypeWithUndefinedConstraint(type) {
            return !!(type.flags & 465829888 /* TypeFlags.Instantiable */) && maybeTypeOfKind(getBaseConstraintOfType(type) || unknownType, 32768 /* TypeFlags.Undefined */);
        }
        function getNonUndefinedType(type) {
            var typeOrConstraint = someType(type, isGenericTypeWithUndefinedConstraint) ? mapType(type, function (t) { return t.flags & 465829888 /* TypeFlags.Instantiable */ ? getBaseConstraintOrType(t) : t; }) : type;
            return getTypeWithFacts(typeOrConstraint, 524288 /* TypeFacts.NEUndefined */);
        }
        // Determine the control flow type associated with a destructuring declaration or assignment. The following
        // forms of destructuring are possible:
        //   let { x } = obj;  // BindingElement
        //   let [ x ] = obj;  // BindingElement
        //   { x } = obj;      // ShorthandPropertyAssignment
        //   { x: v } = obj;   // PropertyAssignment
        //   [ x ] = obj;      // Expression
        // We construct a synthetic element access expression corresponding to 'obj.x' such that the control
        // flow analyzer doesn't have to handle all the different syntactic forms.
        function getFlowTypeOfDestructuring(node, declaredType) {
            var reference = getSyntheticElementAccess(node);
            return reference ? getFlowTypeOfReference(reference, declaredType) : declaredType;
        }
        function getSyntheticElementAccess(node) {
            var parentAccess = getParentElementAccess(node);
            if (parentAccess && parentAccess.flowNode) {
                var propName = getDestructuringPropertyName(node);
                if (propName) {
                    var literal = ts.setTextRange(ts.parseNodeFactory.createStringLiteral(propName), node);
                    var lhsExpr = ts.isLeftHandSideExpression(parentAccess) ? parentAccess : ts.parseNodeFactory.createParenthesizedExpression(parentAccess);
                    var result = ts.setTextRange(ts.parseNodeFactory.createElementAccessExpression(lhsExpr, literal), node);
                    ts.setParent(literal, result);
                    ts.setParent(result, node);
                    if (lhsExpr !== parentAccess) {
                        ts.setParent(lhsExpr, result);
                    }
                    result.flowNode = parentAccess.flowNode;
                    return result;
                }
            }
        }
        function getParentElementAccess(node) {
            var ancestor = node.parent.parent;
            switch (ancestor.kind) {
                case 205 /* SyntaxKind.BindingElement */:
                case 299 /* SyntaxKind.PropertyAssignment */:
                    return getSyntheticElementAccess(ancestor);
                case 206 /* SyntaxKind.ArrayLiteralExpression */:
                    return getSyntheticElementAccess(node.parent);
                case 257 /* SyntaxKind.VariableDeclaration */:
                    return ancestor.initializer;
                case 223 /* SyntaxKind.BinaryExpression */:
                    return ancestor.right;
            }
        }
        function getDestructuringPropertyName(node) {
            var parent = node.parent;
            if (node.kind === 205 /* SyntaxKind.BindingElement */ && parent.kind === 203 /* SyntaxKind.ObjectBindingPattern */) {
                return getLiteralPropertyNameText(node.propertyName || node.name);
            }
            if (node.kind === 299 /* SyntaxKind.PropertyAssignment */ || node.kind === 300 /* SyntaxKind.ShorthandPropertyAssignment */) {
                return getLiteralPropertyNameText(node.name);
            }
            return "" + parent.elements.indexOf(node);
        }
        function getLiteralPropertyNameText(name) {
            var type = getLiteralTypeFromPropertyName(name);
            return type.flags & (128 /* TypeFlags.StringLiteral */ | 256 /* TypeFlags.NumberLiteral */) ? "" + type.value : undefined;
        }
        /** Return the inferred type for a binding element */
        function getTypeForBindingElement(declaration) {
            var checkMode = declaration.dotDotDotToken ? 64 /* CheckMode.RestBindingElement */ : 0 /* CheckMode.Normal */;
            var parentType = getTypeForBindingElementParent(declaration.parent.parent, checkMode);
            return parentType && getBindingElementTypeFromParentType(declaration, parentType);
        }
        function getBindingElementTypeFromParentType(declaration, parentType) {
            // If an any type was inferred for parent, infer that for the binding element
            if (isTypeAny(parentType)) {
                return parentType;
            }
            var pattern = declaration.parent;
            // Relax null check on ambient destructuring parameters, since the parameters have no implementation and are just documentation
            if (strictNullChecks && declaration.flags & 16777216 /* NodeFlags.Ambient */ && ts.isParameterDeclaration(declaration)) {
                parentType = getNonNullableType(parentType);
            }
            // Filter `undefined` from the type we check against if the parent has an initializer and that initializer is not possibly `undefined`
            else if (strictNullChecks && pattern.parent.initializer && !(getTypeFacts(getTypeOfInitializer(pattern.parent.initializer)) & 65536 /* TypeFacts.EQUndefined */)) {
                parentType = getTypeWithFacts(parentType, 524288 /* TypeFacts.NEUndefined */);
            }
            var type;
            if (pattern.kind === 203 /* SyntaxKind.ObjectBindingPattern */) {
                if (declaration.dotDotDotToken) {
                    parentType = getReducedType(parentType);
                    if (parentType.flags & 2 /* TypeFlags.Unknown */ || !isValidSpreadType(parentType)) {
                        error(declaration, ts.Diagnostics.Rest_types_may_only_be_created_from_object_types);
                        return errorType;
                    }
                    var literalMembers = [];
                    for (var _i = 0, _a = pattern.elements; _i < _a.length; _i++) {
                        var element = _a[_i];
                        if (!element.dotDotDotToken) {
                            literalMembers.push(element.propertyName || element.name);
                        }
                    }
                    type = getRestType(parentType, literalMembers, declaration.symbol);
                }
                else {
                    // Use explicitly specified property name ({ p: xxx } form), or otherwise the implied name ({ p } form)
                    var name = declaration.propertyName || declaration.name;
                    var indexType = getLiteralTypeFromPropertyName(name);
                    var declaredType = getIndexedAccessType(parentType, indexType, 32 /* AccessFlags.ExpressionPosition */, name);
                    type = getFlowTypeOfDestructuring(declaration, declaredType);
                }
            }
            else {
                // This elementType will be used if the specific property corresponding to this index is not
                // present (aka the tuple element property). This call also checks that the parentType is in
                // fact an iterable or array (depending on target language).
                var elementType = checkIteratedTypeOrElementType(65 /* IterationUse.Destructuring */ | (declaration.dotDotDotToken ? 0 : 128 /* IterationUse.PossiblyOutOfBounds */), parentType, undefinedType, pattern);
                var index_2 = pattern.elements.indexOf(declaration);
                if (declaration.dotDotDotToken) {
                    // If the parent is a tuple type, the rest element has a tuple type of the
                    // remaining tuple element types. Otherwise, the rest element has an array type with same
                    // element type as the parent type.
                    type = everyType(parentType, isTupleType) ?
                        mapType(parentType, function (t) { return sliceTupleType(t, index_2); }) :
                        createArrayType(elementType);
                }
                else if (isArrayLikeType(parentType)) {
                    var indexType = getNumberLiteralType(index_2);
                    var accessFlags = 32 /* AccessFlags.ExpressionPosition */ | (hasDefaultValue(declaration) ? 16 /* AccessFlags.NoTupleBoundsCheck */ : 0);
                    var declaredType = getIndexedAccessTypeOrUndefined(parentType, indexType, accessFlags, declaration.name) || errorType;
                    type = getFlowTypeOfDestructuring(declaration, declaredType);
                }
                else {
                    type = elementType;
                }
            }
            if (!declaration.initializer) {
                return type;
            }
            if (ts.getEffectiveTypeAnnotationNode(ts.walkUpBindingElementsAndPatterns(declaration))) {
                // In strict null checking mode, if a default value of a non-undefined type is specified, remove
                // undefined from the final type.
                return strictNullChecks && !(getTypeFacts(checkDeclarationInitializer(declaration, 0 /* CheckMode.Normal */)) & 16777216 /* TypeFacts.IsUndefined */) ? getNonUndefinedType(type) : type;
            }
            return widenTypeInferredFromInitializer(declaration, getUnionType([getNonUndefinedType(type), checkDeclarationInitializer(declaration, 0 /* CheckMode.Normal */)], 2 /* UnionReduction.Subtype */));
        }
        function getTypeForDeclarationFromJSDocComment(declaration) {
            var jsdocType = ts.getJSDocType(declaration);
            if (jsdocType) {
                return getTypeFromTypeNode(jsdocType);
            }
            return undefined;
        }
        function isNullOrUndefined(node) {
            var expr = ts.skipParentheses(node, /*excludeJSDocTypeAssertions*/ true);
            return expr.kind === 104 /* SyntaxKind.NullKeyword */ || expr.kind === 79 /* SyntaxKind.Identifier */ && getResolvedSymbol(expr) === undefinedSymbol;
        }
        function isEmptyArrayLiteral(node) {
            var expr = ts.skipParentheses(node, /*excludeJSDocTypeAssertions*/ true);
            return expr.kind === 206 /* SyntaxKind.ArrayLiteralExpression */ && expr.elements.length === 0;
        }
        function addOptionality(type, isProperty, isOptional) {
            if (isProperty === void 0) { isProperty = false; }
            if (isOptional === void 0) { isOptional = true; }
            return strictNullChecks && isOptional ? getOptionalType(type, isProperty) : type;
        }
        // Return the inferred type for a variable, parameter, or property declaration
        function getTypeForVariableLikeDeclaration(declaration, includeOptionality, checkMode) {
            // A variable declared in a for..in statement is of type string, or of type keyof T when the
            // right hand expression is of a type parameter type.
            if (ts.isVariableDeclaration(declaration) && declaration.parent.parent.kind === 246 /* SyntaxKind.ForInStatement */) {
                var indexType = getIndexType(getNonNullableTypeIfNeeded(checkExpression(declaration.parent.parent.expression, /*checkMode*/ checkMode)));
                return indexType.flags & (262144 /* TypeFlags.TypeParameter */ | 4194304 /* TypeFlags.Index */) ? getExtractStringType(indexType) : stringType;
            }
            if (ts.isVariableDeclaration(declaration) && declaration.parent.parent.kind === 247 /* SyntaxKind.ForOfStatement */) {
                // checkRightHandSideOfForOf will return undefined if the for-of expression type was
                // missing properties/signatures required to get its iteratedType (like
                // [Symbol.iterator] or next). This may be because we accessed properties from anyType,
                // or it may have led to an error inside getElementTypeOfIterable.
                var forOfStatement = declaration.parent.parent;
                return checkRightHandSideOfForOf(forOfStatement) || anyType;
            }
            if (ts.isBindingPattern(declaration.parent)) {
                return getTypeForBindingElement(declaration);
            }
            var isProperty = ts.isPropertyDeclaration(declaration) && !ts.hasAccessorModifier(declaration) || ts.isPropertySignature(declaration);
            var isOptional = includeOptionality && (isProperty && !!declaration.questionToken ||
                ts.isParameter(declaration) && (!!declaration.questionToken || isJSDocOptionalParameter(declaration)) ||
                isOptionalJSDocPropertyLikeTag(declaration));
            // Use type from type annotation if one is present
            var declaredType = tryGetTypeFromEffectiveTypeNode(declaration);
            if (declaredType) {
                return addOptionality(declaredType, isProperty, isOptional);
            }
            if ((noImplicitAny || ts.isInJSFile(declaration)) &&
                ts.isVariableDeclaration(declaration) && !ts.isBindingPattern(declaration.name) &&
                !(ts.getCombinedModifierFlags(declaration) & 1 /* ModifierFlags.Export */) && !(declaration.flags & 16777216 /* NodeFlags.Ambient */)) {
                // If --noImplicitAny is on or the declaration is in a Javascript file,
                // use control flow tracked 'any' type for non-ambient, non-exported var or let variables with no
                // initializer or a 'null' or 'undefined' initializer.
                if (!(ts.getCombinedNodeFlags(declaration) & 2 /* NodeFlags.Const */) && (!declaration.initializer || isNullOrUndefined(declaration.initializer))) {
                    return autoType;
                }
                // Use control flow tracked 'any[]' type for non-ambient, non-exported variables with an empty array
                // literal initializer.
                if (declaration.initializer && isEmptyArrayLiteral(declaration.initializer)) {
                    return autoArrayType;
                }
            }
            if (ts.isParameter(declaration)) {
                var func = declaration.parent;
                // For a parameter of a set accessor, use the type of the get accessor if one is present
                if (func.kind === 175 /* SyntaxKind.SetAccessor */ && hasBindableName(func)) {
                    var getter = ts.getDeclarationOfKind(getSymbolOfNode(declaration.parent), 174 /* SyntaxKind.GetAccessor */);
                    if (getter) {
                        var getterSignature = getSignatureFromDeclaration(getter);
                        var thisParameter = getAccessorThisParameter(func);
                        if (thisParameter && declaration === thisParameter) {
                            // Use the type from the *getter*
                            ts.Debug.assert(!thisParameter.type);
                            return getTypeOfSymbol(getterSignature.thisParameter);
                        }
                        return getReturnTypeOfSignature(getterSignature);
                    }
                }
                var parameterTypeOfTypeTag = getParameterTypeOfTypeTag(func, declaration);
                if (parameterTypeOfTypeTag)
                    return parameterTypeOfTypeTag;
                // Use contextual parameter type if one is available
                var type = declaration.symbol.escapedName === "this" /* InternalSymbolName.This */ ? getContextualThisParameterType(func) : getContextuallyTypedParameterType(declaration);
                if (type) {
                    return addOptionality(type, /*isProperty*/ false, isOptional);
                }
            }
            // Use the type of the initializer expression if one is present and the declaration is
            // not a parameter of a contextually typed function
            if (ts.hasOnlyExpressionInitializer(declaration) && !!declaration.initializer) {
                if (ts.isInJSFile(declaration) && !ts.isParameter(declaration)) {
                    var containerObjectType = getJSContainerObjectType(declaration, getSymbolOfNode(declaration), ts.getDeclaredExpandoInitializer(declaration));
                    if (containerObjectType) {
                        return containerObjectType;
                    }
                }
                var type = widenTypeInferredFromInitializer(declaration, checkDeclarationInitializer(declaration, checkMode));
                return addOptionality(type, isProperty, isOptional);
            }
            if (ts.isPropertyDeclaration(declaration) && (noImplicitAny || ts.isInJSFile(declaration))) {
                // We have a property declaration with no type annotation or initializer, in noImplicitAny mode or a .js file.
                // Use control flow analysis of this.xxx assignments in the constructor or static block to determine the type of the property.
                if (!ts.hasStaticModifier(declaration)) {
                    var constructor = findConstructorDeclaration(declaration.parent);
                    var type = constructor ? getFlowTypeInConstructor(declaration.symbol, constructor) :
                        ts.getEffectiveModifierFlags(declaration) & 2 /* ModifierFlags.Ambient */ ? getTypeOfPropertyInBaseClass(declaration.symbol) :
                            undefined;
                    return type && addOptionality(type, /*isProperty*/ true, isOptional);
                }
                else {
                    var staticBlocks = ts.filter(declaration.parent.members, ts.isClassStaticBlockDeclaration);
                    var type = staticBlocks.length ? getFlowTypeInStaticBlocks(declaration.symbol, staticBlocks) :
                        ts.getEffectiveModifierFlags(declaration) & 2 /* ModifierFlags.Ambient */ ? getTypeOfPropertyInBaseClass(declaration.symbol) :
                            undefined;
                    return type && addOptionality(type, /*isProperty*/ true, isOptional);
                }
            }
            if (ts.isJsxAttribute(declaration)) {
                // if JSX attribute doesn't have initializer, by default the attribute will have boolean value of true.
                // I.e <Elem attr /> is sugar for <Elem attr={true} />
                return trueType;
            }
            // If the declaration specifies a binding pattern and is not a parameter of a contextually
            // typed function, use the type implied by the binding pattern
            if (ts.isBindingPattern(declaration.name)) {
                return getTypeFromBindingPattern(declaration.name, /*includePatternInType*/ false, /*reportErrors*/ true);
            }
            // No type specified and nothing can be inferred
            return undefined;
        }
        function isConstructorDeclaredProperty(symbol) {
            // A property is considered a constructor declared property when all declaration sites are this.xxx assignments,
            // when no declaration sites have JSDoc type annotations, and when at least one declaration site is in the body of
            // a class constructor.
            if (symbol.valueDeclaration && ts.isBinaryExpression(symbol.valueDeclaration)) {
                var links = getSymbolLinks(symbol);
                if (links.isConstructorDeclaredProperty === undefined) {
                    links.isConstructorDeclaredProperty = false;
                    links.isConstructorDeclaredProperty = !!getDeclaringConstructor(symbol) && ts.every(symbol.declarations, function (declaration) {
                        return ts.isBinaryExpression(declaration) &&
                            isPossiblyAliasedThisProperty(declaration) &&
                            (declaration.left.kind !== 209 /* SyntaxKind.ElementAccessExpression */ || ts.isStringOrNumericLiteralLike(declaration.left.argumentExpression)) &&
                            !getAnnotatedTypeForAssignmentDeclaration(/*declaredType*/ undefined, declaration, symbol, declaration);
                    });
                }
                return links.isConstructorDeclaredProperty;
            }
            return false;
        }
        function isAutoTypedProperty(symbol) {
            // A property is auto-typed when its declaration has no type annotation or initializer and we're in
            // noImplicitAny mode or a .js file.
            var declaration = symbol.valueDeclaration;
            return declaration && ts.isPropertyDeclaration(declaration) && !ts.getEffectiveTypeAnnotationNode(declaration) &&
                !declaration.initializer && (noImplicitAny || ts.isInJSFile(declaration));
        }
        function getDeclaringConstructor(symbol) {
            if (!symbol.declarations) {
                return;
            }
            for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                var declaration = _a[_i];
                var container = ts.getThisContainer(declaration, /*includeArrowFunctions*/ false);
                if (container && (container.kind === 173 /* SyntaxKind.Constructor */ || isJSConstructor(container))) {
                    return container;
                }
            }
        }
        /** Create a synthetic property access flow node after the last statement of the file */
        function getFlowTypeFromCommonJSExport(symbol) {
            var file = ts.getSourceFileOfNode(symbol.declarations[0]);
            var accessName = ts.unescapeLeadingUnderscores(symbol.escapedName);
            var areAllModuleExports = symbol.declarations.every(function (d) { return ts.isInJSFile(d) && ts.isAccessExpression(d) && ts.isModuleExportsAccessExpression(d.expression); });
            var reference = areAllModuleExports
                ? ts.factory.createPropertyAccessExpression(ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier("module"), ts.factory.createIdentifier("exports")), accessName)
                : ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier("exports"), accessName);
            if (areAllModuleExports) {
                ts.setParent(reference.expression.expression, reference.expression);
            }
            ts.setParent(reference.expression, reference);
            ts.setParent(reference, file);
            reference.flowNode = file.endFlowNode;
            return getFlowTypeOfReference(reference, autoType, undefinedType);
        }
        function getFlowTypeInStaticBlocks(symbol, staticBlocks) {
            var accessName = ts.startsWith(symbol.escapedName, "__#")
                ? ts.factory.createPrivateIdentifier(symbol.escapedName.split("@")[1])
                : ts.unescapeLeadingUnderscores(symbol.escapedName);
            for (var _i = 0, staticBlocks_1 = staticBlocks; _i < staticBlocks_1.length; _i++) {
                var staticBlock = staticBlocks_1[_i];
                var reference = ts.factory.createPropertyAccessExpression(ts.factory.createThis(), accessName);
                ts.setParent(reference.expression, reference);
                ts.setParent(reference, staticBlock);
                reference.flowNode = staticBlock.returnFlowNode;
                var flowType = getFlowTypeOfProperty(reference, symbol);
                if (noImplicitAny && (flowType === autoType || flowType === autoArrayType)) {
                    error(symbol.valueDeclaration, ts.Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType));
                }
                // We don't infer a type if assignments are only null or undefined.
                if (everyType(flowType, isNullableType)) {
                    continue;
                }
                return convertAutoToAny(flowType);
            }
        }
        function getFlowTypeInConstructor(symbol, constructor) {
            var accessName = ts.startsWith(symbol.escapedName, "__#")
                ? ts.factory.createPrivateIdentifier(symbol.escapedName.split("@")[1])
                : ts.unescapeLeadingUnderscores(symbol.escapedName);
            var reference = ts.factory.createPropertyAccessExpression(ts.factory.createThis(), accessName);
            ts.setParent(reference.expression, reference);
            ts.setParent(reference, constructor);
            reference.flowNode = constructor.returnFlowNode;
            var flowType = getFlowTypeOfProperty(reference, symbol);
            if (noImplicitAny && (flowType === autoType || flowType === autoArrayType)) {
                error(symbol.valueDeclaration, ts.Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType));
            }
            // We don't infer a type if assignments are only null or undefined.
            return everyType(flowType, isNullableType) ? undefined : convertAutoToAny(flowType);
        }
        function getFlowTypeOfProperty(reference, prop) {
            var initialType = (prop === null || prop === void 0 ? void 0 : prop.valueDeclaration)
                && (!isAutoTypedProperty(prop) || ts.getEffectiveModifierFlags(prop.valueDeclaration) & 2 /* ModifierFlags.Ambient */)
                && getTypeOfPropertyInBaseClass(prop)
                || undefinedType;
            return getFlowTypeOfReference(reference, autoType, initialType);
        }
        function getWidenedTypeForAssignmentDeclaration(symbol, resolvedSymbol) {
            // function/class/{} initializers are themselves containers, so they won't merge in the same way as other initializers
            var container = ts.getAssignedExpandoInitializer(symbol.valueDeclaration);
            if (container) {
                var tag = ts.getJSDocTypeTag(container);
                if (tag && tag.typeExpression) {
                    return getTypeFromTypeNode(tag.typeExpression);
                }
                var containerObjectType = symbol.valueDeclaration && getJSContainerObjectType(symbol.valueDeclaration, symbol, container);
                return containerObjectType || getWidenedLiteralType(checkExpressionCached(container));
            }
            var type;
            var definedInConstructor = false;
            var definedInMethod = false;
            // We use control flow analysis to determine the type of the property if the property qualifies as a constructor
            // declared property and the resulting control flow type isn't just undefined or null.
            if (isConstructorDeclaredProperty(symbol)) {
                type = getFlowTypeInConstructor(symbol, getDeclaringConstructor(symbol));
            }
            if (!type) {
                var types = void 0;
                if (symbol.declarations) {
                    var jsdocType = void 0;
                    for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                        var declaration = _a[_i];
                        var expression = (ts.isBinaryExpression(declaration) || ts.isCallExpression(declaration)) ? declaration :
                            ts.isAccessExpression(declaration) ? ts.isBinaryExpression(declaration.parent) ? declaration.parent : declaration :
                                undefined;
                        if (!expression) {
                            continue; // Non-assignment declaration merged in (eg, an Identifier to mark the thing as a namespace) - skip over it and pull type info from elsewhere
                        }
                        var kind = ts.isAccessExpression(expression)
                            ? ts.getAssignmentDeclarationPropertyAccessKind(expression)
                            : ts.getAssignmentDeclarationKind(expression);
                        if (kind === 4 /* AssignmentDeclarationKind.ThisProperty */ || ts.isBinaryExpression(expression) && isPossiblyAliasedThisProperty(expression, kind)) {
                            if (isDeclarationInConstructor(expression)) {
                                definedInConstructor = true;
                            }
                            else {
                                definedInMethod = true;
                            }
                        }
                        if (!ts.isCallExpression(expression)) {
                            jsdocType = getAnnotatedTypeForAssignmentDeclaration(jsdocType, expression, symbol, declaration);
                        }
                        if (!jsdocType) {
                            (types || (types = [])).push((ts.isBinaryExpression(expression) || ts.isCallExpression(expression)) ? getInitializerTypeFromAssignmentDeclaration(symbol, resolvedSymbol, expression, kind) : neverType);
                        }
                    }
                    type = jsdocType;
                }
                if (!type) {
                    if (!ts.length(types)) {
                        return errorType; // No types from any declarations :(
                    }
                    var constructorTypes = definedInConstructor && symbol.declarations ? getConstructorDefinedThisAssignmentTypes(types, symbol.declarations) : undefined;
                    // use only the constructor types unless they were only assigned null | undefined (including widening variants)
                    if (definedInMethod) {
                        var propType = getTypeOfPropertyInBaseClass(symbol);
                        if (propType) {
                            (constructorTypes || (constructorTypes = [])).push(propType);
                            definedInConstructor = true;
                        }
                    }
                    var sourceTypes = ts.some(constructorTypes, function (t) { return !!(t.flags & ~98304 /* TypeFlags.Nullable */); }) ? constructorTypes : types; // TODO: GH#18217
                    type = getUnionType(sourceTypes);
                }
            }
            var widened = getWidenedType(addOptionality(type, /*isProperty*/ false, definedInMethod && !definedInConstructor));
            if (symbol.valueDeclaration && filterType(widened, function (t) { return !!(t.flags & ~98304 /* TypeFlags.Nullable */); }) === neverType) {
                reportImplicitAny(symbol.valueDeclaration, anyType);
                return anyType;
            }
            return widened;
        }
        function getJSContainerObjectType(decl, symbol, init) {
            var _a, _b;
            if (!ts.isInJSFile(decl) || !init || !ts.isObjectLiteralExpression(init) || init.properties.length) {
                return undefined;
            }
            var exports = ts.createSymbolTable();
            while (ts.isBinaryExpression(decl) || ts.isPropertyAccessExpression(decl)) {
                var s_2 = getSymbolOfNode(decl);
                if ((_a = s_2 === null || s_2 === void 0 ? void 0 : s_2.exports) === null || _a === void 0 ? void 0 : _a.size) {
                    mergeSymbolTable(exports, s_2.exports);
                }
                decl = ts.isBinaryExpression(decl) ? decl.parent : decl.parent.parent;
            }
            var s = getSymbolOfNode(decl);
            if ((_b = s === null || s === void 0 ? void 0 : s.exports) === null || _b === void 0 ? void 0 : _b.size) {
                mergeSymbolTable(exports, s.exports);
            }
            var type = createAnonymousType(symbol, exports, ts.emptyArray, ts.emptyArray, ts.emptyArray);
            type.objectFlags |= 4096 /* ObjectFlags.JSLiteral */;
            return type;
        }
        function getAnnotatedTypeForAssignmentDeclaration(declaredType, expression, symbol, declaration) {
            var _a;
            var typeNode = ts.getEffectiveTypeAnnotationNode(expression.parent);
            if (typeNode) {
                var type = getWidenedType(getTypeFromTypeNode(typeNode));
                if (!declaredType) {
                    return type;
                }
                else if (!isErrorType(declaredType) && !isErrorType(type) && !isTypeIdenticalTo(declaredType, type)) {
                    errorNextVariableOrPropertyDeclarationMustHaveSameType(/*firstDeclaration*/ undefined, declaredType, declaration, type);
                }
            }
            if ((_a = symbol.parent) === null || _a === void 0 ? void 0 : _a.valueDeclaration) {
                var typeNode_2 = ts.getEffectiveTypeAnnotationNode(symbol.parent.valueDeclaration);
                if (typeNode_2) {
                    var annotationSymbol = getPropertyOfType(getTypeFromTypeNode(typeNode_2), symbol.escapedName);
                    if (annotationSymbol) {
                        return getNonMissingTypeOfSymbol(annotationSymbol);
                    }
                }
            }
            return declaredType;
        }
        /** If we don't have an explicit JSDoc type, get the type from the initializer. */
        function getInitializerTypeFromAssignmentDeclaration(symbol, resolvedSymbol, expression, kind) {
            if (ts.isCallExpression(expression)) {
                if (resolvedSymbol) {
                    return getTypeOfSymbol(resolvedSymbol); // This shouldn't happen except under some hopefully forbidden merges of export assignments and object define assignments
                }
                var objectLitType = checkExpressionCached(expression.arguments[2]);
                var valueType = getTypeOfPropertyOfType(objectLitType, "value");
                if (valueType) {
                    return valueType;
                }
                var getFunc = getTypeOfPropertyOfType(objectLitType, "get");
                if (getFunc) {
                    var getSig = getSingleCallSignature(getFunc);
                    if (getSig) {
                        return getReturnTypeOfSignature(getSig);
                    }
                }
                var setFunc = getTypeOfPropertyOfType(objectLitType, "set");
                if (setFunc) {
                    var setSig = getSingleCallSignature(setFunc);
                    if (setSig) {
                        return getTypeOfFirstParameterOfSignature(setSig);
                    }
                }
                return anyType;
            }
            if (containsSameNamedThisProperty(expression.left, expression.right)) {
                return anyType;
            }
            var isDirectExport = kind === 1 /* AssignmentDeclarationKind.ExportsProperty */ && (ts.isPropertyAccessExpression(expression.left) || ts.isElementAccessExpression(expression.left)) && (ts.isModuleExportsAccessExpression(expression.left.expression) || (ts.isIdentifier(expression.left.expression) && ts.isExportsIdentifier(expression.left.expression)));
            var type = resolvedSymbol ? getTypeOfSymbol(resolvedSymbol)
                : isDirectExport ? getRegularTypeOfLiteralType(checkExpressionCached(expression.right))
                    : getWidenedLiteralType(checkExpressionCached(expression.right));
            if (type.flags & 524288 /* TypeFlags.Object */ &&
                kind === 2 /* AssignmentDeclarationKind.ModuleExports */ &&
                symbol.escapedName === "export=" /* InternalSymbolName.ExportEquals */) {
                var exportedType = resolveStructuredTypeMembers(type);
                var members_4 = ts.createSymbolTable();
                ts.copyEntries(exportedType.members, members_4);
                var initialSize = members_4.size;
                if (resolvedSymbol && !resolvedSymbol.exports) {
                    resolvedSymbol.exports = ts.createSymbolTable();
                }
                (resolvedSymbol || symbol).exports.forEach(function (s, name) {
                    var _a;
                    var exportedMember = members_4.get(name);
                    if (exportedMember && exportedMember !== s && !(s.flags & 2097152 /* SymbolFlags.Alias */)) {
                        if (s.flags & 111551 /* SymbolFlags.Value */ && exportedMember.flags & 111551 /* SymbolFlags.Value */) {
                            // If the member has an additional value-like declaration, union the types from the two declarations,
                            // but issue an error if they occurred in two different files. The purpose is to support a JS file with
                            // a pattern like:
                            //
                            // module.exports = { a: true };
                            // module.exports.a = 3;
                            //
                            // but we may have a JS file with `module.exports = { a: true }` along with a TypeScript module augmentation
                            // declaring an `export const a: number`. In that case, we issue a duplicate identifier error, because
                            // it's unclear what that's supposed to mean, so it's probably a mistake.
                            if (s.valueDeclaration && exportedMember.valueDeclaration && ts.getSourceFileOfNode(s.valueDeclaration) !== ts.getSourceFileOfNode(exportedMember.valueDeclaration)) {
                                var unescapedName = ts.unescapeLeadingUnderscores(s.escapedName);
                                var exportedMemberName = ((_a = ts.tryCast(exportedMember.valueDeclaration, ts.isNamedDeclaration)) === null || _a === void 0 ? void 0 : _a.name) || exportedMember.valueDeclaration;
                                ts.addRelatedInfo(error(s.valueDeclaration, ts.Diagnostics.Duplicate_identifier_0, unescapedName), ts.createDiagnosticForNode(exportedMemberName, ts.Diagnostics._0_was_also_declared_here, unescapedName));
                                ts.addRelatedInfo(error(exportedMemberName, ts.Diagnostics.Duplicate_identifier_0, unescapedName), ts.createDiagnosticForNode(s.valueDeclaration, ts.Diagnostics._0_was_also_declared_here, unescapedName));
                            }
                            var union = createSymbol(s.flags | exportedMember.flags, name);
                            union.type = getUnionType([getTypeOfSymbol(s), getTypeOfSymbol(exportedMember)]);
                            union.valueDeclaration = exportedMember.valueDeclaration;
                            union.declarations = ts.concatenate(exportedMember.declarations, s.declarations);
                            members_4.set(name, union);
                        }
                        else {
                            members_4.set(name, mergeSymbol(s, exportedMember));
                        }
                    }
                    else {
                        members_4.set(name, s);
                    }
                });
                var result = createAnonymousType(initialSize !== members_4.size ? undefined : exportedType.symbol, // Only set the type's symbol if it looks to be the same as the original type
                members_4, exportedType.callSignatures, exportedType.constructSignatures, exportedType.indexInfos);
                if (initialSize === members_4.size) {
                    if (type.aliasSymbol) {
                        result.aliasSymbol = type.aliasSymbol;
                        result.aliasTypeArguments = type.aliasTypeArguments;
                    }
                    if (ts.getObjectFlags(type) & 4 /* ObjectFlags.Reference */) {
                        result.aliasSymbol = type.symbol;
                        var args = getTypeArguments(type);
                        result.aliasTypeArguments = ts.length(args) ? args : undefined;
                    }
                }
                result.objectFlags |= (ts.getObjectFlags(type) & 4096 /* ObjectFlags.JSLiteral */); // Propagate JSLiteral flag
                if (result.symbol && result.symbol.flags & 32 /* SymbolFlags.Class */ && type === getDeclaredTypeOfClassOrInterface(result.symbol)) {
                    result.objectFlags |= 16777216 /* ObjectFlags.IsClassInstanceClone */; // Propagate the knowledge that this type is equivalent to the symbol's class instance type
                }
                return result;
            }
            if (isEmptyArrayLiteralType(type)) {
                reportImplicitAny(expression, anyArrayType);
                return anyArrayType;
            }
            return type;
        }
        function containsSameNamedThisProperty(thisProperty, expression) {
            return ts.isPropertyAccessExpression(thisProperty)
                && thisProperty.expression.kind === 108 /* SyntaxKind.ThisKeyword */
                && ts.forEachChildRecursively(expression, function (n) { return isMatchingReference(thisProperty, n); });
        }
        function isDeclarationInConstructor(expression) {
            var thisContainer = ts.getThisContainer(expression, /*includeArrowFunctions*/ false);
            // Properties defined in a constructor (or base constructor, or javascript constructor function) don't get undefined added.
            // Function expressions that are assigned to the prototype count as methods.
            return thisContainer.kind === 173 /* SyntaxKind.Constructor */ ||
                thisContainer.kind === 259 /* SyntaxKind.FunctionDeclaration */ ||
                (thisContainer.kind === 215 /* SyntaxKind.FunctionExpression */ && !ts.isPrototypePropertyAssignment(thisContainer.parent));
        }
        function getConstructorDefinedThisAssignmentTypes(types, declarations) {
            ts.Debug.assert(types.length === declarations.length);
            return types.filter(function (_, i) {
                var declaration = declarations[i];
                var expression = ts.isBinaryExpression(declaration) ? declaration :
                    ts.isBinaryExpression(declaration.parent) ? declaration.parent : undefined;
                return expression && isDeclarationInConstructor(expression);
            });
        }
        // Return the type implied by a binding pattern element. This is the type of the initializer of the element if
        // one is present. Otherwise, if the element is itself a binding pattern, it is the type implied by the binding
        // pattern. Otherwise, it is the type any.
        function getTypeFromBindingElement(element, includePatternInType, reportErrors) {
            if (element.initializer) {
                // The type implied by a binding pattern is independent of context, so we check the initializer with no
                // contextual type or, if the element itself is a binding pattern, with the type implied by that binding
                // pattern.
                var contextualType = ts.isBindingPattern(element.name) ? getTypeFromBindingPattern(element.name, /*includePatternInType*/ true, /*reportErrors*/ false) : unknownType;
                return addOptionality(widenTypeInferredFromInitializer(element, checkDeclarationInitializer(element, 0 /* CheckMode.Normal */, contextualType)));
            }
            if (ts.isBindingPattern(element.name)) {
                return getTypeFromBindingPattern(element.name, includePatternInType, reportErrors);
            }
            if (reportErrors && !declarationBelongsToPrivateAmbientMember(element)) {
                reportImplicitAny(element, anyType);
            }
            // When we're including the pattern in the type (an indication we're obtaining a contextual type), we
            // use a non-inferrable any type. Inference will never directly infer this type, but it is possible
            // to infer a type that contains it, e.g. for a binding pattern like [foo] or { foo }. In such cases,
            // widening of the binding pattern type substitutes a regular any for the non-inferrable any.
            return includePatternInType ? nonInferrableAnyType : anyType;
        }
        // Return the type implied by an object binding pattern
        function getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors) {
            var members = ts.createSymbolTable();
            var stringIndexInfo;
            var objectFlags = 128 /* ObjectFlags.ObjectLiteral */ | 131072 /* ObjectFlags.ContainsObjectOrArrayLiteral */;
            ts.forEach(pattern.elements, function (e) {
                var name = e.propertyName || e.name;
                if (e.dotDotDotToken) {
                    stringIndexInfo = createIndexInfo(stringType, anyType, /*isReadonly*/ false);
                    return;
                }
                var exprType = getLiteralTypeFromPropertyName(name);
                if (!isTypeUsableAsPropertyName(exprType)) {
                    // do not include computed properties in the implied type
                    objectFlags |= 512 /* ObjectFlags.ObjectLiteralPatternWithComputedProperties */;
                    return;
                }
                var text = getPropertyNameFromType(exprType);
                var flags = 4 /* SymbolFlags.Property */ | (e.initializer ? 16777216 /* SymbolFlags.Optional */ : 0);
                var symbol = createSymbol(flags, text);
                symbol.type = getTypeFromBindingElement(e, includePatternInType, reportErrors);
                symbol.bindingElement = e;
                members.set(symbol.escapedName, symbol);
            });
            var result = createAnonymousType(undefined, members, ts.emptyArray, ts.emptyArray, stringIndexInfo ? [stringIndexInfo] : ts.emptyArray);
            result.objectFlags |= objectFlags;
            if (includePatternInType) {
                result.pattern = pattern;
                result.objectFlags |= 131072 /* ObjectFlags.ContainsObjectOrArrayLiteral */;
            }
            return result;
        }
        // Return the type implied by an array binding pattern
        function getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors) {
            var elements = pattern.elements;
            var lastElement = ts.lastOrUndefined(elements);
            var restElement = lastElement && lastElement.kind === 205 /* SyntaxKind.BindingElement */ && lastElement.dotDotDotToken ? lastElement : undefined;
            if (elements.length === 0 || elements.length === 1 && restElement) {
                return languageVersion >= 2 /* ScriptTarget.ES2015 */ ? createIterableType(anyType) : anyArrayType;
            }
            var elementTypes = ts.map(elements, function (e) { return ts.isOmittedExpression(e) ? anyType : getTypeFromBindingElement(e, includePatternInType, reportErrors); });
            var minLength = ts.findLastIndex(elements, function (e) { return !(e === restElement || ts.isOmittedExpression(e) || hasDefaultValue(e)); }, elements.length - 1) + 1;
            var elementFlags = ts.map(elements, function (e, i) { return e === restElement ? 4 /* ElementFlags.Rest */ : i >= minLength ? 2 /* ElementFlags.Optional */ : 1 /* ElementFlags.Required */; });
            var result = createTupleType(elementTypes, elementFlags);
            if (includePatternInType) {
                result = cloneTypeReference(result);
                result.pattern = pattern;
                result.objectFlags |= 131072 /* ObjectFlags.ContainsObjectOrArrayLiteral */;
            }
            return result;
        }
        // Return the type implied by a binding pattern. This is the type implied purely by the binding pattern itself
        // and without regard to its context (i.e. without regard any type annotation or initializer associated with the
        // declaration in which the binding pattern is contained). For example, the implied type of [x, y] is [any, any]
        // and the implied type of { x, y: z = 1 } is { x: any; y: number; }. The type implied by a binding pattern is
        // used as the contextual type of an initializer associated with the binding pattern. Also, for a destructuring
        // parameter with no type annotation or initializer, the type implied by the binding pattern becomes the type of
        // the parameter.
        function getTypeFromBindingPattern(pattern, includePatternInType, reportErrors) {
            if (includePatternInType === void 0) { includePatternInType = false; }
            if (reportErrors === void 0) { reportErrors = false; }
            return pattern.kind === 203 /* SyntaxKind.ObjectBindingPattern */
                ? getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors)
                : getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors);
        }
        // Return the type associated with a variable, parameter, or property declaration. In the simple case this is the type
        // specified in a type annotation or inferred from an initializer. However, in the case of a destructuring declaration it
        // is a bit more involved. For example:
        //
        //   var [x, s = ""] = [1, "one"];
        //
        // Here, the array literal [1, "one"] is contextually typed by the type [any, string], which is the implied type of the
        // binding pattern [x, s = ""]. Because the contextual type is a tuple type, the resulting type of [1, "one"] is the
        // tuple type [number, string]. Thus, the type inferred for 'x' is number and the type inferred for 's' is string.
        function getWidenedTypeForVariableLikeDeclaration(declaration, reportErrors) {
            return widenTypeForVariableLikeDeclaration(getTypeForVariableLikeDeclaration(declaration, /*includeOptionality*/ true, 0 /* CheckMode.Normal */), declaration, reportErrors);
        }
        function isGlobalSymbolConstructor(node) {
            var symbol = getSymbolOfNode(node);
            var globalSymbol = getGlobalESSymbolConstructorTypeSymbol(/*reportErrors*/ false);
            return globalSymbol && symbol && symbol === globalSymbol;
        }
        function widenTypeForVariableLikeDeclaration(type, declaration, reportErrors) {
            if (type) {
                // TODO: If back compat with pre-3.0/4.0 libs isn't required, remove the following SymbolConstructor special case transforming `symbol` into `unique symbol`
                if (type.flags & 4096 /* TypeFlags.ESSymbol */ && isGlobalSymbolConstructor(declaration.parent)) {
                    type = getESSymbolLikeTypeForNode(declaration);
                }
                if (reportErrors) {
                    reportErrorsFromWidening(declaration, type);
                }
                // always widen a 'unique symbol' type if the type was created for a different declaration.
                if (type.flags & 8192 /* TypeFlags.UniqueESSymbol */ && (ts.isBindingElement(declaration) || !declaration.type) && type.symbol !== getSymbolOfNode(declaration)) {
                    type = esSymbolType;
                }
                return getWidenedType(type);
            }
            // Rest parameters default to type any[], other parameters default to type any
            type = ts.isParameter(declaration) && declaration.dotDotDotToken ? anyArrayType : anyType;
            // Report implicit any errors unless this is a private property within an ambient declaration
            if (reportErrors) {
                if (!declarationBelongsToPrivateAmbientMember(declaration)) {
                    reportImplicitAny(declaration, type);
                }
            }
            return type;
        }
        function declarationBelongsToPrivateAmbientMember(declaration) {
            var root = ts.getRootDeclaration(declaration);
            var memberDeclaration = root.kind === 166 /* SyntaxKind.Parameter */ ? root.parent : root;
            return isPrivateWithinAmbient(memberDeclaration);
        }
        function tryGetTypeFromEffectiveTypeNode(node) {
            var typeNode = ts.getEffectiveTypeAnnotationNode(node);
            if (typeNode) {
                return getTypeFromTypeNode(typeNode);
            }
        }
        function getTypeOfVariableOrParameterOrProperty(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                var type = getTypeOfVariableOrParameterOrPropertyWorker(symbol);
                // For a contextually typed parameter it is possible that a type has already
                // been assigned (in assignTypeToParameterAndFixTypeParameters), and we want
                // to preserve this type.
                if (!links.type) {
                    links.type = type;
                }
            }
            return links.type;
        }
        function getTypeOfVariableOrParameterOrPropertyWorker(symbol) {
            // Handle prototype property
            if (symbol.flags & 4194304 /* SymbolFlags.Prototype */) {
                return getTypeOfPrototypeProperty(symbol);
            }
            // CommonsJS require and module both have type any.
            if (symbol === requireSymbol) {
                return anyType;
            }
            if (symbol.flags & 134217728 /* SymbolFlags.ModuleExports */ && symbol.valueDeclaration) {
                var fileSymbol = getSymbolOfNode(ts.getSourceFileOfNode(symbol.valueDeclaration));
                var result = createSymbol(fileSymbol.flags, "exports");
                result.declarations = fileSymbol.declarations ? fileSymbol.declarations.slice() : [];
                result.parent = symbol;
                result.target = fileSymbol;
                if (fileSymbol.valueDeclaration)
                    result.valueDeclaration = fileSymbol.valueDeclaration;
                if (fileSymbol.members)
                    result.members = new ts.Map(fileSymbol.members);
                if (fileSymbol.exports)
                    result.exports = new ts.Map(fileSymbol.exports);
                var members = ts.createSymbolTable();
                members.set("exports", result);
                return createAnonymousType(symbol, members, ts.emptyArray, ts.emptyArray, ts.emptyArray);
            }
            // Handle catch clause variables
            ts.Debug.assertIsDefined(symbol.valueDeclaration);
            var declaration = symbol.valueDeclaration;
            if (ts.isCatchClauseVariableDeclarationOrBindingElement(declaration)) {
                var typeNode = ts.getEffectiveTypeAnnotationNode(declaration);
                if (typeNode === undefined) {
                    return useUnknownInCatchVariables ? unknownType : anyType;
                }
                var type_1 = getTypeOfNode(typeNode);
                // an errorType will make `checkTryStatement` issue an error
                return isTypeAny(type_1) || type_1 === unknownType ? type_1 : errorType;
            }
            // Handle export default expressions
            if (ts.isSourceFile(declaration) && ts.isJsonSourceFile(declaration)) {
                if (!declaration.statements.length) {
                    return emptyObjectType;
                }
                return getWidenedType(getWidenedLiteralType(checkExpression(declaration.statements[0].expression)));
            }
            if (ts.isAccessor(declaration)) {
                // Binding of certain patterns in JS code will occasionally mark symbols as both properties
                // and accessors. Here we dispatch to accessor resolution if needed.
                return getTypeOfAccessors(symbol);
            }
            // Handle variable, parameter or property
            if (!pushTypeResolution(symbol, 0 /* TypeSystemPropertyName.Type */)) {
                // Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
                if (symbol.flags & 512 /* SymbolFlags.ValueModule */ && !(symbol.flags & 67108864 /* SymbolFlags.Assignment */)) {
                    return getTypeOfFuncClassEnumModule(symbol);
                }
                return reportCircularityError(symbol);
            }
            var type;
            if (declaration.kind === 274 /* SyntaxKind.ExportAssignment */) {
                type = widenTypeForVariableLikeDeclaration(tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionCached(declaration.expression), declaration);
            }
            else if (ts.isBinaryExpression(declaration) ||
                (ts.isInJSFile(declaration) &&
                    (ts.isCallExpression(declaration) || (ts.isPropertyAccessExpression(declaration) || ts.isBindableStaticElementAccessExpression(declaration)) && ts.isBinaryExpression(declaration.parent)))) {
                type = getWidenedTypeForAssignmentDeclaration(symbol);
            }
            else if (ts.isPropertyAccessExpression(declaration)
                || ts.isElementAccessExpression(declaration)
                || ts.isIdentifier(declaration)
                || ts.isStringLiteralLike(declaration)
                || ts.isNumericLiteral(declaration)
                || ts.isClassDeclaration(declaration)
                || ts.isFunctionDeclaration(declaration)
                || (ts.isMethodDeclaration(declaration) && !ts.isObjectLiteralMethod(declaration))
                || ts.isMethodSignature(declaration)
                || ts.isSourceFile(declaration)) {
                // Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
                if (symbol.flags & (16 /* SymbolFlags.Function */ | 8192 /* SymbolFlags.Method */ | 32 /* SymbolFlags.Class */ | 384 /* SymbolFlags.Enum */ | 512 /* SymbolFlags.ValueModule */)) {
                    return getTypeOfFuncClassEnumModule(symbol);
                }
                type = ts.isBinaryExpression(declaration.parent) ?
                    getWidenedTypeForAssignmentDeclaration(symbol) :
                    tryGetTypeFromEffectiveTypeNode(declaration) || anyType;
            }
            else if (ts.isPropertyAssignment(declaration)) {
                type = tryGetTypeFromEffectiveTypeNode(declaration) || checkPropertyAssignment(declaration);
            }
            else if (ts.isJsxAttribute(declaration)) {
                type = tryGetTypeFromEffectiveTypeNode(declaration) || checkJsxAttribute(declaration);
            }
            else if (ts.isShorthandPropertyAssignment(declaration)) {
                type = tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionForMutableLocation(declaration.name, 0 /* CheckMode.Normal */);
            }
            else if (ts.isObjectLiteralMethod(declaration)) {
                type = tryGetTypeFromEffectiveTypeNode(declaration) || checkObjectLiteralMethod(declaration, 0 /* CheckMode.Normal */);
            }
            else if (ts.isParameter(declaration)
                || ts.isPropertyDeclaration(declaration)
                || ts.isPropertySignature(declaration)
                || ts.isVariableDeclaration(declaration)
                || ts.isBindingElement(declaration)
                || ts.isJSDocPropertyLikeTag(declaration)) {
                type = getWidenedTypeForVariableLikeDeclaration(declaration, /*includeOptionality*/ true);
            }
            // getTypeOfSymbol dispatches some JS merges incorrectly because their symbol flags are not mutually exclusive.
            // Re-dispatch based on valueDeclaration.kind instead.
            else if (ts.isEnumDeclaration(declaration)) {
                type = getTypeOfFuncClassEnumModule(symbol);
            }
            else if (ts.isEnumMember(declaration)) {
                type = getTypeOfEnumMember(symbol);
            }
            else {
                return ts.Debug.fail("Unhandled declaration kind! " + ts.Debug.formatSyntaxKind(declaration.kind) + " for " + ts.Debug.formatSymbol(symbol));
            }
            if (!popTypeResolution()) {
                // Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
                if (symbol.flags & 512 /* SymbolFlags.ValueModule */ && !(symbol.flags & 67108864 /* SymbolFlags.Assignment */)) {
                    return getTypeOfFuncClassEnumModule(symbol);
                }
                return reportCircularityError(symbol);
            }
            return type;
        }
        function getAnnotatedAccessorTypeNode(accessor) {
            if (accessor) {
                switch (accessor.kind) {
                    case 174 /* SyntaxKind.GetAccessor */:
                        var getterTypeAnnotation = ts.getEffectiveReturnTypeNode(accessor);
                        return getterTypeAnnotation;
                    case 175 /* SyntaxKind.SetAccessor */:
                        var setterTypeAnnotation = ts.getEffectiveSetAccessorTypeAnnotationNode(accessor);
                        return setterTypeAnnotation;
                    case 169 /* SyntaxKind.PropertyDeclaration */:
                        ts.Debug.assert(ts.hasAccessorModifier(accessor));
                        var accessorTypeAnnotation = ts.getEffectiveTypeAnnotationNode(accessor);
                        return accessorTypeAnnotation;
                }
            }
            return undefined;
        }
        function getAnnotatedAccessorType(accessor) {
            var node = getAnnotatedAccessorTypeNode(accessor);
            return node && getTypeFromTypeNode(node);
        }
        function getAnnotatedAccessorThisParameter(accessor) {
            var parameter = getAccessorThisParameter(accessor);
            return parameter && parameter.symbol;
        }
        function getThisTypeOfDeclaration(declaration) {
            return getThisTypeOfSignature(getSignatureFromDeclaration(declaration));
        }
        function getTypeOfAccessors(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                if (!pushTypeResolution(symbol, 0 /* TypeSystemPropertyName.Type */)) {
                    return errorType;
                }
                var getter = ts.getDeclarationOfKind(symbol, 174 /* SyntaxKind.GetAccessor */);
                var setter = ts.getDeclarationOfKind(symbol, 175 /* SyntaxKind.SetAccessor */);
                var accessor = ts.tryCast(ts.getDeclarationOfKind(symbol, 169 /* SyntaxKind.PropertyDeclaration */), ts.isAutoAccessorPropertyDeclaration);
                // We try to resolve a getter type annotation, a setter type annotation, or a getter function
                // body return type inference, in that order.
                var type = getter && ts.isInJSFile(getter) && getTypeForDeclarationFromJSDocComment(getter) ||
                    getAnnotatedAccessorType(getter) ||
                    getAnnotatedAccessorType(setter) ||
                    getAnnotatedAccessorType(accessor) ||
                    getter && getter.body && getReturnTypeFromBody(getter) ||
                    accessor && accessor.initializer && getWidenedTypeForVariableLikeDeclaration(accessor, /*includeOptionality*/ true);
                if (!type) {
                    if (setter && !isPrivateWithinAmbient(setter)) {
                        errorOrSuggestion(noImplicitAny, setter, ts.Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation, symbolToString(symbol));
                    }
                    else if (getter && !isPrivateWithinAmbient(getter)) {
                        errorOrSuggestion(noImplicitAny, getter, ts.Diagnostics.Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation, symbolToString(symbol));
                    }
                    else if (accessor && !isPrivateWithinAmbient(accessor)) {
                        errorOrSuggestion(noImplicitAny, accessor, ts.Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), "any");
                    }
                    type = anyType;
                }
                if (!popTypeResolution()) {
                    if (getAnnotatedAccessorTypeNode(getter)) {
                        error(getter, ts.Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                    }
                    else if (getAnnotatedAccessorTypeNode(setter)) {
                        error(setter, ts.Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                    }
                    else if (getAnnotatedAccessorTypeNode(accessor)) {
                        error(setter, ts.Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                    }
                    else if (getter && noImplicitAny) {
                        error(getter, ts.Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, symbolToString(symbol));
                    }
                    type = anyType;
                }
                links.type = type;
            }
            return links.type;
        }
        function getWriteTypeOfAccessors(symbol) {
            var _a;
            var links = getSymbolLinks(symbol);
            if (!links.writeType) {
                if (!pushTypeResolution(symbol, 8 /* TypeSystemPropertyName.WriteType */)) {
                    return errorType;
                }
                var setter = (_a = ts.getDeclarationOfKind(symbol, 175 /* SyntaxKind.SetAccessor */)) !== null && _a !== void 0 ? _a : ts.tryCast(ts.getDeclarationOfKind(symbol, 169 /* SyntaxKind.PropertyDeclaration */), ts.isAutoAccessorPropertyDeclaration);
                var writeType = getAnnotatedAccessorType(setter);
                if (!popTypeResolution()) {
                    if (getAnnotatedAccessorTypeNode(setter)) {
                        error(setter, ts.Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                    }
                    writeType = anyType;
                }
                // Absent an explicit setter type annotation we use the read type of the accessor.
                links.writeType = writeType || getTypeOfAccessors(symbol);
            }
            return links.writeType;
        }
        function getBaseTypeVariableOfClass(symbol) {
            var baseConstructorType = getBaseConstructorTypeOfClass(getDeclaredTypeOfClassOrInterface(symbol));
            return baseConstructorType.flags & 8650752 /* TypeFlags.TypeVariable */ ? baseConstructorType :
                baseConstructorType.flags & 2097152 /* TypeFlags.Intersection */ ? ts.find(baseConstructorType.types, function (t) { return !!(t.flags & 8650752 /* TypeFlags.TypeVariable */); }) :
                    undefined;
        }
        function getTypeOfFuncClassEnumModule(symbol) {
            var links = getSymbolLinks(symbol);
            var originalLinks = links;
            if (!links.type) {
                var expando = symbol.valueDeclaration && getSymbolOfExpando(symbol.valueDeclaration, /*allowDeclaration*/ false);
                if (expando) {
                    var merged = mergeJSSymbols(symbol, expando);
                    if (merged) {
                        // note:we overwrite links because we just cloned the symbol
                        symbol = links = merged;
                    }
                }
                originalLinks.type = links.type = getTypeOfFuncClassEnumModuleWorker(symbol);
            }
            return links.type;
        }
        function getTypeOfFuncClassEnumModuleWorker(symbol) {
            var declaration = symbol.valueDeclaration;
            if (symbol.flags & 1536 /* SymbolFlags.Module */ && ts.isShorthandAmbientModuleSymbol(symbol)) {
                return anyType;
            }
            else if (declaration && (declaration.kind === 223 /* SyntaxKind.BinaryExpression */ ||
                ts.isAccessExpression(declaration) &&
                    declaration.parent.kind === 223 /* SyntaxKind.BinaryExpression */)) {
                return getWidenedTypeForAssignmentDeclaration(symbol);
            }
            else if (symbol.flags & 512 /* SymbolFlags.ValueModule */ && declaration && ts.isSourceFile(declaration) && declaration.commonJsModuleIndicator) {
                var resolvedModule = resolveExternalModuleSymbol(symbol);
                if (resolvedModule !== symbol) {
                    if (!pushTypeResolution(symbol, 0 /* TypeSystemPropertyName.Type */)) {
                        return errorType;
                    }
                    var exportEquals = getMergedSymbol(symbol.exports.get("export=" /* InternalSymbolName.ExportEquals */));
                    var type_2 = getWidenedTypeForAssignmentDeclaration(exportEquals, exportEquals === resolvedModule ? undefined : resolvedModule);
                    if (!popTypeResolution()) {
                        return reportCircularityError(symbol);
                    }
                    return type_2;
                }
            }
            var type = createObjectType(16 /* ObjectFlags.Anonymous */, symbol);
            if (symbol.flags & 32 /* SymbolFlags.Class */) {
                var baseTypeVariable = getBaseTypeVariableOfClass(symbol);
                return baseTypeVariable ? getIntersectionType([type, baseTypeVariable]) : type;
            }
            else {
                return strictNullChecks && symbol.flags & 16777216 /* SymbolFlags.Optional */ ? getOptionalType(type) : type;
            }
        }
        function getTypeOfEnumMember(symbol) {
            var links = getSymbolLinks(symbol);
            return links.type || (links.type = getDeclaredTypeOfEnumMember(symbol));
        }
        function getTypeOfAlias(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                var targetSymbol = resolveAlias(symbol);
                var exportSymbol = symbol.declarations && getTargetOfAliasDeclaration(getDeclarationOfAliasSymbol(symbol), /*dontResolveAlias*/ true);
                var declaredType = ts.firstDefined(exportSymbol === null || exportSymbol === void 0 ? void 0 : exportSymbol.declarations, function (d) { return ts.isExportAssignment(d) ? tryGetTypeFromEffectiveTypeNode(d) : undefined; });
                // It only makes sense to get the type of a value symbol. If the result of resolving
                // the alias is not a value, then it has no type. To get the type associated with a
                // type symbol, call getDeclaredTypeOfSymbol.
                // This check is important because without it, a call to getTypeOfSymbol could end
                // up recursively calling getTypeOfAlias, causing a stack overflow.
                links.type = (exportSymbol === null || exportSymbol === void 0 ? void 0 : exportSymbol.declarations) && isDuplicatedCommonJSExport(exportSymbol.declarations) && symbol.declarations.length ? getFlowTypeFromCommonJSExport(exportSymbol)
                    : isDuplicatedCommonJSExport(symbol.declarations) ? autoType
                        : declaredType ? declaredType
                            : getAllSymbolFlags(targetSymbol) & 111551 /* SymbolFlags.Value */ ? getTypeOfSymbol(targetSymbol)
                                : errorType;
            }
            return links.type;
        }
        function getTypeOfInstantiatedSymbol(symbol) {
            var links = getSymbolLinks(symbol);
            return links.type || (links.type = instantiateType(getTypeOfSymbol(links.target), links.mapper));
        }
        function getWriteTypeOfInstantiatedSymbol(symbol) {
            var links = getSymbolLinks(symbol);
            return links.writeType || (links.writeType = instantiateType(getWriteTypeOfSymbol(links.target), links.mapper));
        }
        function reportCircularityError(symbol) {
            var declaration = symbol.valueDeclaration;
            // Check if variable has type annotation that circularly references the variable itself
            if (ts.getEffectiveTypeAnnotationNode(declaration)) {
                error(symbol.valueDeclaration, ts.Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                return errorType;
            }
            // Check if variable has initializer that circularly references the variable itself
            if (noImplicitAny && (declaration.kind !== 166 /* SyntaxKind.Parameter */ || declaration.initializer)) {
                error(symbol.valueDeclaration, ts.Diagnostics._0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer, symbolToString(symbol));
            }
            // Circularities could also result from parameters in function expressions that end up
            // having themselves as contextual types following type argument inference. In those cases
            // we have already reported an implicit any error so we don't report anything here.
            return anyType;
        }
        function getTypeOfSymbolWithDeferredType(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.type) {
                ts.Debug.assertIsDefined(links.deferralParent);
                ts.Debug.assertIsDefined(links.deferralConstituents);
                links.type = links.deferralParent.flags & 1048576 /* TypeFlags.Union */ ? getUnionType(links.deferralConstituents) : getIntersectionType(links.deferralConstituents);
            }
            return links.type;
        }
        function getWriteTypeOfSymbolWithDeferredType(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.writeType && links.deferralWriteConstituents) {
                ts.Debug.assertIsDefined(links.deferralParent);
                ts.Debug.assertIsDefined(links.deferralConstituents);
                links.writeType = links.deferralParent.flags & 1048576 /* TypeFlags.Union */ ? getUnionType(links.deferralWriteConstituents) : getIntersectionType(links.deferralWriteConstituents);
            }
            return links.writeType;
        }
        /**
         * Distinct write types come only from set accessors, but synthetic union and intersection
         * properties deriving from set accessors will either pre-compute or defer the union or
         * intersection of the writeTypes of their constituents.
         */
        function getWriteTypeOfSymbol(symbol) {
            var checkFlags = ts.getCheckFlags(symbol);
            if (symbol.flags & 4 /* SymbolFlags.Property */) {
                return checkFlags & 2 /* CheckFlags.SyntheticProperty */ ?
                    checkFlags & 65536 /* CheckFlags.DeferredType */ ?
                        getWriteTypeOfSymbolWithDeferredType(symbol) || getTypeOfSymbolWithDeferredType(symbol) :
                        symbol.writeType || symbol.type :
                    getTypeOfSymbol(symbol);
            }
            if (symbol.flags & 98304 /* SymbolFlags.Accessor */) {
                return checkFlags & 1 /* CheckFlags.Instantiated */ ?
                    getWriteTypeOfInstantiatedSymbol(symbol) :
                    getWriteTypeOfAccessors(symbol);
            }
            return getTypeOfSymbol(symbol);
        }
        function getTypeOfSymbol(symbol) {
            var checkFlags = ts.getCheckFlags(symbol);
            if (checkFlags & 65536 /* CheckFlags.DeferredType */) {
                return getTypeOfSymbolWithDeferredType(symbol);
            }
            if (checkFlags & 1 /* CheckFlags.Instantiated */) {
                return getTypeOfInstantiatedSymbol(symbol);
            }
            if (checkFlags & 262144 /* CheckFlags.Mapped */) {
                return getTypeOfMappedSymbol(symbol);
            }
            if (checkFlags & 8192 /* CheckFlags.ReverseMapped */) {
                return getTypeOfReverseMappedSymbol(symbol);
            }
            if (symbol.flags & (3 /* SymbolFlags.Variable */ | 4 /* SymbolFlags.Property */)) {
                return getTypeOfVariableOrParameterOrProperty(symbol);
            }
            if (symbol.flags & (16 /* SymbolFlags.Function */ | 8192 /* SymbolFlags.Method */ | 32 /* SymbolFlags.Class */ | 384 /* SymbolFlags.Enum */ | 512 /* SymbolFlags.ValueModule */)) {
                return getTypeOfFuncClassEnumModule(symbol);
            }
            if (symbol.flags & 8 /* SymbolFlags.EnumMember */) {
                return getTypeOfEnumMember(symbol);
            }
            if (symbol.flags & 98304 /* SymbolFlags.Accessor */) {
                return getTypeOfAccessors(symbol);
            }
            if (symbol.flags & 2097152 /* SymbolFlags.Alias */) {
                return getTypeOfAlias(symbol);
            }
            return errorType;
        }
        function getNonMissingTypeOfSymbol(symbol) {
            return removeMissingType(getTypeOfSymbol(symbol), !!(symbol.flags & 16777216 /* SymbolFlags.Optional */));
        }
        function isReferenceToType(type, target) {
            return type !== undefined
                && target !== undefined
                && (ts.getObjectFlags(type) & 4 /* ObjectFlags.Reference */) !== 0
                && type.target === target;
        }
        function getTargetType(type) {
            return ts.getObjectFlags(type) & 4 /* ObjectFlags.Reference */ ? type.target : type;
        }
        // TODO: GH#18217 If `checkBase` is undefined, we should not call this because this will always return false.
        function hasBaseType(type, checkBase) {
            return check(type);
            function check(type) {
                if (ts.getObjectFlags(type) & (3 /* ObjectFlags.ClassOrInterface */ | 4 /* ObjectFlags.Reference */)) {
                    var target = getTargetType(type);
                    return target === checkBase || ts.some(getBaseTypes(target), check);
                }
                else if (type.flags & 2097152 /* TypeFlags.Intersection */) {
                    return ts.some(type.types, check);
                }
                return false;
            }
        }
        // Appends the type parameters given by a list of declarations to a set of type parameters and returns the resulting set.
        // The function allocates a new array if the input type parameter set is undefined, but otherwise it modifies the set
        // in-place and returns the same array.
        function appendTypeParameters(typeParameters, declarations) {
            for (var _i = 0, declarations_2 = declarations; _i < declarations_2.length; _i++) {
                var declaration = declarations_2[_i];
                typeParameters = ts.appendIfUnique(typeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfNode(declaration)));
            }
            return typeParameters;
        }
        // Return the outer type parameters of a node or undefined if the node has no outer type parameters.
        function getOuterTypeParameters(node, includeThisTypes) {
            while (true) {
                node = node.parent; // TODO: GH#18217 Use SourceFile kind check instead
                if (node && ts.isBinaryExpression(node)) {
                    // prototype assignments get the outer type parameters of their constructor function
                    var assignmentKind = ts.getAssignmentDeclarationKind(node);
                    if (assignmentKind === 6 /* AssignmentDeclarationKind.Prototype */ || assignmentKind === 3 /* AssignmentDeclarationKind.PrototypeProperty */) {
                        var symbol = getSymbolOfNode(node.left);
                        if (symbol && symbol.parent && !ts.findAncestor(symbol.parent.valueDeclaration, function (d) { return node === d; })) {
                            node = symbol.parent.valueDeclaration;
                        }
                    }
                }
                if (!node) {
                    return undefined;
                }
                switch (node.kind) {
                    case 260 /* SyntaxKind.ClassDeclaration */:
                    case 228 /* SyntaxKind.ClassExpression */:
                    case 261 /* SyntaxKind.InterfaceDeclaration */:
                    case 176 /* SyntaxKind.CallSignature */:
                    case 177 /* SyntaxKind.ConstructSignature */:
                    case 170 /* SyntaxKind.MethodSignature */:
                    case 181 /* SyntaxKind.FunctionType */:
                    case 182 /* SyntaxKind.ConstructorType */:
                    case 320 /* SyntaxKind.JSDocFunctionType */:
                    case 259 /* SyntaxKind.FunctionDeclaration */:
                    case 171 /* SyntaxKind.MethodDeclaration */:
                    case 215 /* SyntaxKind.FunctionExpression */:
                    case 216 /* SyntaxKind.ArrowFunction */:
                    case 262 /* SyntaxKind.TypeAliasDeclaration */:
                    case 347 /* SyntaxKind.JSDocTemplateTag */:
                    case 348 /* SyntaxKind.JSDocTypedefTag */:
                    case 342 /* SyntaxKind.JSDocEnumTag */:
                    case 341 /* SyntaxKind.JSDocCallbackTag */:
                    case 197 /* SyntaxKind.MappedType */:
                    case 191 /* SyntaxKind.ConditionalType */: {
                        var outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);
                        if (node.kind === 197 /* SyntaxKind.MappedType */) {
                            return ts.append(outerTypeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfNode(node.typeParameter)));
                        }
                        else if (node.kind === 191 /* SyntaxKind.ConditionalType */) {
                            return ts.concatenate(outerTypeParameters, getInferTypeParameters(node));
                        }
                        var outerAndOwnTypeParameters = appendTypeParameters(outerTypeParameters, ts.getEffectiveTypeParameterDeclarations(node));
                        var thisType = includeThisTypes &&
                            (node.kind === 260 /* SyntaxKind.ClassDeclaration */ || node.kind === 228 /* SyntaxKind.ClassExpression */ || node.kind === 261 /* SyntaxKind.InterfaceDeclaration */ || isJSConstructor(node)) &&
                            getDeclaredTypeOfClassOrInterface(getSymbolOfNode(node)).thisType;
                        return thisType ? ts.append(outerAndOwnTypeParameters, thisType) : outerAndOwnTypeParameters;
                    }
                    case 343 /* SyntaxKind.JSDocParameterTag */:
                        var paramSymbol = ts.getParameterSymbolFromJSDoc(node);
                        if (paramSymbol) {
                            node = paramSymbol.valueDeclaration;
                        }
                        break;
                    case 323 /* SyntaxKind.JSDoc */: {
                        var outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);
                        return node.tags
                            ? appendTypeParameters(outerTypeParameters, ts.flatMap(node.tags, function (t) { return ts.isJSDocTemplateTag(t) ? t.typeParameters : undefined; }))
                            : outerTypeParameters;
                    }
                }
            }
        }
        // The outer type parameters are those defined by enclosing generic classes, methods, or functions.
        function getOuterTypeParametersOfClassOrInterface(symbol) {
            var declaration = symbol.flags & 32 /* SymbolFlags.Class */ ? symbol.valueDeclaration : ts.getDeclarationOfKind(symbol, 261 /* SyntaxKind.InterfaceDeclaration */);
            ts.Debug.assert(!!declaration, "Class was missing valueDeclaration -OR- non-class had no interface declarations");
            return getOuterTypeParameters(declaration);
        }
        // The local type parameters are the combined set of type parameters from all declarations of the class,
        // interface, or type alias.
        function getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol) {
            if (!symbol.declarations) {
                return;
            }
            var result;
            for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                var node = _a[_i];
                if (node.kind === 261 /* SyntaxKind.InterfaceDeclaration */ ||
                    node.kind === 260 /* SyntaxKind.ClassDeclaration */ ||
                    node.kind === 228 /* SyntaxKind.ClassExpression */ ||
                    isJSConstructor(node) ||
                    ts.isTypeAlias(node)) {
                    var declaration = node;
                    result = appendTypeParameters(result, ts.getEffectiveTypeParameterDeclarations(declaration));
                }
            }
            return result;
        }
        // The full set of type parameters for a generic class or interface type consists of its outer type parameters plus
        // its locally declared type parameters.
        function getTypeParametersOfClassOrInterface(symbol) {
            return ts.concatenate(getOuterTypeParametersOfClassOrInterface(symbol), getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol));
        }
        // A type is a mixin constructor if it has a single construct signature taking no type parameters and a single
        // rest parameter of type any[].
        function isMixinConstructorType(type) {
            var signatures = getSignaturesOfType(type, 1 /* SignatureKind.Construct */);
            if (signatures.length === 1) {
                var s = signatures[0];
                if (!s.typeParameters && s.parameters.length === 1 && signatureHasRestParameter(s)) {
                    var paramType = getTypeOfParameter(s.parameters[0]);
                    return isTypeAny(paramType) || getElementTypeOfArrayType(paramType) === anyType;
                }
            }
            return false;
        }
        function isConstructorType(type) {
            if (getSignaturesOfType(type, 1 /* SignatureKind.Construct */).length > 0) {
                return true;
            }
            if (type.flags & 8650752 /* TypeFlags.TypeVariable */) {
                var constraint = getBaseConstraintOfType(type);
                return !!constraint && isMixinConstructorType(constraint);
            }
            return false;
        }
        function getBaseTypeNodeOfClass(type) {
            var decl = ts.getClassLikeDeclarationOfSymbol(type.symbol);
            return decl && ts.getEffectiveBaseTypeNode(decl);
        }
        function getConstructorsForTypeArguments(type, typeArgumentNodes, location) {
            var typeArgCount = ts.length(typeArgumentNodes);
            var isJavascript = ts.isInJSFile(location);
            return ts.filter(getSignaturesOfType(type, 1 /* SignatureKind.Construct */), function (sig) { return (isJavascript || typeArgCount >= getMinTypeArgumentCount(sig.typeParameters)) && typeArgCount <= ts.length(sig.typeParameters); });
        }
        function getInstantiatedConstructorsForTypeArguments(type, typeArgumentNodes, location) {
            var signatures = getConstructorsForTypeArguments(type, typeArgumentNodes, location);
            var typeArguments = ts.map(typeArgumentNodes, getTypeFromTypeNode);
            return ts.sameMap(signatures, function (sig) { return ts.some(sig.typeParameters) ? getSignatureInstantiation(sig, typeArguments, ts.isInJSFile(location)) : sig; });
        }
        /**
         * The base constructor of a class can resolve to
         * * undefinedType if the class has no extends clause,
         * * unknownType if an error occurred during resolution of the extends expression,
         * * nullType if the extends expression is the null value,
         * * anyType if the extends expression has type any, or
         * * an object type with at least one construct signature.
         */
        function getBaseConstructorTypeOfClass(type) {
            if (!type.resolvedBaseConstructorType) {
                var decl = ts.getClassLikeDeclarationOfSymbol(type.symbol);
                var extended = decl && ts.getEffectiveBaseTypeNode(decl);
                var baseTypeNode = getBaseTypeNodeOfClass(type);
                if (!baseTypeNode) {
                    return type.resolvedBaseConstructorType = undefinedType;
                }
                if (!pushTypeResolution(type, 1 /* TypeSystemPropertyName.ResolvedBaseConstructorType */)) {
                    return errorType;
                }
                var baseConstructorType = checkExpression(baseTypeNode.expression);
                if (extended && baseTypeNode !== extended) {
                    ts.Debug.assert(!extended.typeArguments); // Because this is in a JS file, and baseTypeNode is in an @extends tag
                    checkExpression(extended.expression);
                }
                if (baseConstructorType.flags & (524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */)) {
                    // Resolving the members of a class requires us to resolve the base class of that class.
                    // We force resolution here such that we catch circularities now.
                    resolveStructuredTypeMembers(baseConstructorType);
                }
                if (!popTypeResolution()) {
                    error(type.symbol.valueDeclaration, ts.Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression, symbolToString(type.symbol));
                    return type.resolvedBaseConstructorType = errorType;
                }
                if (!(baseConstructorType.flags & 1 /* TypeFlags.Any */) && baseConstructorType !== nullWideningType && !isConstructorType(baseConstructorType)) {
                    var err = error(baseTypeNode.expression, ts.Diagnostics.Type_0_is_not_a_constructor_function_type, typeToString(baseConstructorType));
                    if (baseConstructorType.flags & 262144 /* TypeFlags.TypeParameter */) {
                        var constraint = getConstraintFromTypeParameter(baseConstructorType);
                        var ctorReturn = unknownType;
                        if (constraint) {
                            var ctorSig = getSignaturesOfType(constraint, 1 /* SignatureKind.Construct */);
                            if (ctorSig[0]) {
                                ctorReturn = getReturnTypeOfSignature(ctorSig[0]);
                            }
                        }
                        if (baseConstructorType.symbol.declarations) {
                            ts.addRelatedInfo(err, ts.createDiagnosticForNode(baseConstructorType.symbol.declarations[0], ts.Diagnostics.Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1, symbolToString(baseConstructorType.symbol), typeToString(ctorReturn)));
                        }
                    }
                    return type.resolvedBaseConstructorType = errorType;
                }
                type.resolvedBaseConstructorType = baseConstructorType;
            }
            return type.resolvedBaseConstructorType;
        }
        function getImplementsTypes(type) {
            var resolvedImplementsTypes = ts.emptyArray;
            if (type.symbol.declarations) {
                for (var _i = 0, _a = type.symbol.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    var implementsTypeNodes = ts.getEffectiveImplementsTypeNodes(declaration);
                    if (!implementsTypeNodes)
                        continue;
                    for (var _b = 0, implementsTypeNodes_1 = implementsTypeNodes; _b < implementsTypeNodes_1.length; _b++) {
                        var node = implementsTypeNodes_1[_b];
                        var implementsType = getTypeFromTypeNode(node);
                        if (!isErrorType(implementsType)) {
                            if (resolvedImplementsTypes === ts.emptyArray) {
                                resolvedImplementsTypes = [implementsType];
                            }
                            else {
                                resolvedImplementsTypes.push(implementsType);
                            }
                        }
                    }
                }
            }
            return resolvedImplementsTypes;
        }
        function reportCircularBaseType(node, type) {
            error(node, ts.Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, /*enclosingDeclaration*/ undefined, 2 /* TypeFormatFlags.WriteArrayAsGenericType */));
        }
        function getBaseTypes(type) {
            if (!type.baseTypesResolved) {
                if (pushTypeResolution(type, 7 /* TypeSystemPropertyName.ResolvedBaseTypes */)) {
                    if (type.objectFlags & 8 /* ObjectFlags.Tuple */) {
                        type.resolvedBaseTypes = [getTupleBaseType(type)];
                    }
                    else if (type.symbol.flags & (32 /* SymbolFlags.Class */ | 64 /* SymbolFlags.Interface */)) {
                        if (type.symbol.flags & 32 /* SymbolFlags.Class */) {
                            resolveBaseTypesOfClass(type);
                        }
                        if (type.symbol.flags & 64 /* SymbolFlags.Interface */) {
                            resolveBaseTypesOfInterface(type);
                        }
                    }
                    else {
                        ts.Debug.fail("type must be class or interface");
                    }
                    if (!popTypeResolution() && type.symbol.declarations) {
                        for (var _i = 0, _a = type.symbol.declarations; _i < _a.length; _i++) {
                            var declaration = _a[_i];
                            if (declaration.kind === 260 /* SyntaxKind.ClassDeclaration */ || declaration.kind === 261 /* SyntaxKind.InterfaceDeclaration */) {
                                reportCircularBaseType(declaration, type);
                            }
                        }
                    }
                }
                type.baseTypesResolved = true;
            }
            return type.resolvedBaseTypes;
        }
        function getTupleBaseType(type) {
            var elementTypes = ts.sameMap(type.typeParameters, function (t, i) { return type.elementFlags[i] & 8 /* ElementFlags.Variadic */ ? getIndexedAccessType(t, numberType) : t; });
            return createArrayType(getUnionType(elementTypes || ts.emptyArray), type.readonly);
        }
        function resolveBaseTypesOfClass(type) {
            type.resolvedBaseTypes = ts.resolvingEmptyArray;
            var baseConstructorType = getApparentType(getBaseConstructorTypeOfClass(type));
            if (!(baseConstructorType.flags & (524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */ | 1 /* TypeFlags.Any */))) {
                return type.resolvedBaseTypes = ts.emptyArray;
            }
            var baseTypeNode = getBaseTypeNodeOfClass(type);
            var baseType;
            var originalBaseType = baseConstructorType.symbol ? getDeclaredTypeOfSymbol(baseConstructorType.symbol) : undefined;
            if (baseConstructorType.symbol && baseConstructorType.symbol.flags & 32 /* SymbolFlags.Class */ &&
                areAllOuterTypeParametersApplied(originalBaseType)) {
                // When base constructor type is a class with no captured type arguments we know that the constructors all have the same type parameters as the
                // class and all return the instance type of the class. There is no need for further checks and we can apply the
                // type arguments in the same manner as a type reference to get the same error reporting experience.
                baseType = getTypeFromClassOrInterfaceReference(baseTypeNode, baseConstructorType.symbol);
            }
            else if (baseConstructorType.flags & 1 /* TypeFlags.Any */) {
                baseType = baseConstructorType;
            }
            else {
                // The class derives from a "class-like" constructor function, check that we have at least one construct signature
                // with a matching number of type parameters and use the return type of the first instantiated signature. Elsewhere
                // we check that all instantiated signatures return the same type.
                var constructors = getInstantiatedConstructorsForTypeArguments(baseConstructorType, baseTypeNode.typeArguments, baseTypeNode);
                if (!constructors.length) {
                    error(baseTypeNode.expression, ts.Diagnostics.No_base_constructor_has_the_specified_number_of_type_arguments);
                    return type.resolvedBaseTypes = ts.emptyArray;
                }
                baseType = getReturnTypeOfSignature(constructors[0]);
            }
            if (isErrorType(baseType)) {
                return type.resolvedBaseTypes = ts.emptyArray;
            }
            var reducedBaseType = getReducedType(baseType);
            if (!isValidBaseType(reducedBaseType)) {
                var elaboration = elaborateNeverIntersection(/*errorInfo*/ undefined, baseType);
                var diagnostic = ts.chainDiagnosticMessages(elaboration, ts.Diagnostics.Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members, typeToString(reducedBaseType));
                diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(baseTypeNode.expression, diagnostic));
                return type.resolvedBaseTypes = ts.emptyArray;
            }
            if (type === reducedBaseType || hasBaseType(reducedBaseType, type)) {
                error(type.symbol.valueDeclaration, ts.Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, /*enclosingDeclaration*/ undefined, 2 /* TypeFormatFlags.WriteArrayAsGenericType */));
                return type.resolvedBaseTypes = ts.emptyArray;
            }
            if (type.resolvedBaseTypes === ts.resolvingEmptyArray) {
                // Circular reference, likely through instantiation of default parameters
                // (otherwise there'd be an error from hasBaseType) - this is fine, but `.members` should be reset
                // as `getIndexedAccessType` via `instantiateType` via `getTypeFromClassOrInterfaceReference` forces a
                // partial instantiation of the members without the base types fully resolved
                type.members = undefined;
            }
            return type.resolvedBaseTypes = [reducedBaseType];
        }
        function areAllOuterTypeParametersApplied(type) {
            // An unapplied type parameter has its symbol still the same as the matching argument symbol.
            // Since parameters are applied outer-to-inner, only the last outer parameter needs to be checked.
            var outerTypeParameters = type.outerTypeParameters;
            if (outerTypeParameters) {
                var last_1 = outerTypeParameters.length - 1;
                var typeArguments = getTypeArguments(type);
                return outerTypeParameters[last_1].symbol !== typeArguments[last_1].symbol;
            }
            return true;
        }
        // A valid base type is `any`, an object type or intersection of object types.
        function isValidBaseType(type) {
            if (type.flags & 262144 /* TypeFlags.TypeParameter */) {
                var constraint = getBaseConstraintOfType(type);
                if (constraint) {
                    return isValidBaseType(constraint);
                }
            }
            // TODO: Given that we allow type parmeters here now, is this `!isGenericMappedType(type)` check really needed?
            // There's no reason a `T` should be allowed while a `Readonly<T>` should not.
            return !!(type.flags & (524288 /* TypeFlags.Object */ | 67108864 /* TypeFlags.NonPrimitive */ | 1 /* TypeFlags.Any */) && !isGenericMappedType(type) ||
                type.flags & 2097152 /* TypeFlags.Intersection */ && ts.every(type.types, isValidBaseType));
        }
        function resolveBaseTypesOfInterface(type) {
            type.resolvedBaseTypes = type.resolvedBaseTypes || ts.emptyArray;
            if (type.symbol.declarations) {
                for (var _i = 0, _a = type.symbol.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    if (declaration.kind === 261 /* SyntaxKind.InterfaceDeclaration */ && ts.getInterfaceBaseTypeNodes(declaration)) {
                        for (var _b = 0, _c = ts.getInterfaceBaseTypeNodes(declaration); _b < _c.length; _b++) {
                            var node = _c[_b];
                            var baseType = getReducedType(getTypeFromTypeNode(node));
                            if (!isErrorType(baseType)) {
                                if (isValidBaseType(baseType)) {
                                    if (type !== baseType && !hasBaseType(baseType, type)) {
                                        if (type.resolvedBaseTypes === ts.emptyArray) {
                                            type.resolvedBaseTypes = [baseType];
                                        }
                                        else {
                                            type.resolvedBaseTypes.push(baseType);
                                        }
                                    }
                                    else {
                                        reportCircularBaseType(declaration, type);
                                    }
                                }
                                else {
                                    error(node, ts.Diagnostics.An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members);
                                }
                            }
                        }
                    }
                }
            }
        }
        /**
         * Returns true if the interface given by the symbol is free of "this" references.
         *
         * Specifically, the result is true if the interface itself contains no references
         * to "this" in its body, if all base types are interfaces,
         * and if none of the base interfaces have a "this" type.
         */
        function isThislessInterface(symbol) {
            if (!symbol.declarations) {
                return true;
            }
            for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                var declaration = _a[_i];
                if (declaration.kind === 261 /* SyntaxKind.InterfaceDeclaration */) {
                    if (declaration.flags & 128 /* NodeFlags.ContainsThis */) {
                        return false;
                    }
                    var baseTypeNodes = ts.getInterfaceBaseTypeNodes(declaration);
                    if (baseTypeNodes) {
                        for (var _b = 0, baseTypeNodes_1 = baseTypeNodes; _b < baseTypeNodes_1.length; _b++) {
                            var node = baseTypeNodes_1[_b];
                            if (ts.isEntityNameExpression(node.expression)) {
                                var baseSymbol = resolveEntityName(node.expression, 788968 /* SymbolFlags.Type */, /*ignoreErrors*/ true);
                                if (!baseSymbol || !(baseSymbol.flags & 64 /* SymbolFlags.Interface */) || getDeclaredTypeOfClassOrInterface(baseSymbol).thisType) {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
            return true;
        }
        function getDeclaredTypeOfClassOrInterface(symbol) {
            var links = getSymbolLinks(symbol);
            var originalLinks = links;
            if (!links.declaredType) {
                var kind = symbol.flags & 32 /* SymbolFlags.Class */ ? 1 /* ObjectFlags.Class */ : 2 /* ObjectFlags.Interface */;
                var merged = mergeJSSymbols(symbol, symbol.valueDeclaration && getAssignedClassSymbol(symbol.valueDeclaration));
                if (merged) {
                    // note:we overwrite links because we just cloned the symbol
                    symbol = links = merged;
                }
                var type = originalLinks.declaredType = links.declaredType = createObjectType(kind, symbol);
                var outerTypeParameters = getOuterTypeParametersOfClassOrInterface(symbol);
                var localTypeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                // A class or interface is generic if it has type parameters or a "this" type. We always give classes a "this" type
                // because it is not feasible to analyze all members to determine if the "this" type escapes the class (in particular,
                // property types inferred from initializers and method return types inferred from return statements are very hard
                // to exhaustively analyze). We give interfaces a "this" type if we can't definitely determine that they are free of
                // "this" references.
                if (outerTypeParameters || localTypeParameters || kind === 1 /* ObjectFlags.Class */ || !isThislessInterface(symbol)) {
                    type.objectFlags |= 4 /* ObjectFlags.Reference */;
                    type.typeParameters = ts.concatenate(outerTypeParameters, localTypeParameters);
                    type.outerTypeParameters = outerTypeParameters;
                    type.localTypeParameters = localTypeParameters;
                    type.instantiations = new ts.Map();
                    type.instantiations.set(getTypeListId(type.typeParameters), type);
                    type.target = type;
                    type.resolvedTypeArguments = type.typeParameters;
                    type.thisType = createTypeParameter(symbol);
                    type.thisType.isThisType = true;
                    type.thisType.constraint = type;
                }
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfTypeAlias(symbol) {
            var _a;
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                // Note that we use the links object as the target here because the symbol object is used as the unique
                // identity for resolution of the 'type' property in SymbolLinks.
                if (!pushTypeResolution(symbol, 2 /* TypeSystemPropertyName.DeclaredType */)) {
                    return errorType;
                }
                var declaration = ts.Debug.checkDefined((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isTypeAlias), "Type alias symbol with no valid declaration found");
                var typeNode = ts.isJSDocTypeAlias(declaration) ? declaration.typeExpression : declaration.type;
                // If typeNode is missing, we will error in checkJSDocTypedefTag.
                var type = typeNode ? getTypeFromTypeNode(typeNode) : errorType;
                if (popTypeResolution()) {
                    var typeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                    if (typeParameters) {
                        // Initialize the instantiation cache for generic type aliases. The declared type corresponds to
                        // an instantiation of the type alias with the type parameters supplied as type arguments.
                        links.typeParameters = typeParameters;
                        links.instantiations = new ts.Map();
                        links.instantiations.set(getTypeListId(typeParameters), type);
                    }
                }
                else {
                    type = errorType;
                    if (declaration.kind === 342 /* SyntaxKind.JSDocEnumTag */) {
                        error(declaration.typeExpression.type, ts.Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol));
                    }
                    else {
                        error(ts.isNamedDeclaration(declaration) ? declaration.name || declaration : declaration, ts.Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol));
                    }
                }
                links.declaredType = type;
            }
            return links.declaredType;
        }
        function isStringConcatExpression(expr) {
            if (ts.isStringLiteralLike(expr)) {
                return true;
            }
            else if (expr.kind === 223 /* SyntaxKind.BinaryExpression */) {
                return isStringConcatExpression(expr.left) && isStringConcatExpression(expr.right);
            }
            return false;
        }
        function isLiteralEnumMember(member) {
            var expr = member.initializer;
            if (!expr) {
                return !(member.flags & 16777216 /* NodeFlags.Ambient */);
            }
            switch (expr.kind) {
                case 10 /* SyntaxKind.StringLiteral */:
                case 8 /* SyntaxKind.NumericLiteral */:
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                    return true;
                case 221 /* SyntaxKind.PrefixUnaryExpression */:
                    return expr.operator === 40 /* SyntaxKind.MinusToken */ &&
                        expr.operand.kind === 8 /* SyntaxKind.NumericLiteral */;
                case 79 /* SyntaxKind.Identifier */:
                    return ts.nodeIsMissing(expr) || !!getSymbolOfNode(member.parent).exports.get(expr.escapedText);
                case 223 /* SyntaxKind.BinaryExpression */:
                    return isStringConcatExpression(expr);
                default:
                    return false;
            }
        }
        function getEnumKind(symbol) {
            var links = getSymbolLinks(symbol);
            if (links.enumKind !== undefined) {
                return links.enumKind;
            }
            var hasNonLiteralMember = false;
            if (symbol.declarations) {
                for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    if (declaration.kind === 263 /* SyntaxKind.EnumDeclaration */) {
                        for (var _b = 0, _c = declaration.members; _b < _c.length; _b++) {
                            var member = _c[_b];
                            if (member.initializer && ts.isStringLiteralLike(member.initializer)) {
                                return links.enumKind = 1 /* EnumKind.Literal */;
                            }
                            if (!isLiteralEnumMember(member)) {
                                hasNonLiteralMember = true;
                            }
                        }
                    }
                }
            }
            return links.enumKind = hasNonLiteralMember ? 0 /* EnumKind.Numeric */ : 1 /* EnumKind.Literal */;
        }
        function getBaseTypeOfEnumLiteralType(type) {
            return type.flags & 1024 /* TypeFlags.EnumLiteral */ && !(type.flags & 1048576 /* TypeFlags.Union */) ? getDeclaredTypeOfSymbol(getParentOfSymbol(type.symbol)) : type;
        }
        function getDeclaredTypeOfEnum(symbol) {
            var links = getSymbolLinks(symbol);
            if (links.declaredType) {
                return links.declaredType;
            }
            if (getEnumKind(symbol) === 1 /* EnumKind.Literal */) {
                enumCount++;
                var memberTypeList = [];
                if (symbol.declarations) {
                    for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                        var declaration = _a[_i];
                        if (declaration.kind === 263 /* SyntaxKind.EnumDeclaration */) {
                            for (var _b = 0, _c = declaration.members; _b < _c.length; _b++) {
                                var member = _c[_b];
                                var value = getEnumMemberValue(member);
                                var memberType = getFreshTypeOfLiteralType(getEnumLiteralType(value !== undefined ? value : 0, enumCount, getSymbolOfNode(member)));
                                getSymbolLinks(getSymbolOfNode(member)).declaredType = memberType;
                                memberTypeList.push(getRegularTypeOfLiteralType(memberType));
                            }
                        }
                    }
                }
                if (memberTypeList.length) {
                    var enumType_1 = getUnionType(memberTypeList, 1 /* UnionReduction.Literal */, symbol, /*aliasTypeArguments*/ undefined);
                    if (enumType_1.flags & 1048576 /* TypeFlags.Union */) {
                        enumType_1.flags |= 1024 /* TypeFlags.EnumLiteral */;
                        enumType_1.symbol = symbol;
                    }
                    return links.declaredType = enumType_1;
                }
            }
            var enumType = createType(32 /* TypeFlags.Enum */);
            enumType.symbol = symbol;
            return links.declaredType = enumType;
        }
        function getDeclaredTypeOfEnumMember(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.declaredType) {
                var enumType = getDeclaredTypeOfEnum(getParentOfSymbol(symbol));
                if (!links.declaredType) {
                    links.declaredType = enumType;
                }
            }
            return links.declaredType;
        }
        function getDeclaredTypeOfTypeParameter(symbol) {
            var links = getSymbolLinks(symbol);
            return links.declaredType || (links.declaredType = createTypeParameter(symbol));
        }
        function getDeclaredTypeOfAlias(symbol) {
            var links = getSymbolLinks(symbol);
            return links.declaredType || (links.declaredType = getDeclaredTypeOfSymbol(resolveAlias(symbol)));
        }
        function getDeclaredTypeOfSymbol(symbol) {
            return tryGetDeclaredTypeOfSymbol(symbol) || errorType;
        }
        function tryGetDeclaredTypeOfSymbol(symbol) {
            if (symbol.flags & (32 /* SymbolFlags.Class */ | 64 /* SymbolFlags.Interface */)) {
                return getDeclaredTypeOfClassOrInterface(symbol);
            }
            if (symbol.flags & 524288 /* SymbolFlags.TypeAlias */) {
                return getDeclaredTypeOfTypeAlias(symbol);
            }
            if (symbol.flags & 262144 /* SymbolFlags.TypeParameter */) {
                return getDeclaredTypeOfTypeParameter(symbol);
            }
            if (symbol.flags & 384 /* SymbolFlags.Enum */) {
                return getDeclaredTypeOfEnum(symbol);
            }
            if (symbol.flags & 8 /* SymbolFlags.EnumMember */) {
                return getDeclaredTypeOfEnumMember(symbol);
            }
            if (symbol.flags & 2097152 /* SymbolFlags.Alias */) {
                return getDeclaredTypeOfAlias(symbol);
            }
            return undefined;
        }
        /**
         * A type is free of this references if it's the any, string, number, boolean, symbol, or void keyword, a string
         * literal type, an array with an element type that is free of this references, or a type reference that is
         * free of this references.
         */
        function isThislessType(node) {
            switch (node.kind) {
                case 131 /* SyntaxKind.AnyKeyword */:
                case 157 /* SyntaxKind.UnknownKeyword */:
                case 152 /* SyntaxKind.StringKeyword */:
                case 148 /* SyntaxKind.NumberKeyword */:
                case 160 /* SyntaxKind.BigIntKeyword */:
                case 134 /* SyntaxKind.BooleanKeyword */:
                case 153 /* SyntaxKind.SymbolKeyword */:
                case 149 /* SyntaxKind.ObjectKeyword */:
                case 114 /* SyntaxKind.VoidKeyword */:
                case 155 /* SyntaxKind.UndefinedKeyword */:
                case 144 /* SyntaxKind.NeverKeyword */:
                case 198 /* SyntaxKind.LiteralType */:
                    return true;
                case 185 /* SyntaxKind.ArrayType */:
                    return isThislessType(node.elementType);
                case 180 /* SyntaxKind.TypeReference */:
                    return !node.typeArguments || node.typeArguments.every(isThislessType);
            }
            return false;
        }
        /** A type parameter is thisless if its constraint is thisless, or if it has no constraint. */
        function isThislessTypeParameter(node) {
            var constraint = ts.getEffectiveConstraintOfTypeParameter(node);
            return !constraint || isThislessType(constraint);
        }
        /**
         * A variable-like declaration is free of this references if it has a type annotation
         * that is thisless, or if it has no type annotation and no initializer (and is thus of type any).
         */
        function isThislessVariableLikeDeclaration(node) {
            var typeNode = ts.getEffectiveTypeAnnotationNode(node);
            return typeNode ? isThislessType(typeNode) : !ts.hasInitializer(node);
        }
        /**
         * A function-like declaration is considered free of `this` references if it has a return type
         * annotation that is free of this references and if each parameter is thisless and if
         * each type parameter (if present) is thisless.
         */
        function isThislessFunctionLikeDeclaration(node) {
            var returnType = ts.getEffectiveReturnTypeNode(node);
            var typeParameters = ts.getEffectiveTypeParameterDeclarations(node);
            return (node.kind === 173 /* SyntaxKind.Constructor */ || (!!returnType && isThislessType(returnType))) &&
                node.parameters.every(isThislessVariableLikeDeclaration) &&
                typeParameters.every(isThislessTypeParameter);
        }
        /**
         * Returns true if the class or interface member given by the symbol is free of "this" references. The
         * function may return false for symbols that are actually free of "this" references because it is not
         * feasible to perform a complete analysis in all cases. In particular, property members with types
         * inferred from their initializers and function members with inferred return types are conservatively
         * assumed not to be free of "this" references.
         */
        function isThisless(symbol) {
            if (symbol.declarations && symbol.declarations.length === 1) {
                var declaration = symbol.declarations[0];
                if (declaration) {
                    switch (declaration.kind) {
                        case 169 /* SyntaxKind.PropertyDeclaration */:
                        case 168 /* SyntaxKind.PropertySignature */:
                            return isThislessVariableLikeDeclaration(declaration);
                        case 171 /* SyntaxKind.MethodDeclaration */:
                        case 170 /* SyntaxKind.MethodSignature */:
                        case 173 /* SyntaxKind.Constructor */:
                        case 174 /* SyntaxKind.GetAccessor */:
                        case 175 /* SyntaxKind.SetAccessor */:
                            return isThislessFunctionLikeDeclaration(declaration);
                    }
                }
            }
            return false;
        }
        // The mappingThisOnly flag indicates that the only type parameter being mapped is "this". When the flag is true,
        // we check symbols to see if we can quickly conclude they are free of "this" references, thus needing no instantiation.
        function createInstantiatedSymbolTable(symbols, mapper, mappingThisOnly) {
            var result = ts.createSymbolTable();
            for (var _i = 0, symbols_2 = symbols; _i < symbols_2.length; _i++) {
                var symbol = symbols_2[_i];
                result.set(symbol.escapedName, mappingThisOnly && isThisless(symbol) ? symbol : instantiateSymbol(symbol, mapper));
            }
            return result;
        }
        function addInheritedMembers(symbols, baseSymbols) {
            for (var _i = 0, baseSymbols_1 = baseSymbols; _i < baseSymbols_1.length; _i++) {
                var s = baseSymbols_1[_i];
                if (!symbols.has(s.escapedName) && !isStaticPrivateIdentifierProperty(s)) {
                    symbols.set(s.escapedName, s);
                }
            }
        }
        function isStaticPrivateIdentifierProperty(s) {
            return !!s.valueDeclaration && ts.isPrivateIdentifierClassElementDeclaration(s.valueDeclaration) && ts.isStatic(s.valueDeclaration);
        }
        function resolveDeclaredMembers(type) {
            if (!type.declaredProperties) {
                var symbol = type.symbol;
                var members = getMembersOfSymbol(symbol);
                type.declaredProperties = getNamedMembers(members);
                // Start with signatures at empty array in case of recursive types
                type.declaredCallSignatures = ts.emptyArray;
                type.declaredConstructSignatures = ts.emptyArray;
                type.declaredIndexInfos = ts.emptyArray;
                type.declaredCallSignatures = getSignaturesOfSymbol(members.get("__call" /* InternalSymbolName.Call */));
                type.declaredConstructSignatures = getSignaturesOfSymbol(members.get("__new" /* InternalSymbolName.New */));
                type.declaredIndexInfos = getIndexInfosOfSymbol(symbol);
            }
            return type;
        }
        /**
         * Indicates whether a type can be used as a property name.
         */
        function isTypeUsableAsPropertyName(type) {
            return !!(type.flags & 8576 /* TypeFlags.StringOrNumberLiteralOrUnique */);
        }
        /**
         * Indicates whether a declaration name is definitely late-bindable.
         * A declaration name is only late-bindable if:
         * - It is a `ComputedPropertyName`.
         * - Its expression is an `Identifier` or either a `PropertyAccessExpression` an
         * `ElementAccessExpression` consisting only of these same three types of nodes.
         * - The type of its expression is a string or numeric literal type, or is a `unique symbol` type.
         */
        function isLateBindableName(node) {
            if (!ts.isComputedPropertyName(node) && !ts.isElementAccessExpression(node)) {
                return false;
            }
            var expr = ts.isComputedPropertyName(node) ? node.expression : node.argumentExpression;
            return ts.isEntityNameExpression(expr)
                && isTypeUsableAsPropertyName(ts.isComputedPropertyName(node) ? checkComputedPropertyName(node) : checkExpressionCached(expr));
        }
        function isLateBoundName(name) {
            return name.charCodeAt(0) === 95 /* CharacterCodes._ */ &&
                name.charCodeAt(1) === 95 /* CharacterCodes._ */ &&
                name.charCodeAt(2) === 64 /* CharacterCodes.at */;
        }
        /**
         * Indicates whether a declaration has a late-bindable dynamic name.
         */
        function hasLateBindableName(node) {
            var name = ts.getNameOfDeclaration(node);
            return !!name && isLateBindableName(name);
        }
        /**
         * Indicates whether a declaration has an early-bound name or a dynamic name that can be late-bound.
         */
        function hasBindableName(node) {
            return !ts.hasDynamicName(node) || hasLateBindableName(node);
        }
        /**
         * Indicates whether a declaration name is a dynamic name that cannot be late-bound.
         */
        function isNonBindableDynamicName(node) {
            return ts.isDynamicName(node) && !isLateBindableName(node);
        }
        /**
         * Gets the symbolic name for a member from its type.
         */
        function getPropertyNameFromType(type) {
            if (type.flags & 8192 /* TypeFlags.UniqueESSymbol */) {
                return type.escapedName;
            }
            if (type.flags & (128 /* TypeFlags.StringLiteral */ | 256 /* TypeFlags.NumberLiteral */)) {
                return ts.escapeLeadingUnderscores("" + type.value);
            }
            return ts.Debug.fail();
        }
        /**
         * Adds a declaration to a late-bound dynamic member. This performs the same function for
         * late-bound members that `addDeclarationToSymbol` in binder.ts performs for early-bound
         * members.
         */
        function addDeclarationToLateBoundSymbol(symbol, member, symbolFlags) {
            ts.Debug.assert(!!(ts.getCheckFlags(symbol) & 4096 /* CheckFlags.Late */), "Expected a late-bound symbol.");
            symbol.flags |= symbolFlags;
            getSymbolLinks(member.symbol).lateSymbol = symbol;
            if (!symbol.declarations) {
                symbol.declarations = [member];
            }
            else if (!member.symbol.isReplaceableByMethod) {
                symbol.declarations.push(member);
            }
            if (symbolFlags & 111551 /* SymbolFlags.Value */) {
                if (!symbol.valueDeclaration || symbol.valueDeclaration.kind !== member.kind) {
                    symbol.valueDeclaration = member;
                }
            }
        }
        /**
         * Performs late-binding of a dynamic member. This performs the same function for
         * late-bound members that `declareSymbol` in binder.ts performs for early-bound
         * members.
         *
         * If a symbol is a dynamic name from a computed property, we perform an additional "late"
         * binding phase to attempt to resolve the name for the symbol from the type of the computed
         * property's expression. If the type of the expression is a string-literal, numeric-literal,
         * or unique symbol type, we can use that type as the name of the symbol.
         *
         * For example, given:
         *
         *   const x = Symbol();
         *
         *   interface I {
         *     [x]: number;
         *   }
         *
         * The binder gives the property `[x]: number` a special symbol with the name "__computed".
         * In the late-binding phase we can type-check the expression `x` and see that it has a
         * unique symbol type which we can then use as the name of the member. This allows users
         * to define custom symbols that can be used in the members of an object type.
         *
         * @param parent The containing symbol for the member.
         * @param earlySymbols The early-bound symbols of the parent.
         * @param lateSymbols The late-bound symbols of the parent.
         * @param decl The member to bind.
         */
        function lateBindMember(parent, earlySymbols, lateSymbols, decl) {
            ts.Debug.assert(!!decl.symbol, "The member is expected to have a symbol.");
            var links = getNodeLinks(decl);
            if (!links.resolvedSymbol) {
                // In the event we attempt to resolve the late-bound name of this member recursively,
                // fall back to the early-bound name of this member.
                links.resolvedSymbol = decl.symbol;
                var declName = ts.isBinaryExpression(decl) ? decl.left : decl.name;
                var type = ts.isElementAccessExpression(declName) ? checkExpressionCached(declName.argumentExpression) : checkComputedPropertyName(declName);
                if (isTypeUsableAsPropertyName(type)) {
                    var memberName = getPropertyNameFromType(type);
                    var symbolFlags = decl.symbol.flags;
                    // Get or add a late-bound symbol for the member. This allows us to merge late-bound accessor declarations.
                    var lateSymbol = lateSymbols.get(memberName);
                    if (!lateSymbol)
                        lateSymbols.set(memberName, lateSymbol = createSymbol(0 /* SymbolFlags.None */, memberName, 4096 /* CheckFlags.Late */));
                    // Report an error if a late-bound member has the same name as an early-bound member,
                    // or if we have another early-bound symbol declaration with the same name and
                    // conflicting flags.
                    var earlySymbol = earlySymbols && earlySymbols.get(memberName);
                    if (lateSymbol.flags & getExcludedSymbolFlags(symbolFlags) || earlySymbol) {
                        // If we have an existing early-bound member, combine its declarations so that we can
                        // report an error at each declaration.
                        var declarations = earlySymbol ? ts.concatenate(earlySymbol.declarations, lateSymbol.declarations) : lateSymbol.declarations;
                        var name_5 = !(type.flags & 8192 /* TypeFlags.UniqueESSymbol */) && ts.unescapeLeadingUnderscores(memberName) || ts.declarationNameToString(declName);
                        ts.forEach(declarations, function (declaration) { return error(ts.getNameOfDeclaration(declaration) || declaration, ts.Diagnostics.Property_0_was_also_declared_here, name_5); });
                        error(declName || decl, ts.Diagnostics.Duplicate_property_0, name_5);
                        lateSymbol = createSymbol(0 /* SymbolFlags.None */, memberName, 4096 /* CheckFlags.Late */);
                    }
                    lateSymbol.nameType = type;
                    addDeclarationToLateBoundSymbol(lateSymbol, decl, symbolFlags);
                    if (lateSymbol.parent) {
                        ts.Debug.assert(lateSymbol.parent === parent, "Existing symbol parent should match new one");
                    }
                    else {
                        lateSymbol.parent = parent;
                    }
                    return links.resolvedSymbol = lateSymbol;
                }
            }
            return links.resolvedSymbol;
        }
        function getResolvedMembersOrExportsOfSymbol(symbol, resolutionKind) {
            var links = getSymbolLinks(symbol);
            if (!links[resolutionKind]) {
                var isStatic_1 = resolutionKind === "resolvedExports" /* MembersOrExportsResolutionKind.resolvedExports */;
                var earlySymbols = !isStatic_1 ? symbol.members :
                    symbol.flags & 1536 /* SymbolFlags.Module */ ? getExportsOfModuleWorker(symbol) :
                        symbol.exports;
                // In the event we recursively resolve the members/exports of the symbol, we
                // set the initial value of resolvedMembers/resolvedExports to the early-bound
                // members/exports of the symbol.
                links[resolutionKind] = earlySymbols || emptySymbols;
                // fill in any as-yet-unresolved late-bound members.
                var lateSymbols = ts.createSymbolTable();
                for (var _i = 0, _a = symbol.declarations || ts.emptyArray; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    var members = ts.getMembersOfDeclaration(decl);
                    if (members) {
                        for (var _b = 0, members_5 = members; _b < members_5.length; _b++) {
                            var member = members_5[_b];
                            if (isStatic_1 === ts.hasStaticModifier(member)) {
                                if (hasLateBindableName(member)) {
                                    lateBindMember(symbol, earlySymbols, lateSymbols, member);
                                }
                            }
                        }
                    }
                }
                var assignments = symbol.assignmentDeclarationMembers;
                if (assignments) {
                    var decls = ts.arrayFrom(assignments.values());
                    for (var _c = 0, decls_1 = decls; _c < decls_1.length; _c++) {
                        var member = decls_1[_c];
                        var assignmentKind = ts.getAssignmentDeclarationKind(member);
                        var isInstanceMember = assignmentKind === 3 /* AssignmentDeclarationKind.PrototypeProperty */
                            || ts.isBinaryExpression(member) && isPossiblyAliasedThisProperty(member, assignmentKind)
                            || assignmentKind === 9 /* AssignmentDeclarationKind.ObjectDefinePrototypeProperty */
                            || assignmentKind === 6 /* AssignmentDeclarationKind.Prototype */; // A straight `Prototype` assignment probably can never have a computed name
                        if (isStatic_1 === !isInstanceMember) {
                            if (hasLateBindableName(member)) {
                                lateBindMember(symbol, earlySymbols, lateSymbols, member);
                            }
                        }
                    }
                }
                links[resolutionKind] = combineSymbolTables(earlySymbols, lateSymbols) || emptySymbols;
            }
            return links[resolutionKind];
        }
        /**
         * Gets a SymbolTable containing both the early- and late-bound members of a symbol.
         *
         * For a description of late-binding, see `lateBindMember`.
         */
        function getMembersOfSymbol(symbol) {
            return symbol.flags & 6256 /* SymbolFlags.LateBindingContainer */
                ? getResolvedMembersOrExportsOfSymbol(symbol, "resolvedMembers" /* MembersOrExportsResolutionKind.resolvedMembers */)
                : symbol.members || emptySymbols;
        }
        /**
         * If a symbol is the dynamic name of the member of an object type, get the late-bound
         * symbol of the member.
         *
         * For a description of late-binding, see `lateBindMember`.
         */
        function getLateBoundSymbol(symbol) {
            if (symbol.flags & 106500 /* SymbolFlags.ClassMember */ && symbol.escapedName === "__computed" /* InternalSymbolName.Computed */) {
                var links = getSymbolLinks(symbol);
                if (!links.lateSymbol && ts.some(symbol.declarations, hasLateBindableName)) {
                    // force late binding of members/exports. This will set the late-bound symbol
                    var parent = getMergedSymbol(symbol.parent);
                    if (ts.some(symbol.declarations, ts.hasStaticModifier)) {
                        getExportsOfSymbol(parent);
                    }
                    else {
                        getMembersOfSymbol(parent);
                    }
                }
                return links.lateSymbol || (links.lateSymbol = symbol);
            }
            return symbol;
        }
        function getTypeWithThisArgument(type, thisArgument, needApparentType) {
            if (ts.getObjectFlags(type) & 4 /* ObjectFlags.Reference */) {
                var target = type.target;
                var typeArguments = getTypeArguments(type);
                if (ts.length(target.typeParameters) === ts.length(typeArguments)) {
                    var ref = createTypeReference(target, ts.concatenate(typeArguments, [thisArgument || target.thisType]));
                    return needApparentType ? getApparentType(ref) : ref;
                }
            }
            else if (type.flags & 2097152 /* TypeFlags.Intersection */) {
                var types = ts.sameMap(type.types, function (t) { return getTypeWithThisArgument(t, thisArgument, needApparentType); });
                return types !== type.types ? getIntersectionType(types) : type;
            }
            return needApparentType ? getApparentType(type) : type;
        }
        function resolveObjectTypeMembers(type, source, typeParameters, typeArguments) {
            var mapper;
            var members;
            var callSignatures;
            var constructSignatures;
            var indexInfos;
            if (ts.rangeEquals(typeParameters, typeArguments, 0, typeParameters.length)) {
                members = source.symbol ? getMembersOfSymbol(source.symbol) : ts.createSymbolTable(source.declaredProperties);
                callSignatures = source.declaredCallSignatures;
                constructSignatures = source.declaredConstructSignatures;
                indexInfos = source.declaredIndexInfos;
            }
            else {
                mapper = createTypeMapper(typeParameters, typeArguments);
                members = createInstantiatedSymbolTable(source.declaredProperties, mapper, /*mappingThisOnly*/ typeParameters.length === 1);
                callSignatures = instantiateSignatures(source.declaredCallSignatures, mapper);
                constructSignatures = instantiateSignatures(source.declaredConstructSignatures, mapper);
                indexInfos = instantiateIndexInfos(source.declaredIndexInfos, mapper);
            }
            var baseTypes = getBaseTypes(source);
            if (baseTypes.length) {
                if (source.symbol && members === getMembersOfSymbol(source.symbol)) {
                    members = ts.createSymbolTable(source.declaredProperties);
                }
                setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
                var thisArgument = ts.lastOrUndefined(typeArguments);
                for (var _i = 0, baseTypes_1 = baseTypes; _i < baseTypes_1.length; _i++) {
                    var baseType = baseTypes_1[_i];
                    var instantiatedBaseType = thisArgument ? getTypeWithThisArgument(instantiateType(baseType, mapper), thisArgument) : baseType;
                    addInheritedMembers(members, getPropertiesOfType(instantiatedBaseType));
                    callSignatures = ts.concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, 0 /* SignatureKind.Call */));
                    constructSignatures = ts.concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, 1 /* SignatureKind.Construct */));
                    var inheritedIndexInfos = instantiatedBaseType !== anyType ? getIndexInfosOfType(instantiatedBaseType) : [createIndexInfo(stringType, anyType, /*isReadonly*/ false)];
                    indexInfos = ts.concatenate(indexInfos, ts.filter(inheritedIndexInfos, function (info) { return !findIndexInfo(indexInfos, info.keyType); }));
                }
            }
            setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
        }
        function resolveClassOrInterfaceMembers(type) {
            resolveObjectTypeMembers(type, resolveDeclaredMembers(type), ts.emptyArray, ts.emptyArray);
        }
        function resolveTypeReferenceMembers(type) {
            var source = resolveDeclaredMembers(type.target);
            var typeParameters = ts.concatenate(source.typeParameters, [source.thisType]);
            var typeArguments = getTypeArguments(type);
            var paddedTypeArguments = typeArguments.length === typeParameters.length ? typeArguments : ts.concatenate(typeArguments, [type]);
            resolveObjectTypeMembers(type, source, typeParameters, paddedTypeArguments);
        }
        function createSignature(declaration, typeParameters, thisParameter, parameters, resolvedReturnType, resolvedTypePredicate, minArgumentCount, flags) {
            var sig = new Signature(checker, flags);
            sig.declaration = declaration;
            sig.typeParameters = typeParameters;
            sig.parameters = parameters;
            sig.thisParameter = thisParameter;
            sig.resolvedReturnType = resolvedReturnType;
            sig.resolvedTypePredicate = resolvedTypePredicate;
            sig.minArgumentCount = minArgumentCount;
            sig.resolvedMinArgumentCount = undefined;
            sig.target = undefined;
            sig.mapper = undefined;
            sig.compositeSignatures = undefined;
            sig.compositeKind = undefined;
            return sig;
        }
        function cloneSignature(sig) {
            var result = createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, /*resolvedReturnType*/ undefined, 
            /*resolvedTypePredicate*/ undefined, sig.minArgumentCount, sig.flags & 39 /* SignatureFlags.PropagatingFlags */);
            result.target = sig.target;
            result.mapper = sig.mapper;
            result.compositeSignatures = sig.compositeSignatures;
            result.compositeKind = sig.compositeKind;
            return result;
        }
        function createUnionSignature(signature, unionSignatures) {
            var result = cloneSignature(signature);
            result.compositeSignatures = unionSignatures;
            result.compositeKind = 1048576 /* TypeFlags.Union */;
            result.target = undefined;
            result.mapper = undefined;
            return result;
        }
        function getOptionalCallSignature(signature, callChainFlags) {
            if ((signature.flags & 24 /* SignatureFlags.CallChainFlags */) === callChainFlags) {
                return signature;
            }
            if (!signature.optionalCallSignatureCache) {
                signature.optionalCallSignatureCache = {};
            }
            var key = callChainFlags === 8 /* SignatureFlags.IsInnerCallChain */ ? "inner" : "outer";
            return signature.optionalCallSignatureCache[key]
                || (signature.optionalCallSignatureCache[key] = createOptionalCallSignature(signature, callChainFlags));
        }
        function createOptionalCallSignature(signature, callChainFlags) {
            ts.Debug.assert(callChainFlags === 8 /* SignatureFlags.IsInnerCallChain */ || callChainFlags === 16 /* SignatureFlags.IsOuterCallChain */, "An optional call signature can either be for an inner call chain or an outer call chain, but not both.");
            var result = cloneSignature(signature);
            result.flags |= callChainFlags;
            return result;
        }
        function getExpandedParameters(sig, skipUnionExpanding) {
            if (signatureHasRestParameter(sig)) {
                var restIndex_1 = sig.parameters.length - 1;
                var restType = getTypeOfSymbol(sig.parameters[restIndex_1]);
                if (isTupleType(restType)) {
                    return [expandSignatureParametersWithTupleMembers(restType, restIndex_1)];
                }
                else if (!skipUnionExpanding && restType.flags & 1048576 /* TypeFlags.Union */ && ts.every(restType.types, isTupleType)) {
                    return ts.map(restType.types, function (t) { return expandSignatureParametersWithTupleMembers(t, restIndex_1); });
                }
            }
            return [sig.parameters];
            function expandSignatureParametersWithTupleMembers(restType, restIndex) {
                var elementTypes = getTypeArguments(restType);
                var associatedNames = restType.target.labeledElementDeclarations;
                var restParams = ts.map(elementTypes, function (t, i) {
                    // Lookup the label from the individual tuple passed in before falling back to the signature `rest` parameter name
                    var tupleLabelName = !!associatedNames && getTupleElementLabel(associatedNames[i]);
                    var name = tupleLabelName || getParameterNameAtPosition(sig, restIndex + i, restType);
                    var flags = restType.target.elementFlags[i];
                    var checkFlags = flags & 12 /* ElementFlags.Variable */ ? 32768 /* CheckFlags.RestParameter */ :
                        flags & 2 /* ElementFlags.Optional */ ? 16384 /* CheckFlags.OptionalParameter */ : 0;
                    var symbol = createSymbol(1 /* SymbolFlags.FunctionScopedVariable */, name, checkFlags);
                    symbol.type = flags & 4 /* ElementFlags.Rest */ ? createArrayType(t) : t;
                    return symbol;
                });
                return ts.concatenate(sig.parameters.slice(0, restIndex), restParams);
            }
        }
        function getDefaultConstructSignatures(classType) {
            var baseConstructorType = getBaseConstructorTypeOfClass(classType);
            var baseSignatures = getSignaturesOfType(baseConstructorType, 1 /* SignatureKind.Construct */);
            var declaration = ts.getClassLikeDeclarationOfSymbol(classType.symbol);
            var isAbstract = !!declaration && ts.hasSyntacticModifier(declaration, 256 /* ModifierFlags.Abstract */);
            if (baseSignatures.length === 0) {
                return [createSignature(undefined, classType.localTypeParameters, undefined, ts.emptyArray, classType, /*resolvedTypePredicate*/ undefined, 0, isAbstract ? 4 /* SignatureFlags.Abstract */ : 0 /* SignatureFlags.None */)];
            }
            var baseTypeNode = getBaseTypeNodeOfClass(classType);
            var isJavaScript = ts.isInJSFile(baseTypeNode);
            var typeArguments = typeArgumentsFromTypeReferenceNode(baseTypeNode);
            var typeArgCount = ts.length(typeArguments);
            var result = [];
            for (var _i = 0, baseSignatures_1 = baseSignatures; _i < baseSignatures_1.length; _i++) {
                var baseSig = baseSignatures_1[_i];
                var minTypeArgumentCount = getMinTypeArgumentCount(baseSig.typeParameters);
                var typeParamCount = ts.length(baseSig.typeParameters);
                if (isJavaScript || typeArgCount >= minTypeArgumentCount && typeArgCount <= typeParamCount) {
                    var sig = typeParamCount ? createSignatureInstantiation(baseSig, fillMissingTypeArguments(typeArguments, baseSig.typeParameters, minTypeArgumentCount, isJavaScript)) : cloneSignature(baseSig);
                    sig.typeParameters = classType.localTypeParameters;
                    sig.resolvedReturnType = classType;
                    sig.flags = isAbstract ? sig.flags | 4 /* SignatureFlags.Abstract */ : sig.flags & ~4 /* SignatureFlags.Abstract */;
                    result.push(sig);
                }
            }
            return result;
        }
        function findMatchingSignature(signatureList, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes) {
            for (var _i = 0, signatureList_1 = signatureList; _i < signatureList_1.length; _i++) {
                var s = signatureList_1[_i];
                if (compareSignaturesIdentical(s, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes, partialMatch ? compareTypesSubtypeOf : compareTypesIdentical)) {
                    return s;
                }
            }
        }
        function findMatchingSignatures(signatureLists, signature, listIndex) {
            if (signature.typeParameters) {
                // We require an exact match for generic signatures, so we only return signatures from the first
                // signature list and only if they have exact matches in the other signature lists.
                if (listIndex > 0) {
                    return undefined;
                }
                for (var i = 1; i < signatureLists.length; i++) {
                    if (!findMatchingSignature(signatureLists[i], signature, /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ false)) {
                        return undefined;
                    }
                }
                return [signature];
            }
            var result;
            for (var i = 0; i < signatureLists.length; i++) {
                // Allow matching non-generic signatures to have excess parameters and different return types.
                // Prefer matching this types if possible.
                var match = i === listIndex ? signature : findMatchingSignature(signatureLists[i], signature, /*partialMatch*/ true, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ true);
                if (!match) {
                    return undefined;
                }
                result = ts.appendIfUnique(result, match);
            }
            return result;
        }
        // The signatures of a union type are those signatures that are present in each of the constituent types.
        // Generic signatures must match exactly, but non-generic signatures are allowed to have extra optional
        // parameters and may differ in return types. When signatures differ in return types, the resulting return
        // type is the union of the constituent return types.
        function getUnionSignatures(signatureLists) {
            var result;
            var indexWithLengthOverOne;
            for (var i = 0; i < signatureLists.length; i++) {
                if (signatureLists[i].length === 0)
                    return ts.emptyArray;
                if (signatureLists[i].length > 1) {
                    indexWithLengthOverOne = indexWithLengthOverOne === undefined ? i : -1; // -1 is a signal there are multiple overload sets
                }
                for (var _i = 0, _a = signatureLists[i]; _i < _a.length; _i++) {
                    var signature = _a[_i];
                    // Only process signatures with parameter lists that aren't already in the result list
                    if (!result || !findMatchingSignature(result, signature, /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ true)) {
                        var unionSignatures = findMatchingSignatures(signatureLists, signature, i);
                        if (unionSignatures) {
                            var s = signature;
                            // Union the result types when more than one signature matches
                            if (unionSignatures.length > 1) {
                                var thisParameter = signature.thisParameter;
                                var firstThisParameterOfUnionSignatures = ts.forEach(unionSignatures, function (sig) { return sig.thisParameter; });
                                if (firstThisParameterOfUnionSignatures) {
                                    var thisType = getIntersectionType(ts.mapDefined(unionSignatures, function (sig) { return sig.thisParameter && getTypeOfSymbol(sig.thisParameter); }));
                                    thisParameter = createSymbolWithType(firstThisParameterOfUnionSignatures, thisType);
                                }
                                s = createUnionSignature(signature, unionSignatures);
                                s.thisParameter = thisParameter;
                            }
                            (result || (result = [])).push(s);
                        }
                    }
                }
            }
            if (!ts.length(result) && indexWithLengthOverOne !== -1) {
                // No sufficiently similar signature existed to subsume all the other signatures in the union - time to see if we can make a single
                // signature that handles all over them. We only do this when there are overloads in only one constituent.
                // (Overloads are conditional in nature and having overloads in multiple constituents would necessitate making a power set of
                // signatures from the type, whose ordering would be non-obvious)
                var masterList = signatureLists[indexWithLengthOverOne !== undefined ? indexWithLengthOverOne : 0];
                var results = masterList.slice();
                var _loop_10 = function (signatures) {
                    if (signatures !== masterList) {
                        var signature_1 = signatures[0];
                        ts.Debug.assert(!!signature_1, "getUnionSignatures bails early on empty signature lists and should not have empty lists on second pass");
                        results = !!signature_1.typeParameters && ts.some(results, function (s) { return !!s.typeParameters && !compareTypeParametersIdentical(signature_1.typeParameters, s.typeParameters); }) ? undefined : ts.map(results, function (sig) { return combineSignaturesOfUnionMembers(sig, signature_1); });
                        if (!results) {
                            return "break";
                        }
                    }
                };
                for (var _b = 0, signatureLists_1 = signatureLists; _b < signatureLists_1.length; _b++) {
                    var signatures = signatureLists_1[_b];
                    var state_3 = _loop_10(signatures);
                    if (state_3 === "break")
                        break;
                }
                result = results;
            }
            return result || ts.emptyArray;
        }
        function compareTypeParametersIdentical(sourceParams, targetParams) {
            if (ts.length(sourceParams) !== ts.length(targetParams)) {
                return false;
            }
            if (!sourceParams || !targetParams) {
                return true;
            }
            var mapper = createTypeMapper(targetParams, sourceParams);
            for (var i = 0; i < sourceParams.length; i++) {
                var source = sourceParams[i];
                var target = targetParams[i];
                if (source === target)
                    continue;
                // We instantiate the target type parameter constraints into the source types so we can recognize `<T, U extends T>` as the same as `<A, B extends A>`
                if (!isTypeIdenticalTo(getConstraintFromTypeParameter(source) || unknownType, instantiateType(getConstraintFromTypeParameter(target) || unknownType, mapper)))
                    return false;
                // We don't compare defaults - we just use the type parameter defaults from the first signature that seems to match.
                // It might make sense to combine these defaults in the future, but doing so intelligently requires knowing
                // if the parameter is used covariantly or contravariantly (so we intersect if it's used like a parameter or union if used like a return type)
                // and, since it's just an inference _default_, just picking one arbitrarily works OK.
            }
            return true;
        }
        function combineUnionThisParam(left, right, mapper) {
            if (!left || !right) {
                return left || right;
            }
            // A signature `this` type might be a read or a write position... It's very possible that it should be invariant
            // and we should refuse to merge signatures if there are `this` types and they do not match. However, so as to be
            // permissive when calling, for now, we'll intersect the `this` types just like we do for param types in union signatures.
            var thisType = getIntersectionType([getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)]);
            return createSymbolWithType(left, thisType);
        }
        function combineUnionParameters(left, right, mapper) {
            var leftCount = getParameterCount(left);
            var rightCount = getParameterCount(right);
            var longest = leftCount >= rightCount ? left : right;
            var shorter = longest === left ? right : left;
            var longestCount = longest === left ? leftCount : rightCount;
            var eitherHasEffectiveRest = (hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right));
            var needsExtraRestElement = eitherHasEffectiveRest && !hasEffectiveRestParameter(longest);
            var params = new Array(longestCount + (needsExtraRestElement ? 1 : 0));
            for (var i = 0; i < longestCount; i++) {
                var longestParamType = tryGetTypeAtPosition(longest, i);
                if (longest === right) {
                    longestParamType = instantiateType(longestParamType, mapper);
                }
                var shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;
                if (shorter === right) {
                    shorterParamType = instantiateType(shorterParamType, mapper);
                }
                var unionParamType = getIntersectionType([longestParamType, shorterParamType]);
                var isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === (longestCount - 1);
                var isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);
                var leftName = i >= leftCount ? undefined : getParameterNameAtPosition(left, i);
                var rightName = i >= rightCount ? undefined : getParameterNameAtPosition(right, i);
                var paramName = leftName === rightName ? leftName :
                    !leftName ? rightName :
                        !rightName ? leftName :
                            undefined;
                var paramSymbol = createSymbol(1 /* SymbolFlags.FunctionScopedVariable */ | (isOptional && !isRestParam ? 16777216 /* SymbolFlags.Optional */ : 0), paramName || "arg".concat(i));
                paramSymbol.type = isRestParam ? createArrayType(unionParamType) : unionParamType;
                params[i] = paramSymbol;
            }
            if (needsExtraRestElement) {
                var restParamSymbol = createSymbol(1 /* SymbolFlags.FunctionScopedVariable */, "args");
                restParamSymbol.type = createArrayType(getTypeAtPosition(shorter, longestCount));
                if (shorter === right) {
                    restParamSymbol.type = instantiateType(restParamSymbol.type, mapper);
                }
                params[longestCount] = restParamSymbol;
            }
            return params;
        }
        function combineSignaturesOfUnionMembers(left, right) {
            var typeParams = left.typeParameters || right.typeParameters;
            var paramMapper;
            if (left.typeParameters && right.typeParameters) {
                paramMapper = createTypeMapper(right.typeParameters, left.typeParameters);
                // We just use the type parameter defaults from the first signature
            }
            var declaration = left.declaration;
            var params = combineUnionParameters(left, right, paramMapper);
            var thisParam = combineUnionThisParam(left.thisParameter, right.thisParameter, paramMapper);
            var minArgCount = Math.max(left.minArgumentCount, right.minArgumentCount);
            var result = createSignature(declaration, typeParams, thisParam, params, 
            /*resolvedReturnType*/ undefined, 
            /*resolvedTypePredicate*/ undefined, minArgCount, (left.flags | right.flags) & 39 /* SignatureFlags.PropagatingFlags */);
            result.compositeKind = 1048576 /* TypeFlags.Union */;
            result.compositeSignatures = ts.concatenate(left.compositeKind !== 2097152 /* TypeFlags.Intersection */ && left.compositeSignatures || [left], [right]);
            if (paramMapper) {
                result.mapper = left.compositeKind !== 2097152 /* TypeFlags.Intersection */ && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper;
            }
            return result;
        }
        function getUnionIndexInfos(types) {
            var sourceInfos = getIndexInfosOfType(types[0]);
            if (sourceInfos) {
                var result = [];
                var _loop_11 = function (info) {
                    var indexType = info.keyType;
                    if (ts.every(types, function (t) { return !!getIndexInfoOfType(t, indexType); })) {
                        result.push(createIndexInfo(indexType, getUnionType(ts.map(types, function (t) { return getIndexTypeOfType(t, indexType); })), ts.some(types, function (t) { return getIndexInfoOfType(t, indexType).isReadonly; })));
                    }
                };
                for (var _i = 0, sourceInfos_1 = sourceInfos; _i < sourceInfos_1.length; _i++) {
                    var info = sourceInfos_1[_i];
                    _loop_11(info);
                }
                return result;
            }
            return ts.emptyArray;
        }
        function resolveUnionTypeMembers(type) {
            // The members and properties collections are empty for union types. To get all properties of a union
            // type use getPropertiesOfType (only the language service uses this).
            var callSignatures = getUnionSignatures(ts.map(type.types, function (t) { return t === globalFunctionType ? [unknownSignature] : getSignaturesOfType(t, 0 /* SignatureKind.Call */); }));
            var constructSignatures = getUnionSignatures(ts.map(type.types, function (t) { return getSignaturesOfType(t, 1 /* SignatureKind.Construct */); }));
            var indexInfos = getUnionIndexInfos(type.types);
            setStructuredTypeMembers(type, emptySymbols, callSignatures, constructSignatures, indexInfos);
        }
        function intersectTypes(type1, type2) {
            return !type1 ? type2 : !type2 ? type1 : getIntersectionType([type1, type2]);
        }
        function findMixins(types) {
            var constructorTypeCount = ts.countWhere(types, function (t) { return getSignaturesOfType(t, 1 /* SignatureKind.Construct */).length > 0; });
            var mixinFlags = ts.map(types, isMixinConstructorType);
            if (constructorTypeCount > 0 && constructorTypeCount === ts.countWhere(mixinFlags, function (b) { return b; })) {
                var firstMixinIndex = mixinFlags.indexOf(/*searchElement*/ true);
                mixinFlags[firstMixinIndex] = false;
            }
            return mixinFlags;
        }
        function includeMixinType(type, types, mixinFlags, index) {
            var mixedTypes = [];
            for (var i = 0; i < types.length; i++) {
                if (i === index) {
                    mixedTypes.push(type);
                }
                else if (mixinFlags[i]) {
                    mixedTypes.push(getReturnTypeOfSignature(getSignaturesOfType(types[i], 1 /* SignatureKind.Construct */)[0]));
                }
            }
            return getIntersectionType(mixedTypes);
        }
        function resolveIntersectionTypeMembers(type) {
            // The members and properties collections are empty for intersection types. To get all properties of an
            // intersection type use getPropertiesOfType (only the language service uses this).
            var callSignatures;
            var constructSignatures;
            var indexInfos;
            var types = type.types;
            var mixinFlags = findMixins(types);
            var mixinCount = ts.countWhere(mixinFlags, function (b) { return b; });
            var _loop_12 = function (i) {
                var t = type.types[i];
                // When an intersection type contains mixin constructor types, the construct signatures from
                // those types are discarded and their return types are mixed into the return types of all
                // other construct signatures in the intersection type. For example, the intersection type
                // '{ new(...args: any[]) => A } & { new(s: string) => B }' has a single construct signature
                // 'new(s: string) => A & B'.
                if (!mixinFlags[i]) {
                    var signatures = getSignaturesOfType(t, 1 /* SignatureKind.Construct */);
                    if (signatures.length && mixinCount > 0) {
                        signatures = ts.map(signatures, function (s) {
                            var clone = cloneSignature(s);
                            clone.resolvedReturnType = includeMixinType(getReturnTypeOfSignature(s), types, mixinFlags, i);
                            return clone;
                        });
                    }
                    constructSignatures = appendSignatures(constructSignatures, signatures);
                }
                callSignatures = appendSignatures(callSignatures, getSignaturesOfType(t, 0 /* SignatureKind.Call */));
                indexInfos = ts.reduceLeft(getIndexInfosOfType(t), function (infos, newInfo) { return appendIndexInfo(infos, newInfo, /*union*/ false); }, indexInfos);
            };
            for (var i = 0; i < types.length; i++) {
                _loop_12(i);
            }
            setStructuredTypeMembers(type, emptySymbols, callSignatures || ts.emptyArray, constructSignatures || ts.emptyArray, indexInfos || ts.emptyArray);
        }
        function appendSignatures(signatures, newSignatures) {
            var _loop_13 = function (sig) {
                if (!signatures || ts.every(signatures, function (s) { return !compareSignaturesIdentical(s, sig, /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ false, compareTypesIdentical); })) {
                    signatures = ts.append(signatures, sig);
                }
            };
            for (var _i = 0, newSignatures_1 = newSignatures; _i < newSignatures_1.length; _i++) {
                var sig = newSignatures_1[_i];
                _loop_13(sig);
            }
            return signatures;
        }
        function appendIndexInfo(indexInfos, newInfo, union) {
            if (indexInfos) {
                for (var i = 0; i < indexInfos.length; i++) {
                    var info = indexInfos[i];
                    if (info.keyType === newInfo.keyType) {
                        indexInfos[i] = createIndexInfo(info.keyType, union ? getUnionType([info.type, newInfo.type]) : getIntersectionType([info.type, newInfo.type]), union ? info.isReadonly || newInfo.isReadonly : info.isReadonly && newInfo.isReadonly);
                        return indexInfos;
                    }
                }
            }
            return ts.append(indexInfos, newInfo);
        }
        /**
         * Converts an AnonymousType to a ResolvedType.
         */
        function resolveAnonymousTypeMembers(type) {
            if (type.target) {
                setStructuredTypeMembers(type, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
                var members_6 = createInstantiatedSymbolTable(getPropertiesOfObjectType(type.target), type.mapper, /*mappingThisOnly*/ false);
                var callSignatures = instantiateSignatures(getSignaturesOfType(type.target, 0 /* SignatureKind.Call */), type.mapper);
                var constructSignatures = instantiateSignatures(getSignaturesOfType(type.target, 1 /* SignatureKind.Construct */), type.mapper);
                var indexInfos_1 = instantiateIndexInfos(getIndexInfosOfType(type.target), type.mapper);
                setStructuredTypeMembers(type, members_6, callSignatures, constructSignatures, indexInfos_1);
                return;
            }
            var symbol = getMergedSymbol(type.symbol);
            if (symbol.flags & 2048 /* SymbolFlags.TypeLiteral */) {
                setStructuredTypeMembers(type, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
                var members_7 = getMembersOfSymbol(symbol);
                var callSignatures = getSignaturesOfSymbol(members_7.get("__call" /* InternalSymbolName.Call */));
                var constructSignatures = getSignaturesOfSymbol(members_7.get("__new" /* InternalSymbolName.New */));
                var indexInfos_2 = getIndexInfosOfSymbol(symbol);
                setStructuredTypeMembers(type, members_7, callSignatures, constructSignatures, indexInfos_2);
                return;
            }
            // Combinations of function, class, enum and module
            var members = emptySymbols;
            var indexInfos;
            if (symbol.exports) {
                members = getExportsOfSymbol(symbol);
                if (symbol === globalThisSymbol) {
                    var varsOnly_1 = new ts.Map();
                    members.forEach(function (p) {
                        var _a;
                        if (!(p.flags & 418 /* SymbolFlags.BlockScoped */) && !(p.flags & 512 /* SymbolFlags.ValueModule */ && ((_a = p.declarations) === null || _a === void 0 ? void 0 : _a.length) && ts.every(p.declarations, ts.isAmbientModule))) {
                            varsOnly_1.set(p.escapedName, p);
                        }
                    });
                    members = varsOnly_1;
                }
            }
            var baseConstructorIndexInfo;
            setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, ts.emptyArray);
            if (symbol.flags & 32 /* SymbolFlags.Class */) {
                var classType = getDeclaredTypeOfClassOrInterface(symbol);
                var baseConstructorType = getBaseConstructorTypeOfClass(classType);
                if (baseConstructorType.flags & (524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */ | 8650752 /* TypeFlags.TypeVariable */)) {
                    members = ts.createSymbolTable(getNamedOrIndexSignatureMembers(members));
                    addInheritedMembers(members, getPropertiesOfType(baseConstructorType));
                }
                else if (baseConstructorType === anyType) {
                    baseConstructorIndexInfo = createIndexInfo(stringType, anyType, /*isReadonly*/ false);
                }
            }
            var indexSymbol = getIndexSymbolFromSymbolTable(members);
            if (indexSymbol) {
                indexInfos = getIndexInfosOfIndexSymbol(indexSymbol);
            }
            else {
                if (baseConstructorIndexInfo) {
                    indexInfos = ts.append(indexInfos, baseConstructorIndexInfo);
                }
                if (symbol.flags & 384 /* SymbolFlags.Enum */ && (getDeclaredTypeOfSymbol(symbol).flags & 32 /* TypeFlags.Enum */ ||
                    ts.some(type.properties, function (prop) { return !!(getTypeOfSymbol(prop).flags & 296 /* TypeFlags.NumberLike */); }))) {
                    indexInfos = ts.append(indexInfos, enumNumberIndexInfo);
                }
            }
            setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, indexInfos || ts.emptyArray);
            // We resolve the members before computing the signatures because a signature may use
            // typeof with a qualified name expression that circularly references the type we are
            // in the process of resolving (see issue #6072). The temporarily empty signature list
            // will never be observed because a qualified name can't reference signatures.
            if (symbol.flags & (16 /* SymbolFlags.Function */ | 8192 /* SymbolFlags.Method */)) {
                type.callSignatures = getSignaturesOfSymbol(symbol);
            }
            // And likewise for construct signatures for classes
            if (symbol.flags & 32 /* SymbolFlags.Class */) {
                var classType_1 = getDeclaredTypeOfClassOrInterface(symbol);
                var constructSignatures = symbol.members ? getSignaturesOfSymbol(symbol.members.get("__constructor" /* InternalSymbolName.Constructor */)) : ts.emptyArray;
                if (symbol.flags & 16 /* SymbolFlags.Function */) {
                    constructSignatures = ts.addRange(constructSignatures.slice(), ts.mapDefined(type.callSignatures, function (sig) { return isJSConstructor(sig.declaration) ?
                        createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, classType_1, /*resolvedTypePredicate*/ undefined, sig.minArgumentCount, sig.flags & 39 /* SignatureFlags.PropagatingFlags */) :
                        undefined; }));
                }
                if (!constructSignatures.length) {
                    constructSignatures = getDefaultConstructSignatures(classType_1);
                }
                type.constructSignatures = constructSignatures;
            }
        }
        function replaceIndexedAccess(instantiable, type, replacement) {
            // map type.indexType to 0
            // map type.objectType to `[TReplacement]`
            // thus making the indexed access `[TReplacement][0]` or `TReplacement`
            return instantiateType(instantiable, createTypeMapper([type.indexType, type.objectType], [getNumberLiteralType(0), createTupleType([replacement])]));
        }
        function resolveReverseMappedTypeMembers(type) {
            var indexInfo = getIndexInfoOfType(type.source, stringType);
            var modifiers = getMappedTypeModifiers(type.mappedType);
            var readonlyMask = modifiers & 1 /* MappedTypeModifiers.IncludeReadonly */ ? false : true;
            var optionalMask = modifiers & 4 /* MappedTypeModifiers.IncludeOptional */ ? 0 : 16777216 /* SymbolFlags.Optional */;
            var indexInfos = indexInfo ? [createIndexInfo(stringType, inferReverseMappedType(indexInfo.type, type.mappedType, type.constraintType), readonlyMask && indexInfo.isReadonly)] : ts.emptyArray;
            var members = ts.createSymbolTable();
            for (var _i = 0, _a = getPropertiesOfType(type.source); _i < _a.length; _i++) {
                var prop = _a[_i];
                var checkFlags = 8192 /* CheckFlags.ReverseMapped */ | (readonlyMask && isReadonlySymbol(prop) ? 8 /* CheckFlags.Readonly */ : 0);
                var inferredProp = createSymbol(4 /* SymbolFlags.Property */ | prop.flags & optionalMask, prop.escapedName, checkFlags);
                inferredProp.declarations = prop.declarations;
                inferredProp.nameType = getSymbolLinks(prop).nameType;
                inferredProp.propertyType = getTypeOfSymbol(prop);
                if (type.constraintType.type.flags & 8388608 /* TypeFlags.IndexedAccess */
                    && type.constraintType.type.objectType.flags & 262144 /* TypeFlags.TypeParameter */
                    && type.constraintType.type.indexType.flags & 262144 /* TypeFlags.TypeParameter */) {
                    // A reverse mapping of `{[K in keyof T[K_1]]: T[K_1]}` is the same as that of `{[K in keyof T]: T}`, since all we care about is
                    // inferring to the "type parameter" (or indexed access) shared by the constraint and template. So, to reduce the number of
                    // type identities produced, we simplify such indexed access occurences
                    var newTypeParam = type.constraintType.type.objectType;
                    var newMappedType = replaceIndexedAccess(type.mappedType, type.constraintType.type, newTypeParam);
                    inferredProp.mappedType = newMappedType;
                    inferredProp.constraintType = getIndexType(newTypeParam);
                }
                else {
                    inferredProp.mappedType = type.mappedType;
                    inferredProp.constraintType = type.constraintType;
                }
                members.set(prop.escapedName, inferredProp);
            }
            setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, indexInfos);
        }
        // Return the lower bound of the key type in a mapped type. Intuitively, the lower
        // bound includes those keys that are known to always be present, for example because
        // because of constraints on type parameters (e.g. 'keyof T' for a constrained T).
        function getLowerBoundOfKeyType(type) {
            if (type.flags & 4194304 /* TypeFlags.Index */) {
                var t = getApparentType(type.type);
                return isGenericTupleType(t) ? getKnownKeysOfTupleType(t) : getIndexType(t);
            }
            if (type.flags & 16777216 /* TypeFlags.Conditional */) {
                if (type.root.isDistributive) {
                    var checkType = type.checkType;
                    var constraint = getLowerBoundOfKeyType(checkType);
                    if (constraint !== checkType) {
                        return getConditionalTypeInstantiation(type, prependTypeMapping(type.root.checkType, constraint, type.mapper));
                    }
                }
                return type;
            }
            if (type.flags & 1048576 /* TypeFlags.Union */) {
                return mapType(type, getLowerBoundOfKeyType);
            }
            if (type.flags & 2097152 /* TypeFlags.Intersection */) {
                // Similarly to getTypeFromIntersectionTypeNode, we preserve the special string & {}, number & {},
                // and bigint & {} intersections that are used to prevent subtype reduction in union types.
                var types = type.types;
                if (types.length === 2 && !!(types[0].flags & (4 /* TypeFlags.String */ | 8 /* TypeFlags.Number */ | 64 /* TypeFlags.BigInt */)) && types[1] === emptyTypeLiteralType) {
                    return type;
                }
                return getIntersectionType(ts.sameMap(type.types, getLowerBoundOfKeyType));
            }
            return type;
        }
        function getIsLateCheckFlag(s) {
            return ts.getCheckFlags(s) & 4096 /* CheckFlags.Late */;
        }
        function forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(type, include, stringsOnly, cb) {
            for (var _i = 0, _a = getPropertiesOfType(type); _i < _a.length; _i++) {
                var prop = _a[_i];
                cb(getLiteralTypeFromProperty(prop, include));
            }
            if (type.flags & 1 /* TypeFlags.Any */) {
                cb(stringType);
            }
            else {
                for (var _b = 0, _c = getIndexInfosOfType(type); _b < _c.length; _b++) {
                    var info = _c[_b];
                    if (!stringsOnly || info.keyType.flags & (4 /* TypeFlags.String */ | 134217728 /* TypeFlags.TemplateLiteral */)) {
                        cb(info.keyType);
                    }
                }
            }
        }
        /** Resolve the members of a mapped type { [P in K]: T } */
        function resolveMappedTypeMembers(type) {
            var members = ts.createSymbolTable();
            var indexInfos;
            // Resolve upfront such that recursive references see an empty object type.
            setStructuredTypeMembers(type, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
            // In { [P in K]: T }, we refer to P as the type parameter type, K as the constraint type,
            // and T as the template type.
            var typeParameter = getTypeParameterFromMappedType(type);
            var constraintType = getConstraintTypeFromMappedType(type);
            var nameType = getNameTypeFromMappedType(type.target || type);
            var templateType = getTemplateTypeFromMappedType(type.target || type);
            var modifiersType = getApparentType(getModifiersTypeFromMappedType(type)); // The 'T' in 'keyof T'
            var templateModifiers = getMappedTypeModifiers(type);
            var include = keyofStringsOnly ? 128 /* TypeFlags.StringLiteral */ : 8576 /* TypeFlags.StringOrNumberLiteralOrUnique */;
            if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
                // We have a { [P in keyof T]: X }
                forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, include, keyofStringsOnly, addMemberForKeyType);
            }
            else {
                forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType);
            }
            setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, indexInfos || ts.emptyArray);
            function addMemberForKeyType(keyType) {
                var propNameType = nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType;
                forEachType(propNameType, function (t) { return addMemberForKeyTypeWorker(keyType, t); });
            }
            function addMemberForKeyTypeWorker(keyType, propNameType) {
                // If the current iteration type constituent is a string literal type, create a property.
                // Otherwise, for type string create a string index signature.
                if (isTypeUsableAsPropertyName(propNameType)) {
                    var propName = getPropertyNameFromType(propNameType);
                    // String enum members from separate enums with identical values
                    // are distinct types with the same property name. Make the resulting
                    // property symbol's name type be the union of those enum member types.
                    var existingProp = members.get(propName);
                    if (existingProp) {
                        existingProp.nameType = getUnionType([existingProp.nameType, propNameType]);
                        existingProp.keyType = getUnionType([existingProp.keyType, keyType]);
                    }
                    else {
                        var modifiersProp = isTypeUsableAsPropertyName(keyType) ? getPropertyOfType(modifiersType, getPropertyNameFromType(keyType)) : undefined;
                        var isOptional = !!(templateModifiers & 4 /* MappedTypeModifiers.IncludeOptional */ ||
                            !(templateModifiers & 8 /* MappedTypeModifiers.ExcludeOptional */) && modifiersProp && modifiersProp.flags & 16777216 /* SymbolFlags.Optional */);
                        var isReadonly = !!(templateModifiers & 1 /* MappedTypeModifiers.IncludeReadonly */ ||
                            !(templateModifiers & 2 /* MappedTypeModifiers.ExcludeReadonly */) && modifiersProp && isReadonlySymbol(modifiersProp));
                        var stripOptional = strictNullChecks && !isOptional && modifiersProp && modifiersProp.flags & 16777216 /* SymbolFlags.Optional */;
                        var lateFlag = modifiersProp ? getIsLateCheckFlag(modifiersProp) : 0;
                        var prop = createSymbol(4 /* SymbolFlags.Property */ | (isOptional ? 16777216 /* SymbolFlags.Optional */ : 0), propName, lateFlag | 262144 /* CheckFlags.Mapped */ | (isReadonly ? 8 /* CheckFlags.Readonly */ : 0) | (stripOptional ? 524288 /* CheckFlags.StripOptional */ : 0));
                        prop.mappedType = type;
                        prop.nameType = propNameType;
                        prop.keyType = keyType;
                        if (modifiersProp) {
                            prop.syntheticOrigin = modifiersProp;
                            // If the mapped type has an `as XXX` clause, the property name likely won't match the declaration name and
                            // multiple properties may map to the same name. Thus, we attach no declarations to the symbol.
                            prop.declarations = nameType ? undefined : modifiersProp.declarations;
                        }
                        members.set(propName, prop);
                    }
                }
                else if (isValidIndexKeyType(propNameType) || propNameType.flags & (1 /* TypeFlags.Any */ | 32 /* TypeFlags.Enum */)) {
                    var indexKeyType = propNameType.flags & (1 /* TypeFlags.Any */ | 4 /* TypeFlags.String */) ? stringType :
                        propNameType.flags & (8 /* TypeFlags.Number */ | 32 /* TypeFlags.Enum */) ? numberType :
                            propNameType;
                    var propType = instantiateType(templateType, appendTypeMapping(type.mapper, typeParameter, keyType));
                    var indexInfo = createIndexInfo(indexKeyType, propType, !!(templateModifiers & 1 /* MappedTypeModifiers.IncludeReadonly */));
                    indexInfos = appendIndexInfo(indexInfos, indexInfo, /*union*/ true);
                }
            }
        }
        function getTypeOfMappedSymbol(symbol) {
            if (!symbol.type) {
                var mappedType = symbol.mappedType;
                if (!pushTypeResolution(symbol, 0 /* TypeSystemPropertyName.Type */)) {
                    mappedType.containsError = true;
                    return errorType;
                }
                var templateType = getTemplateTypeFromMappedType(mappedType.target || mappedType);
                var mapper = appendTypeMapping(mappedType.mapper, getTypeParameterFromMappedType(mappedType), symbol.keyType);
                var propType = instantiateType(templateType, mapper);
                // When creating an optional property in strictNullChecks mode, if 'undefined' isn't assignable to the
                // type, we include 'undefined' in the type. Similarly, when creating a non-optional property in strictNullChecks
                // mode, if the underlying property is optional we remove 'undefined' from the type.
                var type = strictNullChecks && symbol.flags & 16777216 /* SymbolFlags.Optional */ && !maybeTypeOfKind(propType, 32768 /* TypeFlags.Undefined */ | 16384 /* TypeFlags.Void */) ? getOptionalType(propType, /*isProperty*/ true) :
                    symbol.checkFlags & 524288 /* CheckFlags.StripOptional */ ? removeMissingOrUndefinedType(propType) :
                        propType;
                if (!popTypeResolution()) {
                    error(currentNode, ts.Diagnostics.Type_of_property_0_circularly_references_itself_in_mapped_type_1, symbolToString(symbol), typeToString(mappedType));
                    type = errorType;
                }
                symbol.type = type;
            }
            return symbol.type;
        }
        function getTypeParameterFromMappedType(type) {
            return type.typeParameter ||
                (type.typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfNode(type.declaration.typeParameter)));
        }
        function getConstraintTypeFromMappedType(type) {
            return type.constraintType ||
                (type.constraintType = getConstraintOfTypeParameter(getTypeParameterFromMappedType(type)) || errorType);
        }
        function getNameTypeFromMappedType(type) {
            return type.declaration.nameType ?
                type.nameType || (type.nameType = instantiateType(getTypeFromTypeNode(type.declaration.nameType), type.mapper)) :
                undefined;
        }
        function getTemplateTypeFromMappedType(type) {
            return type.templateType ||
                (type.templateType = type.declaration.type ?
                    instantiateType(addOptionality(getTypeFromTypeNode(type.declaration.type), /*isProperty*/ true, !!(getMappedTypeModifiers(type) & 4 /* MappedTypeModifiers.IncludeOptional */)), type.mapper) :
                    errorType);
        }
        function getConstraintDeclarationForMappedType(type) {
            return ts.getEffectiveConstraintOfTypeParameter(type.declaration.typeParameter);
        }
        function isMappedTypeWithKeyofConstraintDeclaration(type) {
            var constraintDeclaration = getConstraintDeclarationForMappedType(type); // TODO: GH#18217
            return constraintDeclaration.kind === 195 /* SyntaxKind.TypeOperator */ &&
                constraintDeclaration.operator === 141 /* SyntaxKind.KeyOfKeyword */;
        }
        function getModifiersTypeFromMappedType(type) {
            if (!type.modifiersType) {
                if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
                    // If the constraint declaration is a 'keyof T' node, the modifiers type is T. We check
                    // AST nodes here because, when T is a non-generic type, the logic below eagerly resolves
                    // 'keyof T' to a literal union type and we can't recover T from that type.
                    type.modifiersType = instantiateType(getTypeFromTypeNode(getConstraintDeclarationForMappedType(type).type), type.mapper);
                }
                else {
                    // Otherwise, get the declared constraint type, and if the constraint type is a type parameter,
                    // get the constraint of that type parameter. If the resulting type is an indexed type 'keyof T',
                    // the modifiers type is T. Otherwise, the modifiers type is unknown.
                    var declaredType = getTypeFromMappedTypeNode(type.declaration);
                    var constraint = getConstraintTypeFromMappedType(declaredType);
                    var extendedConstraint = constraint && constraint.flags & 262144 /* TypeFlags.TypeParameter */ ? getConstraintOfTypeParameter(constraint) : constraint;
                    type.modifiersType = extendedConstraint && extendedConstraint.flags & 4194304 /* TypeFlags.Index */ ? instantiateType(extendedConstraint.type, type.mapper) : unknownType;
                }
            }
            return type.modifiersType;
        }
        function getMappedTypeModifiers(type) {
            var declaration = type.declaration;
            return (declaration.readonlyToken ? declaration.readonlyToken.kind === 40 /* SyntaxKind.MinusToken */ ? 2 /* MappedTypeModifiers.ExcludeReadonly */ : 1 /* MappedTypeModifiers.IncludeReadonly */ : 0) |
                (declaration.questionToken ? declaration.questionToken.kind === 40 /* SyntaxKind.MinusToken */ ? 8 /* MappedTypeModifiers.ExcludeOptional */ : 4 /* MappedTypeModifiers.IncludeOptional */ : 0);
        }
        function getMappedTypeOptionality(type) {
            var modifiers = getMappedTypeModifiers(type);
            return modifiers & 8 /* MappedTypeModifiers.ExcludeOptional */ ? -1 : modifiers & 4 /* MappedTypeModifiers.IncludeOptional */ ? 1 : 0;
        }
        function getCombinedMappedTypeOptionality(type) {
            var optionality = getMappedTypeOptionality(type);
            var modifiersType = getModifiersTypeFromMappedType(type);
            return optionality || (isGenericMappedType(modifiersType) ? getMappedTypeOptionality(modifiersType) : 0);
        }
        function isPartialMappedType(type) {
            return !!(ts.getObjectFlags(type) & 32 /* ObjectFlags.Mapped */ && getMappedTypeModifiers(type) & 4 /* MappedTypeModifiers.IncludeOptional */);
        }
        function isGenericMappedType(type) {
            if (ts.getObjectFlags(type) & 32 /* ObjectFlags.Mapped */) {
                var constraint = getConstraintTypeFromMappedType(type);
                if (isGenericIndexType(constraint)) {
                    return true;
                }
                // A mapped type is generic if the 'as' clause references generic types other than the iteration type.
                // To determine this, we substitute the constraint type (that we now know isn't generic) for the iteration
                // type and check whether the resulting type is generic.
                var nameType = getNameTypeFromMappedType(type);
                if (nameType && isGenericIndexType(instantiateType(nameType, makeUnaryTypeMapper(getTypeParameterFromMappedType(type), constraint)))) {
                    return true;
                }
            }
            return false;
        }
        function resolveStructuredTypeMembers(type) {
            if (!type.members) {
                if (type.flags & 524288 /* TypeFlags.Object */) {
                    if (type.objectFlags & 4 /* ObjectFlags.Reference */) {
                        resolveTypeReferenceMembers(type);
                    }
                    else if (type.objectFlags & 3 /* ObjectFlags.ClassOrInterface */) {
                        resolveClassOrInterfaceMembers(type);
                    }
                    else if (type.objectFlags & 1024 /* ObjectFlags.ReverseMapped */) {
                        resolveReverseMappedTypeMembers(type);
                    }
                    else if (type.objectFlags & 16 /* ObjectFlags.Anonymous */) {
                        resolveAnonymousTypeMembers(type);
                    }
                    else if (type.objectFlags & 32 /* ObjectFlags.Mapped */) {
                        resolveMappedTypeMembers(type);
                    }
                    else {
                        ts.Debug.fail("Unhandled object type " + ts.Debug.formatObjectFlags(type.objectFlags));
                    }
                }
                else if (type.flags & 1048576 /* TypeFlags.Union */) {
                    resolveUnionTypeMembers(type);
                }
                else if (type.flags & 2097152 /* TypeFlags.Intersection */) {
                    resolveIntersectionTypeMembers(type);
                }
                else {
                    ts.Debug.fail("Unhandled type " + ts.Debug.formatTypeFlags(type.flags));
                }
            }
            return type;
        }
        /** Return properties of an object type or an empty array for other types */
        function getPropertiesOfObjectType(type) {
            if (type.flags & 524288 /* TypeFlags.Object */) {
                return resolveStructuredTypeMembers(type).properties;
            }
            return ts.emptyArray;
        }
        /** If the given type is an object type and that type has a property by the given name,
         * return the symbol for that property. Otherwise return undefined.
         */
        function getPropertyOfObjectType(type, name) {
            if (type.flags & 524288 /* TypeFlags.Object */) {
                var resolved = resolveStructuredTypeMembers(type);
                var symbol = resolved.members.get(name);
                if (symbol && symbolIsValue(symbol)) {
                    return symbol;
                }
            }
        }
        function getPropertiesOfUnionOrIntersectionType(type) {
            if (!type.resolvedProperties) {
                var members = ts.createSymbolTable();
                for (var _i = 0, _a = type.types; _i < _a.length; _i++) {
                    var current = _a[_i];
                    for (var _b = 0, _c = getPropertiesOfType(current); _b < _c.length; _b++) {
                        var prop = _c[_b];
                        if (!members.has(prop.escapedName)) {
                            var combinedProp = getPropertyOfUnionOrIntersectionType(type, prop.escapedName);
                            if (combinedProp) {
                                members.set(prop.escapedName, combinedProp);
                            }
                        }
                    }
                    // The properties of a union type are those that are present in all constituent types, so
                    // we only need to check the properties of the first type without index signature
                    if (type.flags & 1048576 /* TypeFlags.Union */ && getIndexInfosOfType(current).length === 0) {
                        break;
                    }
                }
                type.resolvedProperties = getNamedMembers(members);
            }
            return type.resolvedProperties;
        }
        function getPropertiesOfType(type) {
            type = getReducedApparentType(type);
            return type.flags & 3145728 /* TypeFlags.UnionOrIntersection */ ?
                getPropertiesOfUnionOrIntersectionType(type) :
                getPropertiesOfObjectType(type);
        }
        function forEachPropertyOfType(type, action) {
            type = getReducedApparentType(type);
            if (type.flags & 3670016 /* TypeFlags.StructuredType */) {
                resolveStructuredTypeMembers(type).members.forEach(function (symbol, escapedName) {
                    if (isNamedMember(symbol, escapedName)) {
                        action(symbol, escapedName);
                    }
                });
            }
        }
        function isTypeInvalidDueToUnionDiscriminant(contextualType, obj) {
            var list = obj.properties;
            return list.some(function (property) {
                var nameType = property.name && getLiteralTypeFromPropertyName(property.name);
                var name = nameType && isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined;
                var expected = name === undefined ? undefined : getTypeOfPropertyOfType(contextualType, name);
                return !!expected && isLiteralType(expected) && !isTypeAssignableTo(getTypeOfNode(property), expected);
            });
        }
        function getAllPossiblePropertiesOfTypes(types) {
            var unionType = getUnionType(types);
            if (!(unionType.flags & 1048576 /* TypeFlags.Union */)) {
                return getAugmentedPropertiesOfType(unionType);
            }
            var props = ts.createSymbolTable();
            for (var _i = 0, types_4 = types; _i < types_4.length; _i++) {
                var memberType = types_4[_i];
                for (var _a = 0, _b = getAugmentedPropertiesOfType(memberType); _a < _b.length; _a++) {
                    var escapedName = _b[_a].escapedName;
                    if (!props.has(escapedName)) {
                        var prop = createUnionOrIntersectionProperty(unionType, escapedName);
                        // May be undefined if the property is private
                        if (prop)
                            props.set(escapedName, prop);
                    }
                }
            }
            return ts.arrayFrom(props.values());
        }
        function getConstraintOfType(type) {
            return type.flags & 262144 /* TypeFlags.TypeParameter */ ? getConstraintOfTypeParameter(type) :
                type.flags & 8388608 /* TypeFlags.IndexedAccess */ ? getConstraintOfIndexedAccess(type) :
                    type.flags & 16777216 /* TypeFlags.Conditional */ ? getConstraintOfConditionalType(type) :
                        getBaseConstraintOfType(type);
        }
        function getConstraintOfTypeParameter(typeParameter) {
            return hasNonCircularBaseConstraint(typeParameter) ? getConstraintFromTypeParameter(typeParameter) : undefined;
        }
        function getConstraintOfIndexedAccess(type) {
            return hasNonCircularBaseConstraint(type) ? getConstraintFromIndexedAccess(type) : undefined;
        }
        function getSimplifiedTypeOrConstraint(type) {
            var simplified = getSimplifiedType(type, /*writing*/ false);
            return simplified !== type ? simplified : getConstraintOfType(type);
        }
        function getConstraintFromIndexedAccess(type) {
            if (isMappedTypeGenericIndexedAccess(type)) {
                // For indexed access types of the form { [P in K]: E }[X], where K is non-generic and X is generic,
                // we substitute an instantiation of E where P is replaced with X.
                return substituteIndexedMappedType(type.objectType, type.indexType);
            }
            var indexConstraint = getSimplifiedTypeOrConstraint(type.indexType);
            if (indexConstraint && indexConstraint !== type.indexType) {
                var indexedAccess = getIndexedAccessTypeOrUndefined(type.objectType, indexConstraint, type.accessFlags);
                if (indexedAccess) {
                    return indexedAccess;
                }
            }
            var objectConstraint = getSimplifiedTypeOrConstraint(type.objectType);
            if (objectConstraint && objectConstraint !== type.objectType) {
                return getIndexedAccessTypeOrUndefined(objectConstraint, type.indexType, type.accessFlags);
            }
            return undefined;
        }
        function getDefaultConstraintOfConditionalType(type) {
            if (!type.resolvedDefaultConstraint) {
                // An `any` branch of a conditional type would normally be viral - specifically, without special handling here,
                // a conditional type with a single branch of type `any` would be assignable to anything, since it's constraint would simplify to
                // just `any`. This result is _usually_ unwanted - so instead here we elide an `any` branch from the constraint type,
                // in effect treating `any` like `never` rather than `unknown` in this location.
                var trueConstraint = getInferredTrueTypeFromConditionalType(type);
                var falseConstraint = getFalseTypeFromConditionalType(type);
                type.resolvedDefaultConstraint = isTypeAny(trueConstraint) ? falseConstraint : isTypeAny(falseConstraint) ? trueConstraint : getUnionType([trueConstraint, falseConstraint]);
            }
            return type.resolvedDefaultConstraint;
        }
        function getConstraintOfDistributiveConditionalType(type) {
            // Check if we have a conditional type of the form 'T extends U ? X : Y', where T is a constrained
            // type parameter. If so, create an instantiation of the conditional type where T is replaced
            // with its constraint. We do this because if the constraint is a union type it will be distributed
            // over the conditional type and possibly reduced. For example, 'T extends undefined ? never : T'
            // removes 'undefined' from T.
            // We skip returning a distributive constraint for a restrictive instantiation of a conditional type
            // as the constraint for all type params (check type included) have been replace with `unknown`, which
            // is going to produce even more false positive/negative results than the distribute constraint already does.
            // Please note: the distributive constraint is a kludge for emulating what a negated type could to do filter
            // a union - once negated types exist and are applied to the conditional false branch, this "constraint"
            // likely doesn't need to exist.
            if (type.root.isDistributive && type.restrictiveInstantiation !== type) {
                var simplified = getSimplifiedType(type.checkType, /*writing*/ false);
                var constraint = simplified === type.checkType ? getConstraintOfType(simplified) : simplified;
                if (constraint && constraint !== type.checkType) {
                    var instantiated = getConditionalTypeInstantiation(type, prependTypeMapping(type.root.checkType, constraint, type.mapper));
                    if (!(instantiated.flags & 131072 /* TypeFlags.Never */)) {
                        return instantiated;
                    }
                }
            }
            return undefined;
        }
        function getConstraintFromConditionalType(type) {
            return getConstraintOfDistributiveConditionalType(type) || getDefaultConstraintOfConditionalType(type);
        }
        function getConstraintOfConditionalType(type) {
            return hasNonCircularBaseConstraint(type) ? getConstraintFromConditionalType(type) : undefined;
        }
        function getEffectiveConstraintOfIntersection(types, targetIsUnion) {
            var constraints;
            var hasDisjointDomainType = false;
            for (var _i = 0, types_5 = types; _i < types_5.length; _i++) {
                var t = types_5[_i];
                if (t.flags & 465829888 /* TypeFlags.Instantiable */) {
                    // We keep following constraints as long as we have an instantiable type that is known
                    // not to be circular or infinite (hence we stop on index access types).
                    var constraint = getConstraintOfType(t);
                    while (constraint && constraint.flags & (262144 /* TypeFlags.TypeParameter */ | 4194304 /* TypeFlags.Index */ | 16777216 /* TypeFlags.Conditional */)) {
                        constraint = getConstraintOfType(constraint);
                    }
                    if (constraint) {
                        constraints = ts.append(constraints, constraint);
                        if (targetIsUnion) {
                            constraints = ts.append(constraints, t);
                        }
                    }
                }
                else if (t.flags & 469892092 /* TypeFlags.DisjointDomains */ || isEmptyAnonymousObjectType(t)) {
                    hasDisjointDomainType = true;
                }
            }
            // If the target is a union type or if we are intersecting with types belonging to one of the
            // disjoint domains, we may end up producing a constraint that hasn't been examined before.
            if (constraints && (targetIsUnion || hasDisjointDomainType)) {
                if (hasDisjointDomainType) {
                    // We add any types belong to one of the disjoint domains because they might cause the final
                    // intersection operation to reduce the union constraints.
                    for (var _a = 0, types_6 = types; _a < types_6.length; _a++) {
                        var t = types_6[_a];
                        if (t.flags & 469892092 /* TypeFlags.DisjointDomains */ || isEmptyAnonymousObjectType(t)) {
                            constraints = ts.append(constraints, t);
                        }
                    }
                }
                // The source types were normalized; ensure the result is normalized too.
                return getNormalizedType(getIntersectionType(constraints), /*writing*/ false);
            }
            return undefined;
        }
        function getBaseConstraintOfType(type) {
            if (type.flags & (58982400 /* TypeFlags.InstantiableNonPrimitive */ | 3145728 /* TypeFlags.UnionOrIntersection */ | 134217728 /* TypeFlags.TemplateLiteral */ | 268435456 /* TypeFlags.StringMapping */)) {
                var constraint = getResolvedBaseConstraint(type);
                return constraint !== noConstraintType && constraint !== circularConstraintType ? constraint : undefined;
            }
            return type.flags & 4194304 /* TypeFlags.Index */ ? keyofConstraintType : undefined;
        }
        /**
         * This is similar to `getBaseConstraintOfType` except it returns the input type if there's no base constraint, instead of `undefined`
         * It also doesn't map indexes to `string`, as where this is used this would be unneeded (and likely undesirable)
         */
        function getBaseConstraintOrType(type) {
            return getBaseConstraintOfType(type) || type;
        }
        function hasNonCircularBaseConstraint(type) {
            return getResolvedBaseConstraint(type) !== circularConstraintType;
        }
        /**
         * Return the resolved base constraint of a type variable. The noConstraintType singleton is returned if the
         * type variable has no constraint, and the circularConstraintType singleton is returned if the constraint
         * circularly references the type variable.
         */
        function getResolvedBaseConstraint(type) {
            if (type.resolvedBaseConstraint) {
                return type.resolvedBaseConstraint;
            }
            var stack = [];
            return type.resolvedBaseConstraint = getTypeWithThisArgument(getImmediateBaseConstraint(type), type);
            function getImmediateBaseConstraint(t) {
                if (!t.immediateBaseConstraint) {
                    if (!pushTypeResolution(t, 4 /* TypeSystemPropertyName.ImmediateBaseConstraint */)) {
                        return circularConstraintType;
                    }
                    var result = void 0;
                    // We always explore at least 10 levels of nested constraints. Thereafter, we continue to explore
                    // up to 50 levels of nested constraints provided there are no "deeply nested" types on the stack
                    // (i.e. no types for which five instantiations have been recorded on the stack). If we reach 50
                    // levels of nesting, we are presumably exploring a repeating pattern with a long cycle that hasn't
                    // yet triggered the deeply nested limiter. We have no test cases that actually get to 50 levels of
                    // nesting, so it is effectively just a safety stop.
                    var identity_1 = getRecursionIdentity(t);
                    if (stack.length < 10 || stack.length < 50 && !ts.contains(stack, identity_1)) {
                        stack.push(identity_1);
                        result = computeBaseConstraint(getSimplifiedType(t, /*writing*/ false));
                        stack.pop();
                    }
                    if (!popTypeResolution()) {
                        if (t.flags & 262144 /* TypeFlags.TypeParameter */) {
                            var errorNode = getConstraintDeclaration(t);
                            if (errorNode) {
                                var diagnostic = error(errorNode, ts.Diagnostics.Type_parameter_0_has_a_circular_constraint, typeToString(t));
                                if (currentNode && !ts.isNodeDescendantOf(errorNode, currentNode) && !ts.isNodeDescendantOf(currentNode, errorNode)) {
                                    ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(currentNode, ts.Diagnostics.Circularity_originates_in_type_at_this_location));
                                }
                            }
                        }
                        result = circularConstraintType;
                    }
                    t.immediateBaseConstraint = result || noConstraintType;
                }
                return t.immediateBaseConstraint;
            }
            function getBaseConstraint(t) {
                var c = getImmediateBaseConstraint(t);
                return c !== noConstraintType && c !== circularConstraintType ? c : undefined;
            }
            function computeBaseConstraint(t) {
                if (t.flags & 262144 /* TypeFlags.TypeParameter */) {
                    var constraint = getConstraintFromTypeParameter(t);
                    return t.isThisType || !constraint ?
                        constraint :
                        getBaseConstraint(constraint);
                }
                if (t.flags & 3145728 /* TypeFlags.UnionOrIntersection */) {
                    var types = t.types;
                    var baseTypes = [];
                    var different = false;
                    for (var _i = 0, types_7 = types; _i < types_7.length; _i++) {
                        var type_3 = types_7[_i];
                        var baseType = getBaseConstraint(type_3);
                        if (baseType) {
                            if (baseType !== type_3) {
                                different = true;
                            }
                            baseTypes.push(baseType);
                        }
                        else {
                            different = true;
                        }
                    }
                    if (!different) {
                        return t;
                    }
                    return t.flags & 1048576 /* TypeFlags.Union */ && baseTypes.length === types.length ? getUnionType(baseTypes) :
                        t.flags & 2097152 /* TypeFlags.Intersection */ && baseTypes.length ? getIntersectionType(baseTypes) :
                            undefined;
                }
                if (t.flags & 4194304 /* TypeFlags.Index */) {
                    return keyofConstraintType;
                }
                if (t.flags & 134217728 /* TypeFlags.TemplateLiteral */) {
                    var types = t.types;
                    var constraints = ts.mapDefined(types, getBaseConstraint);
                    return constraints.length === types.length ? getTemplateLiteralType(t.texts, constraints) : stringType;
                }
                if (t.flags & 268435456 /* TypeFlags.StringMapping */) {
                    var constraint = getBaseConstraint(t.type);
                    return constraint && constraint !== t.type ? getStringMappingType(t.symbol, constraint) : stringType;
                }
                if (t.flags & 8388608 /* TypeFlags.IndexedAccess */) {
                    if (isMappedTypeGenericIndexedAccess(t)) {
                        // For indexed access types of the form { [P in K]: E }[X], where K is non-generic and X is generic,
                        // we substitute an instantiation of E where P is replaced with X.
                        return getBaseConstraint(substituteIndexedMappedType(t.objectType, t.indexType));
                    }
                    var baseObjectType = getBaseConstraint(t.objectType);
                    var baseIndexType = getBaseConstraint(t.indexType);
                    var baseIndexedAccess = baseObjectType && baseIndexType && getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, t.accessFlags);
                    return baseIndexedAccess && getBaseConstraint(baseIndexedAccess);
                }
                if (t.flags & 16777216 /* TypeFlags.Conditional */) {
                    var constraint = getConstraintFromConditionalType(t);
                    return constraint && getBaseConstraint(constraint);
                }
                if (t.flags & 33554432 /* TypeFlags.Substitution */) {
                    return getBaseConstraint(getSubstitutionIntersection(t));
                }
                return t;
            }
        }
        function getApparentTypeOfIntersectionType(type) {
            return type.resolvedApparentType || (type.resolvedApparentType = getTypeWithThisArgument(type, type, /*apparentType*/ true));
        }
        function getResolvedTypeParameterDefault(typeParameter) {
            if (!typeParameter.default) {
                if (typeParameter.target) {
                    var targetDefault = getResolvedTypeParameterDefault(typeParameter.target);
                    typeParameter.default = targetDefault ? instantiateType(targetDefault, typeParameter.mapper) : noConstraintType;
                }
                else {
                    // To block recursion, set the initial value to the resolvingDefaultType.
                    typeParameter.default = resolvingDefaultType;
                    var defaultDeclaration = typeParameter.symbol && ts.forEach(typeParameter.symbol.declarations, function (decl) { return ts.isTypeParameterDeclaration(decl) && decl.default; });
                    var defaultType = defaultDeclaration ? getTypeFromTypeNode(defaultDeclaration) : noConstraintType;
                    if (typeParameter.default === resolvingDefaultType) {
                        // If we have not been called recursively, set the correct default type.
                        typeParameter.default = defaultType;
                    }
                }
            }
            else if (typeParameter.default === resolvingDefaultType) {
                // If we are called recursively for this type parameter, mark the default as circular.
                typeParameter.default = circularConstraintType;
            }
            return typeParameter.default;
        }
        /**
         * Gets the default type for a type parameter.
         *
         * If the type parameter is the result of an instantiation, this gets the instantiated
         * default type of its target. If the type parameter has no default type or the default is
         * circular, `undefined` is returned.
         */
        function getDefaultFromTypeParameter(typeParameter) {
            var defaultType = getResolvedTypeParameterDefault(typeParameter);
            return defaultType !== noConstraintType && defaultType !== circularConstraintType ? defaultType : undefined;
        }
        function hasNonCircularTypeParameterDefault(typeParameter) {
            return getResolvedTypeParameterDefault(typeParameter) !== circularConstraintType;
        }
        /**
         * Indicates whether the declaration of a typeParameter has a default type.
         */
        function hasTypeParameterDefault(typeParameter) {
            return !!(typeParameter.symbol && ts.forEach(typeParameter.symbol.declarations, function (decl) { return ts.isTypeParameterDeclaration(decl) && decl.default; }));
        }
        function getApparentTypeOfMappedType(type) {
            return type.resolvedApparentType || (type.resolvedApparentType = getResolvedApparentTypeOfMappedType(type));
        }
        function getResolvedApparentTypeOfMappedType(type) {
            var typeVariable = getHomomorphicTypeVariable(type);
            if (typeVariable && !type.declaration.nameType) {
                var constraint = getConstraintOfTypeParameter(typeVariable);
                if (constraint && isArrayOrTupleType(constraint)) {
                    return instantiateType(type, prependTypeMapping(typeVariable, constraint, type.mapper));
                }
            }
            return type;
        }
        function isMappedTypeGenericIndexedAccess(type) {
            var objectType;
            return !!(type.flags & 8388608 /* TypeFlags.IndexedAccess */ && ts.getObjectFlags(objectType = type.objectType) & 32 /* ObjectFlags.Mapped */ &&
                !isGenericMappedType(objectType) && isGenericIndexType(type.indexType) &&
                !(getMappedTypeModifiers(objectType) & 8 /* MappedTypeModifiers.ExcludeOptional */) && !objectType.declaration.nameType);
        }
        /**
         * For a type parameter, return the base constraint of the type parameter. For the string, number,
         * boolean, and symbol primitive types, return the corresponding object types. Otherwise return the
         * type itself.
         */
        function getApparentType(type) {
            var t = !(type.flags & 465829888 /* TypeFlags.Instantiable */) ? type : getBaseConstraintOfType(type) || unknownType;
            return ts.getObjectFlags(t) & 32 /* ObjectFlags.Mapped */ ? getApparentTypeOfMappedType(t) :
                t.flags & 2097152 /* TypeFlags.Intersection */ ? getApparentTypeOfIntersectionType(t) :
                    t.flags & 402653316 /* TypeFlags.StringLike */ ? globalStringType :
                        t.flags & 296 /* TypeFlags.NumberLike */ ? globalNumberType :
                            t.flags & 2112 /* TypeFlags.BigIntLike */ ? getGlobalBigIntType() :
                                t.flags & 528 /* TypeFlags.BooleanLike */ ? globalBooleanType :
                                    t.flags & 12288 /* TypeFlags.ESSymbolLike */ ? getGlobalESSymbolType() :
                                        t.flags & 67108864 /* TypeFlags.NonPrimitive */ ? emptyObjectType :
                                            t.flags & 4194304 /* TypeFlags.Index */ ? keyofConstraintType :
                                                t.flags & 2 /* TypeFlags.Unknown */ && !strictNullChecks ? emptyObjectType :
                                                    t;
        }
        function getReducedApparentType(type) {
            // Since getApparentType may return a non-reduced union or intersection type, we need to perform
            // type reduction both before and after obtaining the apparent type. For example, given a type parameter
            // 'T extends A | B', the type 'T & X' becomes 'A & X | B & X' after obtaining the apparent type, and
            // that type may need further reduction to remove empty intersections.
            return getReducedType(getApparentType(getReducedType(type)));
        }
        function createUnionOrIntersectionProperty(containingType, name, skipObjectFunctionPropertyAugment) {
            var _a, _b;
            var singleProp;
            var propSet;
            var indexTypes;
            var isUnion = containingType.flags & 1048576 /* TypeFlags.Union */;
            // Flags we want to propagate to the result if they exist in all source symbols
            var optionalFlag;
            var syntheticFlag = 4 /* CheckFlags.SyntheticMethod */;
            var checkFlags = isUnion ? 0 : 8 /* CheckFlags.Readonly */;
            var mergedInstantiations = false;
            for (var _i = 0, _c = containingType.types; _i < _c.length; _i++) {
                var current = _c[_i];
                var type = getApparentType(current);
                if (!(isErrorType(type) || type.flags & 131072 /* TypeFlags.Never */)) {
                    var prop = getPropertyOfType(type, name, skipObjectFunctionPropertyAugment);
                    var modifiers = prop ? ts.getDeclarationModifierFlagsFromSymbol(prop) : 0;
                    if (prop) {
                        if (prop.flags & 106500 /* SymbolFlags.ClassMember */) {
                            optionalFlag !== null && optionalFlag !== void 0 ? optionalFlag : (optionalFlag = isUnion ? 0 /* SymbolFlags.None */ : 16777216 /* SymbolFlags.Optional */);
                            if (isUnion) {
                                optionalFlag |= (prop.flags & 16777216 /* SymbolFlags.Optional */);
                            }
                            else {
                                optionalFlag &= prop.flags;
                            }
                        }
                        if (!singleProp) {
                            singleProp = prop;
                        }
                        else if (prop !== singleProp) {
                            var isInstantiation = (getTargetSymbol(prop) || prop) === (getTargetSymbol(singleProp) || singleProp);
                            // If the symbols are instances of one another with identical types - consider the symbols
                            // equivalent and just use the first one, which thus allows us to avoid eliding private
                            // members when intersecting a (this-)instantiations of a class with its raw base or another instance
                            if (isInstantiation && compareProperties(singleProp, prop, function (a, b) { return a === b ? -1 /* Ternary.True */ : 0 /* Ternary.False */; }) === -1 /* Ternary.True */) {
                                // If we merged instantiations of a generic type, we replicate the symbol parent resetting behavior we used
                                // to do when we recorded multiple distinct symbols so that we still get, eg, `Array<T>.length` printed
                                // back and not `Array<string>.length` when we're looking at a `.length` access on a `string[] | number[]`
                                mergedInstantiations = !!singleProp.parent && !!ts.length(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(singleProp.parent));
                            }
                            else {
                                if (!propSet) {
                                    propSet = new ts.Map();
                                    propSet.set(getSymbolId(singleProp), singleProp);
                                }
                                var id = getSymbolId(prop);
                                if (!propSet.has(id)) {
                                    propSet.set(id, prop);
                                }
                            }
                        }
                        if (isUnion && isReadonlySymbol(prop)) {
                            checkFlags |= 8 /* CheckFlags.Readonly */;
                        }
                        else if (!isUnion && !isReadonlySymbol(prop)) {
                            checkFlags &= ~8 /* CheckFlags.Readonly */;
                        }
                        checkFlags |= (!(modifiers & 24 /* ModifierFlags.NonPublicAccessibilityModifier */) ? 256 /* CheckFlags.ContainsPublic */ : 0) |
                            (modifiers & 16 /* ModifierFlags.Protected */ ? 512 /* CheckFlags.ContainsProtected */ : 0) |
                            (modifiers & 8 /* ModifierFlags.Private */ ? 1024 /* CheckFlags.ContainsPrivate */ : 0) |
                            (modifiers & 32 /* ModifierFlags.Static */ ? 2048 /* CheckFlags.ContainsStatic */ : 0);
                        if (!isPrototypeProperty(prop)) {
                            syntheticFlag = 2 /* CheckFlags.SyntheticProperty */;
                        }
                    }
                    else if (isUnion) {
                        var indexInfo = !isLateBoundName(name) && getApplicableIndexInfoForName(type, name);
                        if (indexInfo) {
                            checkFlags |= 32 /* CheckFlags.WritePartial */ | (indexInfo.isReadonly ? 8 /* CheckFlags.Readonly */ : 0);
                            indexTypes = ts.append(indexTypes, isTupleType(type) ? getRestTypeOfTupleType(type) || undefinedType : indexInfo.type);
                        }
                        else if (isObjectLiteralType(type) && !(ts.getObjectFlags(type) & 2097152 /* ObjectFlags.ContainsSpread */)) {
                            checkFlags |= 32 /* CheckFlags.WritePartial */;
                            indexTypes = ts.append(indexTypes, undefinedType);
                        }
                        else {
                            checkFlags |= 16 /* CheckFlags.ReadPartial */;
                        }
                    }
                }
            }
            if (!singleProp ||
                isUnion &&
                    (propSet || checkFlags & 48 /* CheckFlags.Partial */) &&
                    checkFlags & (1024 /* CheckFlags.ContainsPrivate */ | 512 /* CheckFlags.ContainsProtected */) &&
                    !(propSet && getCommonDeclarationsOfSymbols(ts.arrayFrom(propSet.values())))) {
                // No property was found, or, in a union, a property has a private or protected declaration in one
                // constituent, but is missing or has a different declaration in another constituent.
                return undefined;
            }
            if (!propSet && !(checkFlags & 16 /* CheckFlags.ReadPartial */) && !indexTypes) {
                if (mergedInstantiations) {
                    // No symbol from a union/intersection should have a `.parent` set (since unions/intersections don't act as symbol parents)
                    // Unless that parent is "reconstituted" from the "first value declaration" on the symbol (which is likely different than its instantiated parent!)
                    // They also have a `.containingType` set, which affects some services endpoints behavior, like `getRootSymbol`
                    var clone_1 = createSymbolWithType(singleProp, singleProp.type);
                    clone_1.parent = (_b = (_a = singleProp.valueDeclaration) === null || _a === void 0 ? void 0 : _a.symbol) === null || _b === void 0 ? void 0 : _b.parent;
                    clone_1.containingType = containingType;
                    clone_1.mapper = singleProp.mapper;
                    return clone_1;
                }
                else {
                    return singleProp;
                }
            }
            var props = propSet ? ts.arrayFrom(propSet.values()) : [singleProp];
            var declarations;
            var firstType;
            var nameType;
            var propTypes = [];
            var writeTypes;
            var firstValueDeclaration;
            var hasNonUniformValueDeclaration = false;
            for (var _d = 0, props_1 = props; _d < props_1.length; _d++) {
                var prop = props_1[_d];
                if (!firstValueDeclaration) {
                    firstValueDeclaration = prop.valueDeclaration;
                }
                else if (prop.valueDeclaration && prop.valueDeclaration !== firstValueDeclaration) {
                    hasNonUniformValueDeclaration = true;
                }
                declarations = ts.addRange(declarations, prop.declarations);
                var type = getTypeOfSymbol(prop);
                if (!firstType) {
                    firstType = type;
                    nameType = getSymbolLinks(prop).nameType;
                }
                var writeType = getWriteTypeOfSymbol(prop);
                if (writeTypes || writeType !== type) {
                    writeTypes = ts.append(!writeTypes ? propTypes.slice() : writeTypes, writeType);
                }
                else if (type !== firstType) {
                    checkFlags |= 64 /* CheckFlags.HasNonUniformType */;
                }
                if (isLiteralType(type) || isPatternLiteralType(type) || type === uniqueLiteralType) {
                    checkFlags |= 128 /* CheckFlags.HasLiteralType */;
                }
                if (type.flags & 131072 /* TypeFlags.Never */ && type !== uniqueLiteralType) {
                    checkFlags |= 131072 /* CheckFlags.HasNeverType */;
                }
                propTypes.push(type);
            }
            ts.addRange(propTypes, indexTypes);
            var result = createSymbol(4 /* SymbolFlags.Property */ | (optionalFlag !== null && optionalFlag !== void 0 ? optionalFlag : 0), name, syntheticFlag | checkFlags);
            result.containingType = containingType;
            if (!hasNonUniformValueDeclaration && firstValueDeclaration) {
                result.valueDeclaration = firstValueDeclaration;
                // Inherit information about parent type.
                if (firstValueDeclaration.symbol.parent) {
                    result.parent = firstValueDeclaration.symbol.parent;
                }
            }
            result.declarations = declarations;
            result.nameType = nameType;
            if (propTypes.length > 2) {
                // When `propTypes` has the potential to explode in size when normalized, defer normalization until absolutely needed
                result.checkFlags |= 65536 /* CheckFlags.DeferredType */;
                result.deferralParent = containingType;
                result.deferralConstituents = propTypes;
                result.deferralWriteConstituents = writeTypes;
            }
            else {
                result.type = isUnion ? getUnionType(propTypes) : getIntersectionType(propTypes);
                if (writeTypes) {
                    result.writeType = isUnion ? getUnionType(writeTypes) : getIntersectionType(writeTypes);
                }
            }
            return result;
        }
        // Return the symbol for a given property in a union or intersection type, or undefined if the property
        // does not exist in any constituent type. Note that the returned property may only be present in some
        // constituents, in which case the isPartial flag is set when the containing type is union type. We need
        // these partial properties when identifying discriminant properties, but otherwise they are filtered out
        // and do not appear to be present in the union type.
        function getUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment) {
            var _a, _b;
            var property = ((_a = type.propertyCacheWithoutObjectFunctionPropertyAugment) === null || _a === void 0 ? void 0 : _a.get(name)) ||
                !skipObjectFunctionPropertyAugment ? (_b = type.propertyCache) === null || _b === void 0 ? void 0 : _b.get(name) : undefined;
            if (!property) {
                property = createUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment);
                if (property) {
                    var properties = skipObjectFunctionPropertyAugment ? type.propertyCacheWithoutObjectFunctionPropertyAugment || (type.propertyCacheWithoutObjectFunctionPropertyAugment = ts.createSymbolTable()) : type.propertyCache || (type.propertyCache = ts.createSymbolTable());
                    properties.set(name, property);
                }
            }
            return property;
        }
        function getCommonDeclarationsOfSymbols(symbols) {
            var commonDeclarations;
            var _loop_14 = function (symbol) {
                if (!symbol.declarations) {
                    return { value: undefined };
                }
                if (!commonDeclarations) {
                    commonDeclarations = new ts.Set(symbol.declarations);
                    return "continue";
                }
                commonDeclarations.forEach(function (declaration) {
                    if (!ts.contains(symbol.declarations, declaration)) {
                        commonDeclarations.delete(declaration);
                    }
                });
                if (commonDeclarations.size === 0) {
                    return { value: undefined };
                }
            };
            for (var _i = 0, symbols_3 = symbols; _i < symbols_3.length; _i++) {
                var symbol = symbols_3[_i];
                var state_4 = _loop_14(symbol);
                if (typeof state_4 === "object")
                    return state_4.value;
            }
            return commonDeclarations;
        }
        function getPropertyOfUnionOrIntersectionType(type, name, skipObjectFunctionPropertyAugment) {
            var property = getUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment);
            // We need to filter out partial properties in union types
            return property && !(ts.getCheckFlags(property) & 16 /* CheckFlags.ReadPartial */) ? property : undefined;
        }
        /**
         * Return the reduced form of the given type. For a union type, it is a union of the normalized constituent types.
         * For an intersection of types containing one or more mututally exclusive discriminant properties, it is 'never'.
         * For all other types, it is simply the type itself. Discriminant properties are considered mutually exclusive when
         * no constituent property has type 'never', but the intersection of the constituent property types is 'never'.
         */
        function getReducedType(type) {
            if (type.flags & 1048576 /* TypeFlags.Union */ && type.objectFlags & 16777216 /* ObjectFlags.ContainsIntersections */) {
                return type.resolvedReducedType || (type.resolvedReducedType = getReducedUnionType(type));
            }
            else if (type.flags & 2097152 /* TypeFlags.Intersection */) {
                if (!(type.objectFlags & 16777216 /* ObjectFlags.IsNeverIntersectionComputed */)) {
                    type.objectFlags |= 16777216 /* ObjectFlags.IsNeverIntersectionComputed */ |
                        (ts.some(getPropertiesOfUnionOrIntersectionType(type), isNeverReducedProperty) ? 33554432 /* ObjectFlags.IsNeverIntersection */ : 0);
                }
                return type.objectFlags & 33554432 /* ObjectFlags.IsNeverIntersection */ ? neverType : type;
            }
            return type;
        }
        function getReducedUnionType(unionType) {
            var reducedTypes = ts.sameMap(unionType.types, getReducedType);
            if (reducedTypes === unionType.types) {
                return unionType;
            }
            var reduced = getUnionType(reducedTypes);
            if (reduced.flags & 1048576 /* TypeFlags.Union */) {
                reduced.resolvedReducedType = reduced;
            }
            return reduced;
        }
        function isNeverReducedProperty(prop) {
            return isDiscriminantWithNeverType(prop) || isConflictingPrivateProperty(prop);
        }
        function isDiscriminantWithNeverType(prop) {
            // Return true for a synthetic non-optional property with non-uniform types, where at least one is
            // a literal type and none is never, that reduces to never.
            return !(prop.flags & 16777216 /* SymbolFlags.Optional */) &&
                (ts.getCheckFlags(prop) & (192 /* CheckFlags.Discriminant */ | 131072 /* CheckFlags.HasNeverType */)) === 192 /* CheckFlags.Discriminant */ &&
                !!(getTypeOfSymbol(prop).flags & 131072 /* TypeFlags.Never */);
        }
        function isConflictingPrivateProperty(prop) {
            // Return true for a synthetic property with multiple declarations, at least one of which is private.
            return !prop.valueDeclaration && !!(ts.getCheckFlags(prop) & 1024 /* CheckFlags.ContainsPrivate */);
        }
        function elaborateNeverIntersection(errorInfo, type) {
            if (type.flags & 2097152 /* TypeFlags.Intersection */ && ts.getObjectFlags(type) & 33554432 /* ObjectFlags.IsNeverIntersection */) {
                var neverProp = ts.find(getPropertiesOfUnionOrIntersectionType(type), isDiscriminantWithNeverType);
                if (neverProp) {
                    return ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents, typeToString(type, /*enclosingDeclaration*/ undefined, 536870912 /* TypeFormatFlags.NoTypeReduction */), symbolToString(neverProp));
                }
                var privateProp = ts.find(getPropertiesOfUnionOrIntersectionType(type), isConflictingPrivateProperty);
                if (privateProp) {
                    return ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some, typeToString(type, /*enclosingDeclaration*/ undefined, 536870912 /* TypeFormatFlags.NoTypeReduction */), symbolToString(privateProp));
                }
            }
            return errorInfo;
        }
        /**
         * Return the symbol for the property with the given name in the given type. Creates synthetic union properties when
         * necessary, maps primitive types and type parameters are to their apparent types, and augments with properties from
         * Object and Function as appropriate.
         *
         * @param type a type to look up property from
         * @param name a name of property to look up in a given type
         */
        function getPropertyOfType(type, name, skipObjectFunctionPropertyAugment, includeTypeOnlyMembers) {
            type = getReducedApparentType(type);
            if (type.flags & 524288 /* TypeFlags.Object */) {
                var resolved = resolveStructuredTypeMembers(type);
                var symbol = resolved.members.get(name);
                if (symbol && symbolIsValue(symbol, includeTypeOnlyMembers)) {
                    return symbol;
                }
                if (skipObjectFunctionPropertyAugment)
                    return undefined;
                var functionType = resolved === anyFunctionType ? globalFunctionType :
                    resolved.callSignatures.length ? globalCallableFunctionType :
                        resolved.constructSignatures.length ? globalNewableFunctionType :
                            undefined;
                if (functionType) {
                    var symbol_1 = getPropertyOfObjectType(functionType, name);
                    if (symbol_1) {
                        return symbol_1;
                    }
                }
                return getPropertyOfObjectType(globalObjectType, name);
            }
            if (type.flags & 3145728 /* TypeFlags.UnionOrIntersection */) {
                return getPropertyOfUnionOrIntersectionType(type, name, skipObjectFunctionPropertyAugment);
            }
            return undefined;
        }
        function getSignaturesOfStructuredType(type, kind) {
            if (type.flags & 3670016 /* TypeFlags.StructuredType */) {
                var resolved = resolveStructuredTypeMembers(type);
                return kind === 0 /* SignatureKind.Call */ ? resolved.callSignatures : resolved.constructSignatures;
            }
            return ts.emptyArray;
        }
        /**
         * Return the signatures of the given kind in the given type. Creates synthetic union signatures when necessary and
         * maps primitive types and type parameters are to their apparent types.
         */
        function getSignaturesOfType(type, kind) {
            return getSignaturesOfStructuredType(getReducedApparentType(type), kind);
        }
        function findIndexInfo(indexInfos, keyType) {
            return ts.find(indexInfos, function (info) { return info.keyType === keyType; });
        }
        function findApplicableIndexInfo(indexInfos, keyType) {
            // Index signatures for type 'string' are considered only when no other index signatures apply.
            var stringIndexInfo;
            var applicableInfo;
            var applicableInfos;
            for (var _i = 0, indexInfos_3 = indexInfos; _i < indexInfos_3.length; _i++) {
                var info = indexInfos_3[_i];
                if (info.keyType === stringType) {
                    stringIndexInfo = info;
                }
                else if (isApplicableIndexType(keyType, info.keyType)) {
                    if (!applicableInfo) {
                        applicableInfo = info;
                    }
                    else {
                        (applicableInfos || (applicableInfos = [applicableInfo])).push(info);
                    }
                }
            }
            // When more than one index signature is applicable we create a synthetic IndexInfo. Instead of computing
            // the intersected key type, we just use unknownType for the key type as nothing actually depends on the
            // keyType property of the returned IndexInfo.
            return applicableInfos ? createIndexInfo(unknownType, getIntersectionType(ts.map(applicableInfos, function (info) { return info.type; })), ts.reduceLeft(applicableInfos, function (isReadonly, info) { return isReadonly && info.isReadonly; }, /*initial*/ true)) :
                applicableInfo ? applicableInfo :
                    stringIndexInfo && isApplicableIndexType(keyType, stringType) ? stringIndexInfo :
                        undefined;
        }
        function isApplicableIndexType(source, target) {
            // A 'string' index signature applies to types assignable to 'string' or 'number', and a 'number' index
            // signature applies to types assignable to 'number', `${number}` and numeric string literal types.
            return isTypeAssignableTo(source, target) ||
                target === stringType && isTypeAssignableTo(source, numberType) ||
                target === numberType && (source === numericStringType || !!(source.flags & 128 /* TypeFlags.StringLiteral */) && ts.isNumericLiteralName(source.value));
        }
        function getIndexInfosOfStructuredType(type) {
            if (type.flags & 3670016 /* TypeFlags.StructuredType */) {
                var resolved = resolveStructuredTypeMembers(type);
                return resolved.indexInfos;
            }
            return ts.emptyArray;
        }
        function getIndexInfosOfType(type) {
            return getIndexInfosOfStructuredType(getReducedApparentType(type));
        }
        // Return the indexing info of the given kind in the given type. Creates synthetic union index types when necessary and
        // maps primitive types and type parameters are to their apparent types.
        function getIndexInfoOfType(type, keyType) {
            return findIndexInfo(getIndexInfosOfType(type), keyType);
        }
        // Return the index type of the given kind in the given type. Creates synthetic union index types when necessary and
        // maps primitive types and type parameters are to their apparent types.
        function getIndexTypeOfType(type, keyType) {
            var _a;
            return (_a = getIndexInfoOfType(type, keyType)) === null || _a === void 0 ? void 0 : _a.type;
        }
        function getApplicableIndexInfos(type, keyType) {
            return getIndexInfosOfType(type).filter(function (info) { return isApplicableIndexType(keyType, info.keyType); });
        }
        function getApplicableIndexInfo(type, keyType) {
            return findApplicableIndexInfo(getIndexInfosOfType(type), keyType);
        }
        function getApplicableIndexInfoForName(type, name) {
            return getApplicableIndexInfo(type, isLateBoundName(name) ? esSymbolType : getStringLiteralType(ts.unescapeLeadingUnderscores(name)));
        }
        // Return list of type parameters with duplicates removed (duplicate identifier errors are generated in the actual
        // type checking functions).
        function getTypeParametersFromDeclaration(declaration) {
            var _a;
            var result;
            for (var _i = 0, _b = ts.getEffectiveTypeParameterDeclarations(declaration); _i < _b.length; _i++) {
                var node = _b[_i];
                result = ts.appendIfUnique(result, getDeclaredTypeOfTypeParameter(node.symbol));
            }
            return (result === null || result === void 0 ? void 0 : result.length) ? result
                : ts.isFunctionDeclaration(declaration) ? (_a = getSignatureOfTypeTag(declaration)) === null || _a === void 0 ? void 0 : _a.typeParameters
                    : undefined;
        }
        function symbolsToArray(symbols) {
            var result = [];
            symbols.forEach(function (symbol, id) {
                if (!isReservedMemberName(id)) {
                    result.push(symbol);
                }
            });
            return result;
        }
        function isJSDocOptionalParameter(node) {
            return ts.isInJSFile(node) && (
            // node.type should only be a JSDocOptionalType when node is a parameter of a JSDocFunctionType
            node.type && node.type.kind === 319 /* SyntaxKind.JSDocOptionalType */
                || ts.getJSDocParameterTags(node).some(function (_a) {
                    var isBracketed = _a.isBracketed, typeExpression = _a.typeExpression;
                    return isBracketed || !!typeExpression && typeExpression.type.kind === 319 /* SyntaxKind.JSDocOptionalType */;
                }));
        }
        function tryFindAmbientModule(moduleName, withAugmentations) {
            if (ts.isExternalModuleNameRelative(moduleName)) {
                return undefined;
            }
            var symbol = getSymbol(globals, '"' + moduleName + '"', 512 /* SymbolFlags.ValueModule */);
            // merged symbol is module declaration symbol combined with all augmentations
            return symbol && withAugmentations ? getMergedSymbol(symbol) : symbol;
        }
        function isOptionalParameter(node) {
            if (ts.hasQuestionToken(node) || isOptionalJSDocPropertyLikeTag(node) || isJSDocOptionalParameter(node)) {
                return true;
            }
            if (node.initializer) {
                var signature = getSignatureFromDeclaration(node.parent);
                var parameterIndex = node.parent.parameters.indexOf(node);
                ts.Debug.assert(parameterIndex >= 0);
                // Only consider syntactic or instantiated parameters as optional, not `void` parameters as this function is used
                // in grammar checks and checking for `void` too early results in parameter types widening too early
                // and causes some noImplicitAny errors to be lost.
                return parameterIndex >= getMinArgumentCount(signature, 1 /* MinArgumentCountFlags.StrongArityForUntypedJS */ | 2 /* MinArgumentCountFlags.VoidIsNonOptional */);
            }
            var iife = ts.getImmediatelyInvokedFunctionExpression(node.parent);
            if (iife) {
                return !node.type &&
                    !node.dotDotDotToken &&
                    node.parent.parameters.indexOf(node) >= iife.arguments.length;
            }
            return false;
        }
        function isOptionalPropertyDeclaration(node) {
            return ts.isPropertyDeclaration(node) && !ts.hasAccessorModifier(node) && node.questionToken;
        }
        function isOptionalJSDocPropertyLikeTag(node) {
            if (!ts.isJSDocPropertyLikeTag(node)) {
                return false;
            }
            var isBracketed = node.isBracketed, typeExpression = node.typeExpression;
            return isBracketed || !!typeExpression && typeExpression.type.kind === 319 /* SyntaxKind.JSDocOptionalType */;
        }
        function createTypePredicate(kind, parameterName, parameterIndex, type) {
            return { kind: kind, parameterName: parameterName, parameterIndex: parameterIndex, type: type };
        }
        /**
         * Gets the minimum number of type arguments needed to satisfy all non-optional type
         * parameters.
         */
        function getMinTypeArgumentCount(typeParameters) {
            var minTypeArgumentCount = 0;
            if (typeParameters) {
                for (var i = 0; i < typeParameters.length; i++) {
                    if (!hasTypeParameterDefault(typeParameters[i])) {
                        minTypeArgumentCount = i + 1;
                    }
                }
            }
            return minTypeArgumentCount;
        }
        function fillMissingTypeArguments(typeArguments, typeParameters, minTypeArgumentCount, isJavaScriptImplicitAny) {
            var numTypeParameters = ts.length(typeParameters);
            if (!numTypeParameters) {
                return [];
            }
            var numTypeArguments = ts.length(typeArguments);
            if (isJavaScriptImplicitAny || (numTypeArguments >= minTypeArgumentCount && numTypeArguments <= numTypeParameters)) {
                var result = typeArguments ? typeArguments.slice() : [];
                // Map invalid forward references in default types to the error type
                for (var i = numTypeArguments; i < numTypeParameters; i++) {
                    result[i] = errorType;
                }
                var baseDefaultType = getDefaultTypeArgumentType(isJavaScriptImplicitAny);
                for (var i = numTypeArguments; i < numTypeParameters; i++) {
                    var defaultType = getDefaultFromTypeParameter(typeParameters[i]);
                    if (isJavaScriptImplicitAny && defaultType && (isTypeIdenticalTo(defaultType, unknownType) || isTypeIdenticalTo(defaultType, emptyObjectType))) {
                        defaultType = anyType;
                    }
                    result[i] = defaultType ? instantiateType(defaultType, createTypeMapper(typeParameters, result)) : baseDefaultType;
                }
                result.length = typeParameters.length;
                return result;
            }
            return typeArguments && typeArguments.slice();
        }
        function getSignatureFromDeclaration(declaration) {
            var links = getNodeLinks(declaration);
            if (!links.resolvedSignature) {
                var parameters = [];
                var flags = 0 /* SignatureFlags.None */;
                var minArgumentCount = 0;
                var thisParameter = void 0;
                var hasThisParameter = false;
                var iife = ts.getImmediatelyInvokedFunctionExpression(declaration);
                var isJSConstructSignature = ts.isJSDocConstructSignature(declaration);
                var isUntypedSignatureInJSFile = !iife &&
                    ts.isInJSFile(declaration) &&
                    ts.isValueSignatureDeclaration(declaration) &&
                    !ts.hasJSDocParameterTags(declaration) &&
                    !ts.getJSDocType(declaration);
                if (isUntypedSignatureInJSFile) {
                    flags |= 32 /* SignatureFlags.IsUntypedSignatureInJSFile */;
                }
                // If this is a JSDoc construct signature, then skip the first parameter in the
                // parameter list.  The first parameter represents the return type of the construct
                // signature.
                for (var i = isJSConstructSignature ? 1 : 0; i < declaration.parameters.length; i++) {
                    var param = declaration.parameters[i];
                    var paramSymbol = param.symbol;
                    var type = ts.isJSDocParameterTag(param) ? (param.typeExpression && param.typeExpression.type) : param.type;
                    // Include parameter symbol instead of property symbol in the signature
                    if (paramSymbol && !!(paramSymbol.flags & 4 /* SymbolFlags.Property */) && !ts.isBindingPattern(param.name)) {
                        var resolvedSymbol = resolveName(param, paramSymbol.escapedName, 111551 /* SymbolFlags.Value */, undefined, undefined, /*isUse*/ false);
                        paramSymbol = resolvedSymbol;
                    }
                    if (i === 0 && paramSymbol.escapedName === "this" /* InternalSymbolName.This */) {
                        hasThisParameter = true;
                        thisParameter = param.symbol;
                    }
                    else {
                        parameters.push(paramSymbol);
                    }
                    if (type && type.kind === 198 /* SyntaxKind.LiteralType */) {
                        flags |= 2 /* SignatureFlags.HasLiteralTypes */;
                    }
                    // Record a new minimum argument count if this is not an optional parameter
                    var isOptionalParameter_1 = isOptionalJSDocPropertyLikeTag(param) ||
                        param.initializer || param.questionToken || ts.isRestParameter(param) ||
                        iife && parameters.length > iife.arguments.length && !type ||
                        isJSDocOptionalParameter(param);
                    if (!isOptionalParameter_1) {
                        minArgumentCount = parameters.length;
                    }
                }
                // If only one accessor includes a this-type annotation, the other behaves as if it had the same type annotation
                if ((declaration.kind === 174 /* SyntaxKind.GetAccessor */ || declaration.kind === 175 /* SyntaxKind.SetAccessor */) &&
                    hasBindableName(declaration) &&
                    (!hasThisParameter || !thisParameter)) {
                    var otherKind = declaration.kind === 174 /* SyntaxKind.GetAccessor */ ? 175 /* SyntaxKind.SetAccessor */ : 174 /* SyntaxKind.GetAccessor */;
                    var other = ts.getDeclarationOfKind(getSymbolOfNode(declaration), otherKind);
                    if (other) {
                        thisParameter = getAnnotatedAccessorThisParameter(other);
                    }
                }
                var classType = declaration.kind === 173 /* SyntaxKind.Constructor */ ?
                    getDeclaredTypeOfClassOrInterface(getMergedSymbol(declaration.parent.symbol))
                    : undefined;
                var typeParameters = classType ? classType.localTypeParameters : getTypeParametersFromDeclaration(declaration);
                if (ts.hasRestParameter(declaration) || ts.isInJSFile(declaration) && maybeAddJsSyntheticRestParameter(declaration, parameters)) {
                    flags |= 1 /* SignatureFlags.HasRestParameter */;
                }
                if (ts.isConstructorTypeNode(declaration) && ts.hasSyntacticModifier(declaration, 256 /* ModifierFlags.Abstract */) ||
                    ts.isConstructorDeclaration(declaration) && ts.hasSyntacticModifier(declaration.parent, 256 /* ModifierFlags.Abstract */)) {
                    flags |= 4 /* SignatureFlags.Abstract */;
                }
                links.resolvedSignature = createSignature(declaration, typeParameters, thisParameter, parameters, 
                /*resolvedReturnType*/ undefined, /*resolvedTypePredicate*/ undefined, minArgumentCount, flags);
            }
            return links.resolvedSignature;
        }
        /**
         * A JS function gets a synthetic rest parameter if it references `arguments` AND:
         * 1. It has no parameters but at least one `@param` with a type that starts with `...`
         * OR
         * 2. It has at least one parameter, and the last parameter has a matching `@param` with a type that starts with `...`
         */
        function maybeAddJsSyntheticRestParameter(declaration, parameters) {
            if (ts.isJSDocSignature(declaration) || !containsArgumentsReference(declaration)) {
                return false;
            }
            var lastParam = ts.lastOrUndefined(declaration.parameters);
            var lastParamTags = lastParam ? ts.getJSDocParameterTags(lastParam) : ts.getJSDocTags(declaration).filter(ts.isJSDocParameterTag);
            var lastParamVariadicType = ts.firstDefined(lastParamTags, function (p) {
                return p.typeExpression && ts.isJSDocVariadicType(p.typeExpression.type) ? p.typeExpression.type : undefined;
            });
            var syntheticArgsSymbol = createSymbol(3 /* SymbolFlags.Variable */, "args", 32768 /* CheckFlags.RestParameter */);
            if (lastParamVariadicType) {
                // Parameter has effective annotation, lock in type
                syntheticArgsSymbol.type = createArrayType(getTypeFromTypeNode(lastParamVariadicType.type));
            }
            else {
                // Parameter has no annotation
                // By using a `DeferredType` symbol, we allow the type of this rest arg to be overriden by contextual type assignment so long as its type hasn't been
                // cached by `getTypeOfSymbol` yet.
                syntheticArgsSymbol.checkFlags |= 65536 /* CheckFlags.DeferredType */;
                syntheticArgsSymbol.deferralParent = neverType;
                syntheticArgsSymbol.deferralConstituents = [anyArrayType];
                syntheticArgsSymbol.deferralWriteConstituents = [anyArrayType];
            }
            if (lastParamVariadicType) {
                // Replace the last parameter with a rest parameter.
                parameters.pop();
            }
            parameters.push(syntheticArgsSymbol);
            return true;
        }
        function getSignatureOfTypeTag(node) {
            // should be attached to a function declaration or expression
            if (!(ts.isInJSFile(node) && ts.isFunctionLikeDeclaration(node)))
                return undefined;
            var typeTag = ts.getJSDocTypeTag(node);
            return (typeTag === null || typeTag === void 0 ? void 0 : typeTag.typeExpression) && getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression));
        }
        function getParameterTypeOfTypeTag(func, parameter) {
            var signature = getSignatureOfTypeTag(func);
            if (!signature)
                return undefined;
            var pos = func.parameters.indexOf(parameter);
            return parameter.dotDotDotToken ? getRestTypeAtPosition(signature, pos) : getTypeAtPosition(signature, pos);
        }
        function getReturnTypeOfTypeTag(node) {
            var signature = getSignatureOfTypeTag(node);
            return signature && getReturnTypeOfSignature(signature);
        }
        function containsArgumentsReference(declaration) {
            var links = getNodeLinks(declaration);
            if (links.containsArgumentsReference === undefined) {
                if (links.flags & 8192 /* NodeCheckFlags.CaptureArguments */) {
                    links.containsArgumentsReference = true;
                }
                else {
                    links.containsArgumentsReference = traverse(declaration.body);
                }
            }
            return links.containsArgumentsReference;
            function traverse(node) {
                if (!node)
                    return false;
                switch (node.kind) {
                    case 79 /* SyntaxKind.Identifier */:
                        return node.escapedText === argumentsSymbol.escapedName && getReferencedValueSymbol(node) === argumentsSymbol;
                    case 169 /* SyntaxKind.PropertyDeclaration */:
                    case 171 /* SyntaxKind.MethodDeclaration */:
                    case 174 /* SyntaxKind.GetAccessor */:
                    case 175 /* SyntaxKind.SetAccessor */:
                        return node.name.kind === 164 /* SyntaxKind.ComputedPropertyName */
                            && traverse(node.name);
                    case 208 /* SyntaxKind.PropertyAccessExpression */:
                    case 209 /* SyntaxKind.ElementAccessExpression */:
                        return traverse(node.expression);
                    case 299 /* SyntaxKind.PropertyAssignment */:
                        return traverse(node.initializer);
                    default:
                        return !ts.nodeStartsNewLexicalEnvironment(node) && !ts.isPartOfTypeNode(node) && !!ts.forEachChild(node, traverse);
                }
            }
        }
        function getSignaturesOfSymbol(symbol) {
            if (!symbol || !symbol.declarations)
                return ts.emptyArray;
            var result = [];
            for (var i = 0; i < symbol.declarations.length; i++) {
                var decl = symbol.declarations[i];
                if (!ts.isFunctionLike(decl))
                    continue;
                // Don't include signature if node is the implementation of an overloaded function. A node is considered
                // an implementation node if it has a body and the previous node is of the same kind and immediately
                // precedes the implementation node (i.e. has the same parent and ends where the implementation starts).
                if (i > 0 && decl.body) {
                    var previous = symbol.declarations[i - 1];
                    if (decl.parent === previous.parent && decl.kind === previous.kind && decl.pos === previous.end) {
                        continue;
                    }
                }
                // If this is a function or method declaration, get the signature from the @type tag for the sake of optional parameters.
                // Exclude contextually-typed kinds because we already apply the @type tag to the context, plus applying it here to the initializer would supress checks that the two are compatible.
                result.push((!ts.isFunctionExpressionOrArrowFunction(decl) &&
                    !ts.isObjectLiteralMethod(decl) &&
                    getSignatureOfTypeTag(decl)) ||
                    getSignatureFromDeclaration(decl));
            }
            return result;
        }
        function resolveExternalModuleTypeByLiteral(name) {
            var moduleSym = resolveExternalModuleName(name, name);
            if (moduleSym) {
                var resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
                if (resolvedModuleSymbol) {
                    return getTypeOfSymbol(resolvedModuleSymbol);
                }
            }
            return anyType;
        }
        function getThisTypeOfSignature(signature) {
            if (signature.thisParameter) {
                return getTypeOfSymbol(signature.thisParameter);
            }
        }
        function getTypePredicateOfSignature(signature) {
            if (!signature.resolvedTypePredicate) {
                if (signature.target) {
                    var targetTypePredicate = getTypePredicateOfSignature(signature.target);
                    signature.resolvedTypePredicate = targetTypePredicate ? instantiateTypePredicate(targetTypePredicate, signature.mapper) : noTypePredicate;
                }
                else if (signature.compositeSignatures) {
                    signature.resolvedTypePredicate = getUnionOrIntersectionTypePredicate(signature.compositeSignatures, signature.compositeKind) || noTypePredicate;
                }
                else {
                    var type = signature.declaration && ts.getEffectiveReturnTypeNode(signature.declaration);
                    var jsdocPredicate = void 0;
                    if (!type) {
                        var jsdocSignature = getSignatureOfTypeTag(signature.declaration);
                        if (jsdocSignature && signature !== jsdocSignature) {
                            jsdocPredicate = getTypePredicateOfSignature(jsdocSignature);
                        }
                    }
                    signature.resolvedTypePredicate = type && ts.isTypePredicateNode(type) ?
                        createTypePredicateFromTypePredicateNode(type, signature) :
                        jsdocPredicate || noTypePredicate;
                }
                ts.Debug.assert(!!signature.resolvedTypePredicate);
            }
            return signature.resolvedTypePredicate === noTypePredicate ? undefined : signature.resolvedTypePredicate;
        }
        function createTypePredicateFromTypePredicateNode(node, signature) {
            var parameterName = node.parameterName;
            var type = node.type && getTypeFromTypeNode(node.type);
            return parameterName.kind === 194 /* SyntaxKind.ThisType */ ?
                createTypePredicate(node.assertsModifier ? 2 /* TypePredicateKind.AssertsThis */ : 0 /* TypePredicateKind.This */, /*parameterName*/ undefined, /*parameterIndex*/ undefined, type) :
                createTypePredicate(node.assertsModifier ? 3 /* TypePredicateKind.AssertsIdentifier */ : 1 /* TypePredicateKind.Identifier */, parameterName.escapedText, ts.findIndex(signature.parameters, function (p) { return p.escapedName === parameterName.escapedText; }), type);
        }
        function getUnionOrIntersectionType(types, kind, unionReduction) {
            return kind !== 2097152 /* TypeFlags.Intersection */ ? getUnionType(types, unionReduction) : getIntersectionType(types);
        }
        function getReturnTypeOfSignature(signature) {
            if (!signature.resolvedReturnType) {
                if (!pushTypeResolution(signature, 3 /* TypeSystemPropertyName.ResolvedReturnType */)) {
                    return errorType;
                }
                var type = signature.target ? instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper) :
                    signature.compositeSignatures ? instantiateType(getUnionOrIntersectionType(ts.map(signature.compositeSignatures, getReturnTypeOfSignature), signature.compositeKind, 2 /* UnionReduction.Subtype */), signature.mapper) :
                        getReturnTypeFromAnnotation(signature.declaration) ||
                            (ts.nodeIsMissing(signature.declaration.body) ? anyType : getReturnTypeFromBody(signature.declaration));
                if (signature.flags & 8 /* SignatureFlags.IsInnerCallChain */) {
                    type = addOptionalTypeMarker(type);
                }
                else if (signature.flags & 16 /* SignatureFlags.IsOuterCallChain */) {
                    type = getOptionalType(type);
                }
                if (!popTypeResolution()) {
                    if (signature.declaration) {
                        var typeNode = ts.getEffectiveReturnTypeNode(signature.declaration);
                        if (typeNode) {
                            error(typeNode, ts.Diagnostics.Return_type_annotation_circularly_references_itself);
                        }
                        else if (noImplicitAny) {
                            var declaration = signature.declaration;
                            var name = ts.getNameOfDeclaration(declaration);
                            if (name) {
                                error(name, ts.Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, ts.declarationNameToString(name));
                            }
                            else {
                                error(declaration, ts.Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions);
                            }
                        }
                    }
                    type = anyType;
                }
                signature.resolvedReturnType = type;
            }
            return signature.resolvedReturnType;
        }
        function getReturnTypeFromAnnotation(declaration) {
            if (declaration.kind === 173 /* SyntaxKind.Constructor */) {
                return getDeclaredTypeOfClassOrInterface(getMergedSymbol(declaration.parent.symbol));
            }
            if (ts.isJSDocConstructSignature(declaration)) {
                return getTypeFromTypeNode(declaration.parameters[0].type); // TODO: GH#18217
            }
            var typeNode = ts.getEffectiveReturnTypeNode(declaration);
            if (typeNode) {
                return getTypeFromTypeNode(typeNode);
            }
            if (declaration.kind === 174 /* SyntaxKind.GetAccessor */ && hasBindableName(declaration)) {
                var jsDocType = ts.isInJSFile(declaration) && getTypeForDeclarationFromJSDocComment(declaration);
                if (jsDocType) {
                    return jsDocType;
                }
                var setter = ts.getDeclarationOfKind(getSymbolOfNode(declaration), 175 /* SyntaxKind.SetAccessor */);
                var setterType = getAnnotatedAccessorType(setter);
                if (setterType) {
                    return setterType;
                }
            }
            return getReturnTypeOfTypeTag(declaration);
        }
        function isResolvingReturnTypeOfSignature(signature) {
            return !signature.resolvedReturnType && findResolutionCycleStartIndex(signature, 3 /* TypeSystemPropertyName.ResolvedReturnType */) >= 0;
        }
        function getRestTypeOfSignature(signature) {
            return tryGetRestTypeOfSignature(signature) || anyType;
        }
        function tryGetRestTypeOfSignature(signature) {
            if (signatureHasRestParameter(signature)) {
                var sigRestType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
                var restType = isTupleType(sigRestType) ? getRestTypeOfTupleType(sigRestType) : sigRestType;
                return restType && getIndexTypeOfType(restType, numberType);
            }
            return undefined;
        }
        function getSignatureInstantiation(signature, typeArguments, isJavascript, inferredTypeParameters) {
            var instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(signature, fillMissingTypeArguments(typeArguments, signature.typeParameters, getMinTypeArgumentCount(signature.typeParameters), isJavascript));
            if (inferredTypeParameters) {
                var returnSignature = getSingleCallOrConstructSignature(getReturnTypeOfSignature(instantiatedSignature));
                if (returnSignature) {
                    var newReturnSignature = cloneSignature(returnSignature);
                    newReturnSignature.typeParameters = inferredTypeParameters;
                    var newInstantiatedSignature = cloneSignature(instantiatedSignature);
                    newInstantiatedSignature.resolvedReturnType = getOrCreateTypeFromSignature(newReturnSignature);
                    return newInstantiatedSignature;
                }
            }
            return instantiatedSignature;
        }
        function getSignatureInstantiationWithoutFillingInTypeArguments(signature, typeArguments) {
            var instantiations = signature.instantiations || (signature.instantiations = new ts.Map());
            var id = getTypeListId(typeArguments);
            var instantiation = instantiations.get(id);
            if (!instantiation) {
                instantiations.set(id, instantiation = createSignatureInstantiation(signature, typeArguments));
            }
            return instantiation;
        }
        function createSignatureInstantiation(signature, typeArguments) {
            return instantiateSignature(signature, createSignatureTypeMapper(signature, typeArguments), /*eraseTypeParameters*/ true);
        }
        function createSignatureTypeMapper(signature, typeArguments) {
            return createTypeMapper(signature.typeParameters, typeArguments);
        }
        function getErasedSignature(signature) {
            return signature.typeParameters ?
                signature.erasedSignatureCache || (signature.erasedSignatureCache = createErasedSignature(signature)) :
                signature;
        }
        function createErasedSignature(signature) {
            // Create an instantiation of the signature where all type arguments are the any type.
            return instantiateSignature(signature, createTypeEraser(signature.typeParameters), /*eraseTypeParameters*/ true);
        }
        function getCanonicalSignature(signature) {
            return signature.typeParameters ?
                signature.canonicalSignatureCache || (signature.canonicalSignatureCache = createCanonicalSignature(signature)) :
                signature;
        }
        function createCanonicalSignature(signature) {
            // Create an instantiation of the signature where each unconstrained type parameter is replaced with
            // its original. When a generic class or interface is instantiated, each generic method in the class or
            // interface is instantiated with a fresh set of cloned type parameters (which we need to handle scenarios
            // where different generations of the same type parameter are in scope). This leads to a lot of new type
            // identities, and potentially a lot of work comparing those identities, so here we create an instantiation
            // that uses the original type identities for all unconstrained type parameters.
            return getSignatureInstantiation(signature, ts.map(signature.typeParameters, function (tp) { return tp.target && !getConstraintOfTypeParameter(tp.target) ? tp.target : tp; }), ts.isInJSFile(signature.declaration));
        }
        function getBaseSignature(signature) {
            var typeParameters = signature.typeParameters;
            if (typeParameters) {
                if (signature.baseSignatureCache) {
                    return signature.baseSignatureCache;
                }
                var typeEraser = createTypeEraser(typeParameters);
                var baseConstraintMapper_1 = createTypeMapper(typeParameters, ts.map(typeParameters, function (tp) { return getConstraintOfTypeParameter(tp) || unknownType; }));
                var baseConstraints = ts.map(typeParameters, function (tp) { return instantiateType(tp, baseConstraintMapper_1) || unknownType; });
                // Run N type params thru the immediate constraint mapper up to N times
                // This way any noncircular interdependent type parameters are definitely resolved to their external dependencies
                for (var i = 0; i < typeParameters.length - 1; i++) {
                    baseConstraints = instantiateTypes(baseConstraints, baseConstraintMapper_1);
                }
                // and then apply a type eraser to remove any remaining circularly dependent type parameters
                baseConstraints = instantiateTypes(baseConstraints, typeEraser);
                return signature.baseSignatureCache = instantiateSignature(signature, createTypeMapper(typeParameters, baseConstraints), /*eraseTypeParameters*/ true);
            }
            return signature;
        }
        function getOrCreateTypeFromSignature(signature) {
            var _a;
            // There are two ways to declare a construct signature, one is by declaring a class constructor
            // using the constructor keyword, and the other is declaring a bare construct signature in an
            // object type literal or interface (using the new keyword). Each way of declaring a constructor
            // will result in a different declaration kind.
            if (!signature.isolatedSignatureType) {
                var kind = (_a = signature.declaration) === null || _a === void 0 ? void 0 : _a.kind;
                // If declaration is undefined, it is likely to be the signature of the default constructor.
                var isConstructor = kind === undefined || kind === 173 /* SyntaxKind.Constructor */ || kind === 177 /* SyntaxKind.ConstructSignature */ || kind === 182 /* SyntaxKind.ConstructorType */;
                var type = createObjectType(16 /* ObjectFlags.Anonymous */);
                type.members = emptySymbols;
                type.properties = ts.emptyArray;
                type.callSignatures = !isConstructor ? [signature] : ts.emptyArray;
                type.constructSignatures = isConstructor ? [signature] : ts.emptyArray;
                type.indexInfos = ts.emptyArray;
                signature.isolatedSignatureType = type;
            }
            return signature.isolatedSignatureType;
        }
        function getIndexSymbol(symbol) {
            return symbol.members ? getIndexSymbolFromSymbolTable(symbol.members) : undefined;
        }
        function getIndexSymbolFromSymbolTable(symbolTable) {
            return symbolTable.get("__index" /* InternalSymbolName.Index */);
        }
        function createIndexInfo(keyType, type, isReadonly, declaration) {
            return { keyType: keyType, type: type, isReadonly: isReadonly, declaration: declaration };
        }
        function getIndexInfosOfSymbol(symbol) {
            var indexSymbol = getIndexSymbol(symbol);
            return indexSymbol ? getIndexInfosOfIndexSymbol(indexSymbol) : ts.emptyArray;
        }
        function getIndexInfosOfIndexSymbol(indexSymbol) {
            if (indexSymbol.declarations) {
                var indexInfos_4 = [];
                var _loop_15 = function (declaration) {
                    if (declaration.parameters.length === 1) {
                        var parameter = declaration.parameters[0];
                        if (parameter.type) {
                            forEachType(getTypeFromTypeNode(parameter.type), function (keyType) {
                                if (isValidIndexKeyType(keyType) && !findIndexInfo(indexInfos_4, keyType)) {
                                    indexInfos_4.push(createIndexInfo(keyType, declaration.type ? getTypeFromTypeNode(declaration.type) : anyType, ts.hasEffectiveModifier(declaration, 64 /* ModifierFlags.Readonly */), declaration));
                                }
                            });
                        }
                    }
                };
                for (var _i = 0, _a = indexSymbol.declarations; _i < _a.length; _i++) {
                    var declaration = _a[_i];
                    _loop_15(declaration);
                }
                return indexInfos_4;
            }
            return ts.emptyArray;
        }
        function isValidIndexKeyType(type) {
            return !!(type.flags & (4 /* TypeFlags.String */ | 8 /* TypeFlags.Number */ | 4096 /* TypeFlags.ESSymbol */)) || isPatternLiteralType(type) ||
                !!(type.flags & 2097152 /* TypeFlags.Intersection */) && !isGenericType(type) && ts.some(type.types, isValidIndexKeyType);
        }
        function getConstraintDeclaration(type) {
            return ts.mapDefined(ts.filter(type.symbol && type.symbol.declarations, ts.isTypeParameterDeclaration), ts.getEffectiveConstraintOfTypeParameter)[0];
        }
        function getInferredTypeParameterConstraint(typeParameter, omitTypeReferences) {
            var _a;
            var inferences;
            if ((_a = typeParameter.symbol) === null || _a === void 0 ? void 0 : _a.declarations) {
                var _loop_16 = function (declaration) {
                    if (declaration.parent.kind === 192 /* SyntaxKind.InferType */) {
                        // When an 'infer T' declaration is immediately contained in a type reference node
                        // (such as 'Foo<infer T>'), T's constraint is inferred from the constraint of the
                        // corresponding type parameter in 'Foo'. When multiple 'infer T' declarations are
                        // present, we form an intersection of the inferred constraint types.
                        var _c = ts.walkUpParenthesizedTypesAndGetParentAndChild(declaration.parent.parent), _d = _c[0], childTypeParameter = _d === void 0 ? declaration.parent : _d, grandParent = _c[1];
                        if (grandParent.kind === 180 /* SyntaxKind.TypeReference */ && !omitTypeReferences) {
                            var typeReference_1 = grandParent;
                            var typeParameters_1 = getTypeParametersForTypeReference(typeReference_1);
                            if (typeParameters_1) {
                                var index = typeReference_1.typeArguments.indexOf(childTypeParameter);
                                if (index < typeParameters_1.length) {
                                    var declaredConstraint = getConstraintOfTypeParameter(typeParameters_1[index]);
                                    if (declaredConstraint) {
                                        // Type parameter constraints can reference other type parameters so
                                        // constraints need to be instantiated. If instantiation produces the
                                        // type parameter itself, we discard that inference. For example, in
                                        //   type Foo<T extends string, U extends T> = [T, U];
                                        //   type Bar<T> = T extends Foo<infer X, infer X> ? Foo<X, X> : T;
                                        // the instantiated constraint for U is X, so we discard that inference.
                                        var mapper = makeDeferredTypeMapper(typeParameters_1, typeParameters_1.map(function (_, index) { return function () {
                                            return getEffectiveTypeArgumentAtIndex(typeReference_1, typeParameters_1, index);
                                        }; }));
                                        var constraint = instantiateType(declaredConstraint, mapper);
                                        if (constraint !== typeParameter) {
                                            inferences = ts.append(inferences, constraint);
                                        }
                                    }
                                }
                            }
                        }
                        // When an 'infer T' declaration is immediately contained in a rest parameter declaration, a rest type
                        // or a named rest tuple element, we infer an 'unknown[]' constraint.
                        else if (grandParent.kind === 166 /* SyntaxKind.Parameter */ && grandParent.dotDotDotToken ||
                            grandParent.kind === 188 /* SyntaxKind.RestType */ ||
                            grandParent.kind === 199 /* SyntaxKind.NamedTupleMember */ && grandParent.dotDotDotToken) {
                            inferences = ts.append(inferences, createArrayType(unknownType));
                        }
                        // When an 'infer T' declaration is immediately contained in a string template type, we infer a 'string'
                        // constraint.
                        else if (grandParent.kind === 201 /* SyntaxKind.TemplateLiteralTypeSpan */) {
                            inferences = ts.append(inferences, stringType);
                        }
                        // When an 'infer T' declaration is in the constraint position of a mapped type, we infer a 'keyof any'
                        // constraint.
                        else if (grandParent.kind === 165 /* SyntaxKind.TypeParameter */ && grandParent.parent.kind === 197 /* SyntaxKind.MappedType */) {
                            inferences = ts.append(inferences, keyofConstraintType);
                        }
                        // When an 'infer T' declaration is the template of a mapped type, and that mapped type is the extends
                        // clause of a conditional whose check type is also a mapped type, give it a constraint equal to the template
                        // of the check type's mapped type
                        else if (grandParent.kind === 197 /* SyntaxKind.MappedType */ && grandParent.type &&
                            ts.skipParentheses(grandParent.type) === declaration.parent && grandParent.parent.kind === 191 /* SyntaxKind.ConditionalType */ &&
                            grandParent.parent.extendsType === grandParent && grandParent.parent.checkType.kind === 197 /* SyntaxKind.MappedType */ &&
                            grandParent.parent.checkType.type) {
                            var checkMappedType_1 = grandParent.parent.checkType;
                            var nodeType = getTypeFromTypeNode(checkMappedType_1.type);
                            inferences = ts.append(inferences, instantiateType(nodeType, makeUnaryTypeMapper(getDeclaredTypeOfTypeParameter(getSymbolOfNode(checkMappedType_1.typeParameter)), checkMappedType_1.typeParameter.constraint ? getTypeFromTypeNode(checkMappedType_1.typeParameter.constraint) : keyofConstraintType)));
                        }
                    }
                };
                for (var _i = 0, _b = typeParameter.symbol.declarations; _i < _b.length; _i++) {
                    var declaration = _b[_i];
                    _loop_16(declaration);
                }
            }
            return inferences && getIntersectionType(inferences);
        }
        /** This is a worker function. Use getConstraintOfTypeParameter which guards against circular constraints. */
        function getConstraintFromTypeParameter(typeParameter) {
            if (!typeParameter.constraint) {
                if (typeParameter.target) {
                    var targetConstraint = getConstraintOfTypeParameter(typeParameter.target);
                    typeParameter.constraint = targetConstraint ? instantiateType(targetConstraint, typeParameter.mapper) : noConstraintType;
                }
                else {
                    var constraintDeclaration = getConstraintDeclaration(typeParameter);
                    if (!constraintDeclaration) {
                        typeParameter.constraint = getInferredTypeParameterConstraint(typeParameter) || noConstraintType;
                    }
                    else {
                        var type = getTypeFromTypeNode(constraintDeclaration);
                        if (type.flags & 1 /* TypeFlags.Any */ && !isErrorType(type)) { // Allow errorType to propegate to keep downstream errors suppressed
                            // use keyofConstraintType as the base constraint for mapped type key constraints (unknown isn;t assignable to that, but `any` was),
                            // use unknown otherwise
                            type = constraintDeclaration.parent.parent.kind === 197 /* SyntaxKind.MappedType */ ? keyofConstraintType : unknownType;
                        }
                        typeParameter.constraint = type;
                    }
                }
            }
            return typeParameter.constraint === noConstraintType ? undefined : typeParameter.constraint;
        }
        function getParentSymbolOfTypeParameter(typeParameter) {
            var tp = ts.getDeclarationOfKind(typeParameter.symbol, 165 /* SyntaxKind.TypeParameter */);
            var host = ts.isJSDocTemplateTag(tp.parent) ? ts.getEffectiveContainerForJSDocTemplateTag(tp.parent) : tp.parent;
            return host && getSymbolOfNode(host);
        }
        function getTypeListId(types) {
            var result = "";
            if (types) {
                var length_4 = types.length;
                var i = 0;
                while (i < length_4) {
                    var startId = types[i].id;
                    var count = 1;
                    while (i + count < length_4 && types[i + count].id === startId + count) {
                        count++;
                    }
                    if (result.length) {
                        result += ",";
                    }
                    result += startId;
                    if (count > 1) {
                        result += ":" + count;
                    }
                    i += count;
                }
            }
            return result;
        }
        function getAliasId(aliasSymbol, aliasTypeArguments) {
            return aliasSymbol ? "@".concat(getSymbolId(aliasSymbol)) + (aliasTypeArguments ? ":".concat(getTypeListId(aliasTypeArguments)) : "") : "";
        }
        // This function is used to propagate certain flags when creating new object type references and union types.
        // It is only necessary to do so if a constituent type might be the undefined type, the null type, the type
        // of an object literal or a non-inferrable type. This is because there are operations in the type checker
        // that care about the presence of such types at arbitrary depth in a containing type.
        function getPropagatingFlagsOfTypes(types, excludeKinds) {
            var result = 0;
            for (var _i = 0, types_8 = types; _i < types_8.length; _i++) {
                var type = types_8[_i];
                if (excludeKinds === undefined || !(type.flags & excludeKinds)) {
                    result |= ts.getObjectFlags(type);
                }
            }
            return result & 458752 /* ObjectFlags.PropagatingFlags */;
        }
        function createTypeReference(target, typeArguments) {
            var id = getTypeListId(typeArguments);
            var type = target.instantiations.get(id);
            if (!type) {
                type = createObjectType(4 /* ObjectFlags.Reference */, target.symbol);
                target.instantiations.set(id, type);
                type.objectFlags |= typeArguments ? getPropagatingFlagsOfTypes(typeArguments) : 0;
                type.target = target;
                type.resolvedTypeArguments = typeArguments;
            }
            return type;
        }
        function cloneTypeReference(source) {
            var type = createType(source.flags);
            type.symbol = source.symbol;
            type.objectFlags = source.objectFlags;
            type.target = source.target;
            type.resolvedTypeArguments = source.resolvedTypeArguments;
            return type;
        }
        function createDeferredTypeReference(target, node, mapper, aliasSymbol, aliasTypeArguments) {
            if (!aliasSymbol) {
                aliasSymbol = getAliasSymbolForTypeNode(node);
                var localAliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
                aliasTypeArguments = mapper ? instantiateTypes(localAliasTypeArguments, mapper) : localAliasTypeArguments;
            }
            var type = createObjectType(4 /* ObjectFlags.Reference */, target.symbol);
            type.target = target;
            type.node = node;
            type.mapper = mapper;
            type.aliasSymbol = aliasSymbol;
            type.aliasTypeArguments = aliasTypeArguments;
            return type;
        }
        function getTypeArguments(type) {
            var _a, _b;
            if (!type.resolvedTypeArguments) {
                if (!pushTypeResolution(type, 6 /* TypeSystemPropertyName.ResolvedTypeArguments */)) {
                    return ((_a = type.target.localTypeParameters) === null || _a === void 0 ? void 0 : _a.map(function () { return errorType; })) || ts.emptyArray;
                }
                var node = type.node;
                var typeArguments = !node ? ts.emptyArray :
                    node.kind === 180 /* SyntaxKind.TypeReference */ ? ts.concatenate(type.target.outerTypeParameters, getEffectiveTypeArguments(node, type.target.localTypeParameters)) :
                        node.kind === 185 /* SyntaxKind.ArrayType */ ? [getTypeFromTypeNode(node.elementType)] :
                            ts.map(node.elements, getTypeFromTypeNode);
                if (popTypeResolution()) {
                    type.resolvedTypeArguments = type.mapper ? instantiateTypes(typeArguments, type.mapper) : typeArguments;
                }
                else {
                    type.resolvedTypeArguments = ((_b = type.target.localTypeParameters) === null || _b === void 0 ? void 0 : _b.map(function () { return errorType; })) || ts.emptyArray;
                    error(type.node || currentNode, type.target.symbol ? ts.Diagnostics.Type_arguments_for_0_circularly_reference_themselves : ts.Diagnostics.Tuple_type_arguments_circularly_reference_themselves, type.target.symbol && symbolToString(type.target.symbol));
                }
            }
            return type.resolvedTypeArguments;
        }
        function getTypeReferenceArity(type) {
            return ts.length(type.target.typeParameters);
        }
        /**
         * Get type from type-reference that reference to class or interface
         */
        function getTypeFromClassOrInterfaceReference(node, symbol) {
            var type = getDeclaredTypeOfSymbol(getMergedSymbol(symbol));
            var typeParameters = type.localTypeParameters;
            if (typeParameters) {
                var numTypeArguments = ts.length(node.typeArguments);
                var minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
                var isJs = ts.isInJSFile(node);
                var isJsImplicitAny = !noImplicitAny && isJs;
                if (!isJsImplicitAny && (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length)) {
                    var missingAugmentsTag = isJs && ts.isExpressionWithTypeArguments(node) && !ts.isJSDocAugmentsTag(node.parent);
                    var diag = minTypeArgumentCount === typeParameters.length ?
                        missingAugmentsTag ?
                            ts.Diagnostics.Expected_0_type_arguments_provide_these_with_an_extends_tag :
                            ts.Diagnostics.Generic_type_0_requires_1_type_argument_s :
                        missingAugmentsTag ?
                            ts.Diagnostics.Expected_0_1_type_arguments_provide_these_with_an_extends_tag :
                            ts.Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments;
                    var typeStr = typeToString(type, /*enclosingDeclaration*/ undefined, 2 /* TypeFormatFlags.WriteArrayAsGenericType */);
                    error(node, diag, typeStr, minTypeArgumentCount, typeParameters.length);
                    if (!isJs) {
                        // TODO: Adopt same permissive behavior in TS as in JS to reduce follow-on editing experience failures (requires editing fillMissingTypeArguments)
                        return errorType;
                    }
                }
                if (node.kind === 180 /* SyntaxKind.TypeReference */ && isDeferredTypeReferenceNode(node, ts.length(node.typeArguments) !== typeParameters.length)) {
                    return createDeferredTypeReference(type, node, /*mapper*/ undefined);
                }
                // In a type reference, the outer type parameters of the referenced class or interface are automatically
                // supplied as type arguments and the type reference only specifies arguments for the local type parameters
                // of the class or interface.
                var typeArguments = ts.concatenate(type.outerTypeParameters, fillMissingTypeArguments(typeArgumentsFromTypeReferenceNode(node), typeParameters, minTypeArgumentCount, isJs));
                return createTypeReference(type, typeArguments);
            }
            return checkNoTypeArguments(node, symbol) ? type : errorType;
        }
        function getTypeAliasInstantiation(symbol, typeArguments, aliasSymbol, aliasTypeArguments) {
            var type = getDeclaredTypeOfSymbol(symbol);
            if (type === intrinsicMarkerType && intrinsicTypeKinds.has(symbol.escapedName) && typeArguments && typeArguments.length === 1) {
                return getStringMappingType(symbol, typeArguments[0]);
            }
            var links = getSymbolLinks(symbol);
            var typeParameters = links.typeParameters;
            var id = getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments);
            var instantiation = links.instantiations.get(id);
            if (!instantiation) {
                links.instantiations.set(id, instantiation = instantiateTypeWithAlias(type, createTypeMapper(typeParameters, fillMissingTypeArguments(typeArguments, typeParameters, getMinTypeArgumentCount(typeParameters), ts.isInJSFile(symbol.valueDeclaration))), aliasSymbol, aliasTypeArguments));
            }
            return instantiation;
        }
        /**
         * Get type from reference to type alias. When a type alias is generic, the declared type of the type alias may include
         * references to the type parameters of the alias. We replace those with the actual type arguments by instantiating the
         * declared type. Instantiations are cached using the type identities of the type arguments as the key.
         */
        function getTypeFromTypeAliasReference(node, symbol) {
            if (ts.getCheckFlags(symbol) & 1048576 /* CheckFlags.Unresolved */) {
                var typeArguments = typeArgumentsFromTypeReferenceNode(node);
                var id = getAliasId(symbol, typeArguments);
                var errorType_1 = errorTypes.get(id);
                if (!errorType_1) {
                    errorType_1 = createIntrinsicType(1 /* TypeFlags.Any */, "error");
                    errorType_1.aliasSymbol = symbol;
                    errorType_1.aliasTypeArguments = typeArguments;
                    errorTypes.set(id, errorType_1);
                }
                return errorType_1;
            }
            var type = getDeclaredTypeOfSymbol(symbol);
            var typeParameters = getSymbolLinks(symbol).typeParameters;
            if (typeParameters) {
                var numTypeArguments = ts.length(node.typeArguments);
                var minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
                if (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length) {
                    error(node, minTypeArgumentCount === typeParameters.length ?
                        ts.Diagnostics.Generic_type_0_requires_1_type_argument_s :
                        ts.Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments, symbolToString(symbol), minTypeArgumentCount, typeParameters.length);
                    return errorType;
                }
                // We refrain from associating a local type alias with an instantiation of a top-level type alias
                // because the local alias may end up being referenced in an inferred return type where it is not
                // accessible--which in turn may lead to a large structural expansion of the type when generating
                // a .d.ts file. See #43622 for an example.
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                var newAliasSymbol = aliasSymbol && (isLocalTypeAlias(symbol) || !isLocalTypeAlias(aliasSymbol)) ? aliasSymbol : undefined;
                return getTypeAliasInstantiation(symbol, typeArgumentsFromTypeReferenceNode(node), newAliasSymbol, getTypeArgumentsForAliasSymbol(newAliasSymbol));
            }
            return checkNoTypeArguments(node, symbol) ? type : errorType;
        }
        function isLocalTypeAlias(symbol) {
            var _a;
            var declaration = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isTypeAlias);
            return !!(declaration && ts.getContainingFunction(declaration));
        }
        function getTypeReferenceName(node) {
            switch (node.kind) {
                case 180 /* SyntaxKind.TypeReference */:
                    return node.typeName;
                case 230 /* SyntaxKind.ExpressionWithTypeArguments */:
                    // We only support expressions that are simple qualified names. For other
                    // expressions this produces undefined.
                    var expr = node.expression;
                    if (ts.isEntityNameExpression(expr)) {
                        return expr;
                    }
                // fall through;
            }
            return undefined;
        }
        function getSymbolPath(symbol) {
            return symbol.parent ? "".concat(getSymbolPath(symbol.parent), ".").concat(symbol.escapedName) : symbol.escapedName;
        }
        function getUnresolvedSymbolForEntityName(name) {
            var identifier = name.kind === 163 /* SyntaxKind.QualifiedName */ ? name.right :
                name.kind === 208 /* SyntaxKind.PropertyAccessExpression */ ? name.name :
                    name;
            var text = identifier.escapedText;
            if (text) {
                var parentSymbol = name.kind === 163 /* SyntaxKind.QualifiedName */ ? getUnresolvedSymbolForEntityName(name.left) :
                    name.kind === 208 /* SyntaxKind.PropertyAccessExpression */ ? getUnresolvedSymbolForEntityName(name.expression) :
                        undefined;
                var path = parentSymbol ? "".concat(getSymbolPath(parentSymbol), ".").concat(text) : text;
                var result = unresolvedSymbols.get(path);
                if (!result) {
                    unresolvedSymbols.set(path, result = createSymbol(524288 /* SymbolFlags.TypeAlias */, text, 1048576 /* CheckFlags.Unresolved */));
                    result.parent = parentSymbol;
                    result.declaredType = unresolvedType;
                }
                return result;
            }
            return unknownSymbol;
        }
        function resolveTypeReferenceName(typeReference, meaning, ignoreErrors) {
            var name = getTypeReferenceName(typeReference);
            if (!name) {
                return unknownSymbol;
            }
            var symbol = resolveEntityName(name, meaning, ignoreErrors);
            return symbol && symbol !== unknownSymbol ? symbol :
                ignoreErrors ? unknownSymbol : getUnresolvedSymbolForEntityName(name);
        }
        function getTypeReferenceType(node, symbol) {
            if (symbol === unknownSymbol) {
                return errorType;
            }
            symbol = getExpandoSymbol(symbol) || symbol;
            if (symbol.flags & (32 /* SymbolFlags.Class */ | 64 /* SymbolFlags.Interface */)) {
                return getTypeFromClassOrInterfaceReference(node, symbol);
            }
            if (symbol.flags & 524288 /* SymbolFlags.TypeAlias */) {
                return getTypeFromTypeAliasReference(node, symbol);
            }
            // Get type from reference to named type that cannot be generic (enum or type parameter)
            var res = tryGetDeclaredTypeOfSymbol(symbol);
            if (res) {
                return checkNoTypeArguments(node, symbol) ? getRegularTypeOfLiteralType(res) : errorType;
            }
            if (symbol.flags & 111551 /* SymbolFlags.Value */ && isJSDocTypeReference(node)) {
                var jsdocType = getTypeFromJSDocValueReference(node, symbol);
                if (jsdocType) {
                    return jsdocType;
                }
                else {
                    // Resolve the type reference as a Type for the purpose of reporting errors.
                    resolveTypeReferenceName(node, 788968 /* SymbolFlags.Type */);
                    return getTypeOfSymbol(symbol);
                }
            }
            return errorType;
        }
        /**
         * A JSdoc TypeReference may be to a value, but resolve it as a type anyway.
         * Example: import('./b').ConstructorFunction
         */
        function getTypeFromJSDocValueReference(node, symbol) {
            var links = getNodeLinks(node);
            if (!links.resolvedJSDocType) {
                var valueType = getTypeOfSymbol(symbol);
                var typeType = valueType;
                if (symbol.valueDeclaration) {
                    var isImportTypeWithQualifier = node.kind === 202 /* SyntaxKind.ImportType */ && node.qualifier;
                    // valueType might not have a symbol, eg, {import('./b').STRING_LITERAL}
                    if (valueType.symbol && valueType.symbol !== symbol && isImportTypeWithQualifier) {
                        typeType = getTypeReferenceType(node, valueType.symbol);
                    }
                }
                links.resolvedJSDocType = typeType;
            }
            return links.resolvedJSDocType;
        }
        function getSubstitutionType(baseType, constraint) {
            if (constraint.flags & 3 /* TypeFlags.AnyOrUnknown */ || constraint === baseType ||
                !isGenericType(baseType) && !isGenericType(constraint)) {
                return baseType;
            }
            var id = "".concat(getTypeId(baseType), ">").concat(getTypeId(constraint));
            var cached = substitutionTypes.get(id);
            if (cached) {
                return cached;
            }
            var result = createType(33554432 /* TypeFlags.Substitution */);
            result.baseType = baseType;
            result.constraint = constraint;
            substitutionTypes.set(id, result);
            return result;
        }
        function getSubstitutionIntersection(substitutionType) {
            return getIntersectionType([substitutionType.constraint, substitutionType.baseType]);
        }
        function isUnaryTupleTypeNode(node) {
            return node.kind === 186 /* SyntaxKind.TupleType */ && node.elements.length === 1;
        }
        function getImpliedConstraint(type, checkNode, extendsNode) {
            return isUnaryTupleTypeNode(checkNode) && isUnaryTupleTypeNode(extendsNode) ? getImpliedConstraint(type, checkNode.elements[0], extendsNode.elements[0]) :
                getActualTypeVariable(getTypeFromTypeNode(checkNode)) === getActualTypeVariable(type) ? getTypeFromTypeNode(extendsNode) :
                    undefined;
        }
        function getConditionalFlowTypeOfType(type, node) {
            var constraints;
            var covariant = true;
            while (node && !ts.isStatement(node) && node.kind !== 323 /* SyntaxKind.JSDoc */) {
                var parent = node.parent;
                // only consider variance flipped by parameter locations - `keyof` types would usually be considered variance inverting, but
                // often get used in indexed accesses where they behave sortof invariantly, but our checking is lax
                if (parent.kind === 166 /* SyntaxKind.Parameter */) {
                    covariant = !covariant;
                }
                // Always substitute on type parameters, regardless of variance, since even
                // in contravariant positions, they may rely on substituted constraints to be valid
                if ((covariant || type.flags & 8650752 /* TypeFlags.TypeVariable */) && parent.kind === 191 /* SyntaxKind.ConditionalType */ && node === parent.trueType) {
                    var constraint = getImpliedConstraint(type, parent.checkType, parent.extendsType);
                    if (constraint) {
                        constraints = ts.append(constraints, constraint);
                    }
                }
                // Given a homomorphic mapped type { [K in keyof T]: XXX }, where T is constrained to an array or tuple type, in the
                // template type XXX, K has an added constraint of number | `${number}`.
                else if (type.flags & 262144 /* TypeFlags.TypeParameter */ && parent.kind === 197 /* SyntaxKind.MappedType */ && node === parent.type) {
                    var mappedType = getTypeFromTypeNode(parent);
                    if (getTypeParameterFromMappedType(mappedType) === getActualTypeVariable(type)) {
                        var typeParameter = getHomomorphicTypeVariable(mappedType);
                        if (typeParameter) {
                            var constraint = getConstraintOfTypeParameter(typeParameter);
                            if (constraint && everyType(constraint, isArrayOrTupleType)) {
                                constraints = ts.append(constraints, getUnionType([numberType, numericStringType]));
                            }
                        }
                    }
                }
                node = parent;
            }
            return constraints ? getSubstitutionType(type, getIntersectionType(constraints)) : type;
        }
        function isJSDocTypeReference(node) {
            return !!(node.flags & 8388608 /* NodeFlags.JSDoc */) && (node.kind === 180 /* SyntaxKind.TypeReference */ || node.kind === 202 /* SyntaxKind.ImportType */);
        }
        function checkNoTypeArguments(node, symbol) {
            if (node.typeArguments) {
                error(node, ts.Diagnostics.Type_0_is_not_generic, symbol ? symbolToString(symbol) : node.typeName ? ts.declarationNameToString(node.typeName) : anon);
                return false;
            }
            return true;
        }
        function getIntendedTypeFromJSDocTypeReference(node) {
            if (ts.isIdentifier(node.typeName)) {
                var typeArgs = node.typeArguments;
                switch (node.typeName.escapedText) {
                    case "String":
                        checkNoTypeArguments(node);
                        return stringType;
                    case "Number":
                        checkNoTypeArguments(node);
                        return numberType;
                    case "Boolean":
                        checkNoTypeArguments(node);
                        return booleanType;
                    case "Void":
                        checkNoTypeArguments(node);
                        return voidType;
                    case "Undefined":
                        checkNoTypeArguments(node);
                        return undefinedType;
                    case "Null":
                        checkNoTypeArguments(node);
                        return nullType;
                    case "Function":
                    case "function":
                        checkNoTypeArguments(node);
                        return globalFunctionType;
                    case "array":
                        return (!typeArgs || !typeArgs.length) && !noImplicitAny ? anyArrayType : undefined;
                    case "promise":
                        return (!typeArgs || !typeArgs.length) && !noImplicitAny ? createPromiseType(anyType) : undefined;
                    case "Object":
                        if (typeArgs && typeArgs.length === 2) {
                            if (ts.isJSDocIndexSignature(node)) {
                                var indexed = getTypeFromTypeNode(typeArgs[0]);
                                var target = getTypeFromTypeNode(typeArgs[1]);
                                var indexInfo = indexed === stringType || indexed === numberType ? [createIndexInfo(indexed, target, /*isReadonly*/ false)] : ts.emptyArray;
                                return createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, indexInfo);
                            }
                            return anyType;
                        }
                        checkNoTypeArguments(node);
                        return !noImplicitAny ? anyType : undefined;
                }
            }
        }
        function getTypeFromJSDocNullableTypeNode(node) {
            var type = getTypeFromTypeNode(node.type);
            return strictNullChecks ? getNullableType(type, 65536 /* TypeFlags.Null */) : type;
        }
        function getTypeFromTypeReference(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                // handle LS queries on the `const` in `x as const` by resolving to the type of `x`
                if (ts.isConstTypeReference(node) && ts.isAssertionExpression(node.parent)) {
                    links.resolvedSymbol = unknownSymbol;
                    return links.resolvedType = checkExpressionCached(node.parent.expression);
                }
                var symbol = void 0;
                var type = void 0;
                var meaning = 788968 /* SymbolFlags.Type */;
                if (isJSDocTypeReference(node)) {
                    type = getIntendedTypeFromJSDocTypeReference(node);
                    if (!type) {
                        symbol = resolveTypeReferenceName(node, meaning, /*ignoreErrors*/ true);
                        if (symbol === unknownSymbol) {
                            symbol = resolveTypeReferenceName(node, meaning | 111551 /* SymbolFlags.Value */);
                        }
                        else {
                            resolveTypeReferenceName(node, meaning); // Resolve again to mark errors, if any
                        }
                        type = getTypeReferenceType(node, symbol);
                    }
                }
                if (!type) {
                    symbol = resolveTypeReferenceName(node, meaning);
                    type = getTypeReferenceType(node, symbol);
                }
                // Cache both the resolved symbol and the resolved type. The resolved symbol is needed when we check the
                // type reference in checkTypeReferenceNode.
                links.resolvedSymbol = symbol;
                links.resolvedType = type;
            }
            return links.resolvedType;
        }
        function typeArgumentsFromTypeReferenceNode(node) {
            return ts.map(node.typeArguments, getTypeFromTypeNode);
        }
        function getTypeFromTypeQueryNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                // TypeScript 1.0 spec (April 2014): 3.6.3
                // The expression is processed as an identifier expression (section 4.3)
                // or property access expression(section 4.10),
                // the widened type(section 3.9) of which becomes the result.
                var type = checkExpressionWithTypeArguments(node);
                links.resolvedType = getRegularTypeOfLiteralType(getWidenedType(type));
            }
            return links.resolvedType;
        }
        function getTypeOfGlobalSymbol(symbol, arity) {
            function getTypeDeclaration(symbol) {
                var declarations = symbol.declarations;
                if (declarations) {
                    for (var _i = 0, declarations_3 = declarations; _i < declarations_3.length; _i++) {
                        var declaration = declarations_3[_i];
                        switch (declaration.kind) {
                            case 260 /* SyntaxKind.ClassDeclaration */:
                            case 261 /* SyntaxKind.InterfaceDeclaration */:
                            case 263 /* SyntaxKind.EnumDeclaration */:
                                return declaration;
                        }
                    }
                }
            }
            if (!symbol) {
                return arity ? emptyGenericType : emptyObjectType;
            }
            var type = getDeclaredTypeOfSymbol(symbol);
            if (!(type.flags & 524288 /* TypeFlags.Object */)) {
                error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_be_a_class_or_interface_type, ts.symbolName(symbol));
                return arity ? emptyGenericType : emptyObjectType;
            }
            if (ts.length(type.typeParameters) !== arity) {
                error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_have_1_type_parameter_s, ts.symbolName(symbol), arity);
                return arity ? emptyGenericType : emptyObjectType;
            }
            return type;
        }
        function getGlobalValueSymbol(name, reportErrors) {
            return getGlobalSymbol(name, 111551 /* SymbolFlags.Value */, reportErrors ? ts.Diagnostics.Cannot_find_global_value_0 : undefined);
        }
        function getGlobalTypeSymbol(name, reportErrors) {
            return getGlobalSymbol(name, 788968 /* SymbolFlags.Type */, reportErrors ? ts.Diagnostics.Cannot_find_global_type_0 : undefined);
        }
        function getGlobalTypeAliasSymbol(name, arity, reportErrors) {
            var symbol = getGlobalSymbol(name, 788968 /* SymbolFlags.Type */, reportErrors ? ts.Diagnostics.Cannot_find_global_type_0 : undefined);
            if (symbol) {
                // Resolve the declared type of the symbol. This resolves type parameters for the type
                // alias so that we can check arity.
                getDeclaredTypeOfSymbol(symbol);
                if (ts.length(getSymbolLinks(symbol).typeParameters) !== arity) {
                    var decl = symbol.declarations && ts.find(symbol.declarations, ts.isTypeAliasDeclaration);
                    error(decl, ts.Diagnostics.Global_type_0_must_have_1_type_parameter_s, ts.symbolName(symbol), arity);
                    return undefined;
                }
            }
            return symbol;
        }
        function getGlobalSymbol(name, meaning, diagnostic) {
            // Don't track references for global symbols anyway, so value if `isReference` is arbitrary
            return resolveName(undefined, name, meaning, diagnostic, name, /*isUse*/ false, /*excludeGlobals*/ false, /*getSpellingSuggestions*/ false);
        }
        function getGlobalType(name, arity, reportErrors) {
            var symbol = getGlobalTypeSymbol(name, reportErrors);
            return symbol || reportErrors ? getTypeOfGlobalSymbol(symbol, arity) : undefined;
        }
        function getGlobalTypedPropertyDescriptorType() {
            // We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
            return deferredGlobalTypedPropertyDescriptorType || (deferredGlobalTypedPropertyDescriptorType = getGlobalType("TypedPropertyDescriptor", /*arity*/ 1, /*reportErrors*/ true) || emptyGenericType);
        }
        function getGlobalTemplateStringsArrayType() {
            // We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
            return deferredGlobalTemplateStringsArrayType || (deferredGlobalTemplateStringsArrayType = getGlobalType("TemplateStringsArray", /*arity*/ 0, /*reportErrors*/ true) || emptyObjectType);
        }
        function getGlobalImportMetaType() {
            // We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
            return deferredGlobalImportMetaType || (deferredGlobalImportMetaType = getGlobalType("ImportMeta", /*arity*/ 0, /*reportErrors*/ true) || emptyObjectType);
        }
        function getGlobalImportMetaExpressionType() {
            if (!deferredGlobalImportMetaExpressionType) {
                // Create a synthetic type `ImportMetaExpression { meta: MetaProperty }`
                var symbol = createSymbol(0 /* SymbolFlags.None */, "ImportMetaExpression");
                var importMetaType = getGlobalImportMetaType();
                var metaPropertySymbol = createSymbol(4 /* SymbolFlags.Property */, "meta", 8 /* CheckFlags.Readonly */);
                metaPropertySymbol.parent = symbol;
                metaPropertySymbol.type = importMetaType;
                var members = ts.createSymbolTable([metaPropertySymbol]);
                symbol.members = members;
                deferredGlobalImportMetaExpressionType = createAnonymousType(symbol, members, ts.emptyArray, ts.emptyArray, ts.emptyArray);
            }
            return deferredGlobalImportMetaExpressionType;
        }
        function getGlobalImportCallOptionsType(reportErrors) {
            return (deferredGlobalImportCallOptionsType || (deferredGlobalImportCallOptionsType = getGlobalType("ImportCallOptions", /*arity*/ 0, reportErrors))) || emptyObjectType;
        }
        function getGlobalESSymbolConstructorSymbol(reportErrors) {
            return deferredGlobalESSymbolConstructorSymbol || (deferredGlobalESSymbolConstructorSymbol = getGlobalValueSymbol("Symbol", reportErrors));
        }
        function getGlobalESSymbolConstructorTypeSymbol(reportErrors) {
            return deferredGlobalESSymbolConstructorTypeSymbol || (deferredGlobalESSymbolConstructorTypeSymbol = getGlobalTypeSymbol("SymbolConstructor", reportErrors));
        }
        function getGlobalESSymbolType() {
            return (deferredGlobalESSymbolType || (deferredGlobalESSymbolType = getGlobalType("Symbol", /*arity*/ 0, /*reportErrors*/ false))) || emptyObjectType;
        }
        function getGlobalPromiseType(reportErrors) {
            return (deferredGlobalPromiseType || (deferredGlobalPromiseType = getGlobalType("Promise", /*arity*/ 1, reportErrors))) || emptyGenericType;
        }
        function getGlobalPromiseLikeType(reportErrors) {
            return (deferredGlobalPromiseLikeType || (deferredGlobalPromiseLikeType = getGlobalType("PromiseLike", /*arity*/ 1, reportErrors))) || emptyGenericType;
        }
        function getGlobalPromiseConstructorSymbol(reportErrors) {
            return deferredGlobalPromiseConstructorSymbol || (deferredGlobalPromiseConstructorSymbol = getGlobalValueSymbol("Promise", reportErrors));
        }
        function getGlobalPromiseConstructorLikeType(reportErrors) {
            return (deferredGlobalPromiseConstructorLikeType || (deferredGlobalPromiseConstructorLikeType = getGlobalType("PromiseConstructorLike", /*arity*/ 0, reportErrors))) || emptyObjectType;
        }
        function getGlobalAsyncIterableType(reportErrors) {
            return (deferredGlobalAsyncIterableType || (deferredGlobalAsyncIterableType = getGlobalType("AsyncIterable", /*arity*/ 1, reportErrors))) || emptyGenericType;
        }
        function getGlobalAsyncIteratorType(reportErrors) {
            return (deferredGlobalAsyncIteratorType || (deferredGlobalAsyncIteratorType = getGlobalType("AsyncIterator", /*arity*/ 3, reportErrors))) || emptyGenericType;
        }
        function getGlobalAsyncIterableIteratorType(reportErrors) {
            return (deferredGlobalAsyncIterableIteratorType || (deferredGlobalAsyncIterableIteratorType = getGlobalType("AsyncIterableIterator", /*arity*/ 1, reportErrors))) || emptyGenericType;
        }
        function getGlobalAsyncGeneratorType(reportErrors) {
            return (deferredGlobalAsyncGeneratorType || (deferredGlobalAsyncGeneratorType = getGlobalType("AsyncGenerator", /*arity*/ 3, reportErrors))) || emptyGenericType;
        }
        function getGlobalIterableType(reportErrors) {
            return (deferredGlobalIterableType || (deferredGlobalIterableType = getGlobalType("Iterable", /*arity*/ 1, reportErrors))) || emptyGenericType;
        }
        function getGlobalIteratorType(reportErrors) {
            return (deferredGlobalIteratorType || (deferredGlobalIteratorType = getGlobalType("Iterator", /*arity*/ 3, reportErrors))) || emptyGenericType;
        }
        function getGlobalIterableIteratorType(reportErrors) {
            return (deferredGlobalIterableIteratorType || (deferredGlobalIterableIteratorType = getGlobalType("IterableIterator", /*arity*/ 1, reportErrors))) || emptyGenericType;
        }
        function getGlobalGeneratorType(reportErrors) {
            return (deferredGlobalGeneratorType || (deferredGlobalGeneratorType = getGlobalType("Generator", /*arity*/ 3, reportErrors))) || emptyGenericType;
        }
        function getGlobalIteratorYieldResultType(reportErrors) {
            return (deferredGlobalIteratorYieldResultType || (deferredGlobalIteratorYieldResultType = getGlobalType("IteratorYieldResult", /*arity*/ 1, reportErrors))) || emptyGenericType;
        }
        function getGlobalIteratorReturnResultType(reportErrors) {
            return (deferredGlobalIteratorReturnResultType || (deferredGlobalIteratorReturnResultType = getGlobalType("IteratorReturnResult", /*arity*/ 1, reportErrors))) || emptyGenericType;
        }
        function getGlobalTypeOrUndefined(name, arity) {
            if (arity === void 0) { arity = 0; }
            var symbol = getGlobalSymbol(name, 788968 /* SymbolFlags.Type */, /*diagnostic*/ undefined);
            return symbol && getTypeOfGlobalSymbol(symbol, arity);
        }
        function getGlobalExtractSymbol() {
            // We always report an error, so cache a result in the event we could not resolve the symbol to prevent reporting it multiple times
            deferredGlobalExtractSymbol || (deferredGlobalExtractSymbol = getGlobalTypeAliasSymbol("Extract", /*arity*/ 2, /*reportErrors*/ true) || unknownSymbol);
            return deferredGlobalExtractSymbol === unknownSymbol ? undefined : deferredGlobalExtractSymbol;
        }
        function getGlobalOmitSymbol() {
            // We always report an error, so cache a result in the event we could not resolve the symbol to prevent reporting it multiple times
            deferredGlobalOmitSymbol || (deferredGlobalOmitSymbol = getGlobalTypeAliasSymbol("Omit", /*arity*/ 2, /*reportErrors*/ true) || unknownSymbol);
            return deferredGlobalOmitSymbol === unknownSymbol ? undefined : deferredGlobalOmitSymbol;
        }
        function getGlobalAwaitedSymbol(reportErrors) {
            // Only cache `unknownSymbol` if we are reporting errors so that we don't report the error more than once.
            deferredGlobalAwaitedSymbol || (deferredGlobalAwaitedSymbol = getGlobalTypeAliasSymbol("Awaited", /*arity*/ 1, reportErrors) || (reportErrors ? unknownSymbol : undefined));
            return deferredGlobalAwaitedSymbol === unknownSymbol ? undefined : deferredGlobalAwaitedSymbol;
        }
        function getGlobalBigIntType() {
            return (deferredGlobalBigIntType || (deferredGlobalBigIntType = getGlobalType("BigInt", /*arity*/ 0, /*reportErrors*/ false))) || emptyObjectType;
        }
        function getGlobalNaNSymbol() {
            return (deferredGlobalNaNSymbol || (deferredGlobalNaNSymbol = getGlobalValueSymbol("NaN", /*reportErrors*/ false)));
        }
        function getGlobalRecordSymbol() {
            deferredGlobalRecordSymbol || (deferredGlobalRecordSymbol = getGlobalTypeAliasSymbol("Record", /*arity*/ 2, /*reportErrors*/ true) || unknownSymbol);
            return deferredGlobalRecordSymbol === unknownSymbol ? undefined : deferredGlobalRecordSymbol;
        }
        /**
         * Instantiates a global type that is generic with some element type, and returns that instantiation.
         */
        function createTypeFromGenericGlobalType(genericGlobalType, typeArguments) {
            return genericGlobalType !== emptyGenericType ? createTypeReference(genericGlobalType, typeArguments) : emptyObjectType;
        }
        function createTypedPropertyDescriptorType(propertyType) {
            return createTypeFromGenericGlobalType(getGlobalTypedPropertyDescriptorType(), [propertyType]);
        }
        function createIterableType(iteratedType) {
            return createTypeFromGenericGlobalType(getGlobalIterableType(/*reportErrors*/ true), [iteratedType]);
        }
        function createArrayType(elementType, readonly) {
            return createTypeFromGenericGlobalType(readonly ? globalReadonlyArrayType : globalArrayType, [elementType]);
        }
        function getTupleElementFlags(node) {
            switch (node.kind) {
                case 187 /* SyntaxKind.OptionalType */:
                    return 2 /* ElementFlags.Optional */;
                case 188 /* SyntaxKind.RestType */:
                    return getRestTypeElementFlags(node);
                case 199 /* SyntaxKind.NamedTupleMember */:
                    return node.questionToken ? 2 /* ElementFlags.Optional */ :
                        node.dotDotDotToken ? getRestTypeElementFlags(node) :
                            1 /* ElementFlags.Required */;
                default:
                    return 1 /* ElementFlags.Required */;
            }
        }
        function getRestTypeElementFlags(node) {
            return getArrayElementTypeNode(node.type) ? 4 /* ElementFlags.Rest */ : 8 /* ElementFlags.Variadic */;
        }
        function getArrayOrTupleTargetType(node) {
            var readonly = isReadonlyTypeOperator(node.parent);
            var elementType = getArrayElementTypeNode(node);
            if (elementType) {
                return readonly ? globalReadonlyArrayType : globalArrayType;
            }
            var elementFlags = ts.map(node.elements, getTupleElementFlags);
            var missingName = ts.some(node.elements, function (e) { return e.kind !== 199 /* SyntaxKind.NamedTupleMember */; });
            return getTupleTargetType(elementFlags, readonly, /*associatedNames*/ missingName ? undefined : node.elements);
        }
        // Return true if the given type reference node is directly aliased or if it needs to be deferred
        // because it is possibly contained in a circular chain of eagerly resolved types.
        function isDeferredTypeReferenceNode(node, hasDefaultTypeArguments) {
            return !!getAliasSymbolForTypeNode(node) || isResolvedByTypeAlias(node) && (node.kind === 185 /* SyntaxKind.ArrayType */ ? mayResolveTypeAlias(node.elementType) :
                node.kind === 186 /* SyntaxKind.TupleType */ ? ts.some(node.elements, mayResolveTypeAlias) :
                    hasDefaultTypeArguments || ts.some(node.typeArguments, mayResolveTypeAlias));
        }
        // Return true when the given node is transitively contained in type constructs that eagerly
        // resolve their constituent types. We include SyntaxKind.TypeReference because type arguments
        // of type aliases are eagerly resolved.
        function isResolvedByTypeAlias(node) {
            var parent = node.parent;
            switch (parent.kind) {
                case 193 /* SyntaxKind.ParenthesizedType */:
                case 199 /* SyntaxKind.NamedTupleMember */:
                case 180 /* SyntaxKind.TypeReference */:
                case 189 /* SyntaxKind.UnionType */:
                case 190 /* SyntaxKind.IntersectionType */:
                case 196 /* SyntaxKind.IndexedAccessType */:
                case 191 /* SyntaxKind.ConditionalType */:
                case 195 /* SyntaxKind.TypeOperator */:
                case 185 /* SyntaxKind.ArrayType */:
                case 186 /* SyntaxKind.TupleType */:
                    return isResolvedByTypeAlias(parent);
                case 262 /* SyntaxKind.TypeAliasDeclaration */:
                    return true;
            }
            return false;
        }
        // Return true if resolving the given node (i.e. getTypeFromTypeNode) possibly causes resolution
        // of a type alias.
        function mayResolveTypeAlias(node) {
            switch (node.kind) {
                case 180 /* SyntaxKind.TypeReference */:
                    return isJSDocTypeReference(node) || !!(resolveTypeReferenceName(node, 788968 /* SymbolFlags.Type */).flags & 524288 /* SymbolFlags.TypeAlias */);
                case 183 /* SyntaxKind.TypeQuery */:
                    return true;
                case 195 /* SyntaxKind.TypeOperator */:
                    return node.operator !== 156 /* SyntaxKind.UniqueKeyword */ && mayResolveTypeAlias(node.type);
                case 193 /* SyntaxKind.ParenthesizedType */:
                case 187 /* SyntaxKind.OptionalType */:
                case 199 /* SyntaxKind.NamedTupleMember */:
                case 319 /* SyntaxKind.JSDocOptionalType */:
                case 317 /* SyntaxKind.JSDocNullableType */:
                case 318 /* SyntaxKind.JSDocNonNullableType */:
                case 312 /* SyntaxKind.JSDocTypeExpression */:
                    return mayResolveTypeAlias(node.type);
                case 188 /* SyntaxKind.RestType */:
                    return node.type.kind !== 185 /* SyntaxKind.ArrayType */ || mayResolveTypeAlias(node.type.elementType);
                case 189 /* SyntaxKind.UnionType */:
                case 190 /* SyntaxKind.IntersectionType */:
                    return ts.some(node.types, mayResolveTypeAlias);
                case 196 /* SyntaxKind.IndexedAccessType */:
                    return mayResolveTypeAlias(node.objectType) || mayResolveTypeAlias(node.indexType);
                case 191 /* SyntaxKind.ConditionalType */:
                    return mayResolveTypeAlias(node.checkType) || mayResolveTypeAlias(node.extendsType) ||
                        mayResolveTypeAlias(node.trueType) || mayResolveTypeAlias(node.falseType);
            }
            return false;
        }
        function getTypeFromArrayOrTupleTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var target = getArrayOrTupleTargetType(node);
                if (target === emptyGenericType) {
                    links.resolvedType = emptyObjectType;
                }
                else if (!(node.kind === 186 /* SyntaxKind.TupleType */ && ts.some(node.elements, function (e) { return !!(getTupleElementFlags(e) & 8 /* ElementFlags.Variadic */); })) && isDeferredTypeReferenceNode(node)) {
                    links.resolvedType = node.kind === 186 /* SyntaxKind.TupleType */ && node.elements.length === 0 ? target :
                        createDeferredTypeReference(target, node, /*mapper*/ undefined);
                }
                else {
                    var elementTypes = node.kind === 185 /* SyntaxKind.ArrayType */ ? [getTypeFromTypeNode(node.elementType)] : ts.map(node.elements, getTypeFromTypeNode);
                    links.resolvedType = createNormalizedTypeReference(target, elementTypes);
                }
            }
            return links.resolvedType;
        }
        function isReadonlyTypeOperator(node) {
            return ts.isTypeOperatorNode(node) && node.operator === 146 /* SyntaxKind.ReadonlyKeyword */;
        }
        function createTupleType(elementTypes, elementFlags, readonly, namedMemberDeclarations) {
            if (readonly === void 0) { readonly = false; }
            var tupleTarget = getTupleTargetType(elementFlags || ts.map(elementTypes, function (_) { return 1 /* ElementFlags.Required */; }), readonly, namedMemberDeclarations);
            return tupleTarget === emptyGenericType ? emptyObjectType :
                elementTypes.length ? createNormalizedTypeReference(tupleTarget, elementTypes) :
                    tupleTarget;
        }
        function getTupleTargetType(elementFlags, readonly, namedMemberDeclarations) {
            if (elementFlags.length === 1 && elementFlags[0] & 4 /* ElementFlags.Rest */) {
                // [...X[]] is equivalent to just X[]
                return readonly ? globalReadonlyArrayType : globalArrayType;
            }
            var key = ts.map(elementFlags, function (f) { return f & 1 /* ElementFlags.Required */ ? "#" : f & 2 /* ElementFlags.Optional */ ? "?" : f & 4 /* ElementFlags.Rest */ ? "." : "*"; }).join() +
                (readonly ? "R" : "") +
                (namedMemberDeclarations && namedMemberDeclarations.length ? "," + ts.map(namedMemberDeclarations, getNodeId).join(",") : "");
            var type = tupleTypes.get(key);
            if (!type) {
                tupleTypes.set(key, type = createTupleTargetType(elementFlags, readonly, namedMemberDeclarations));
            }
            return type;
        }
        // We represent tuple types as type references to synthesized generic interface types created by
        // this function. The types are of the form:
        //
        //   interface Tuple<T0, T1, T2, ...> extends Array<T0 | T1 | T2 | ...> { 0: T0, 1: T1, 2: T2, ... }
        //
        // Note that the generic type created by this function has no symbol associated with it. The same
        // is true for each of the synthesized type parameters.
        function createTupleTargetType(elementFlags, readonly, namedMemberDeclarations) {
            var arity = elementFlags.length;
            var minLength = ts.countWhere(elementFlags, function (f) { return !!(f & (1 /* ElementFlags.Required */ | 8 /* ElementFlags.Variadic */)); });
            var typeParameters;
            var properties = [];
            var combinedFlags = 0;
            if (arity) {
                typeParameters = new Array(arity);
                for (var i = 0; i < arity; i++) {
                    var typeParameter = typeParameters[i] = createTypeParameter();
                    var flags = elementFlags[i];
                    combinedFlags |= flags;
                    if (!(combinedFlags & 12 /* ElementFlags.Variable */)) {
                        var property = createSymbol(4 /* SymbolFlags.Property */ | (flags & 2 /* ElementFlags.Optional */ ? 16777216 /* SymbolFlags.Optional */ : 0), "" + i, readonly ? 8 /* CheckFlags.Readonly */ : 0);
                        property.tupleLabelDeclaration = namedMemberDeclarations === null || namedMemberDeclarations === void 0 ? void 0 : namedMemberDeclarations[i];
                        property.type = typeParameter;
                        properties.push(property);
                    }
                }
            }
            var fixedLength = properties.length;
            var lengthSymbol = createSymbol(4 /* SymbolFlags.Property */, "length", readonly ? 8 /* CheckFlags.Readonly */ : 0);
            if (combinedFlags & 12 /* ElementFlags.Variable */) {
                lengthSymbol.type = numberType;
            }
            else {
                var literalTypes = [];
                for (var i = minLength; i <= arity; i++)
                    literalTypes.push(getNumberLiteralType(i));
                lengthSymbol.type = getUnionType(literalTypes);
            }
            properties.push(lengthSymbol);
            var type = createObjectType(8 /* ObjectFlags.Tuple */ | 4 /* ObjectFlags.Reference */);
            type.typeParameters = typeParameters;
            type.outerTypeParameters = undefined;
            type.localTypeParameters = typeParameters;
            type.instantiations = new ts.Map();
            type.instantiations.set(getTypeListId(type.typeParameters), type);
            type.target = type;
            type.resolvedTypeArguments = type.typeParameters;
            type.thisType = createTypeParameter();
            type.thisType.isThisType = true;
            type.thisType.constraint = type;
            type.declaredProperties = properties;
            type.declaredCallSignatures = ts.emptyArray;
            type.declaredConstructSignatures = ts.emptyArray;
            type.declaredIndexInfos = ts.emptyArray;
            type.elementFlags = elementFlags;
            type.minLength = minLength;
            type.fixedLength = fixedLength;
            type.hasRestElement = !!(combinedFlags & 12 /* ElementFlags.Variable */);
            type.combinedFlags = combinedFlags;
            type.readonly = readonly;
            type.labeledElementDeclarations = namedMemberDeclarations;
            return type;
        }
        function createNormalizedTypeReference(target, typeArguments) {
            return target.objectFlags & 8 /* ObjectFlags.Tuple */ ? createNormalizedTupleType(target, typeArguments) : createTypeReference(target, typeArguments);
        }
        function createNormalizedTupleType(target, elementTypes) {
            var _a, _b, _c;
            if (!(target.combinedFlags & 14 /* ElementFlags.NonRequired */)) {
                // No need to normalize when we only have regular required elements
                return createTypeReference(target, elementTypes);
            }
            if (target.combinedFlags & 8 /* ElementFlags.Variadic */) {
                // Transform [A, ...(X | Y | Z)] into [A, ...X] | [A, ...Y] | [A, ...Z]
                var unionIndex_1 = ts.findIndex(elementTypes, function (t, i) { return !!(target.elementFlags[i] & 8 /* ElementFlags.Variadic */ && t.flags & (131072 /* TypeFlags.Never */ | 1048576 /* TypeFlags.Union */)); });
                if (unionIndex_1 >= 0) {
                    return checkCrossProductUnion(ts.map(elementTypes, function (t, i) { return target.elementFlags[i] & 8 /* ElementFlags.Variadic */ ? t : unknownType; })) ?
                        mapType(elementTypes[unionIndex_1], function (t) { return createNormalizedTupleType(target, ts.replaceElement(elementTypes, unionIndex_1, t)); }) :
                        errorType;
                }
            }
            // We have optional, rest, or variadic elements that may need normalizing. Normalization ensures that all variadic
            // elements are generic and that the tuple type has one of the following layouts, disregarding variadic elements:
            // (1) Zero or more required elements, followed by zero or more optional elements, followed by zero or one rest element.
            // (2) Zero or more required elements, followed by a rest element, followed by zero or more required elements.
            // In either layout, zero or more generic variadic elements may be present at any location.
            var expandedTypes = [];
            var expandedFlags = [];
            var expandedDeclarations = [];
            var lastRequiredIndex = -1;
            var firstRestIndex = -1;
            var lastOptionalOrRestIndex = -1;
            var _loop_17 = function (i) {
                var type = elementTypes[i];
                var flags = target.elementFlags[i];
                if (flags & 8 /* ElementFlags.Variadic */) {
                    if (type.flags & 58982400 /* TypeFlags.InstantiableNonPrimitive */ || isGenericMappedType(type)) {
                        // Generic variadic elements stay as they are.
                        addElement(type, 8 /* ElementFlags.Variadic */, (_a = target.labeledElementDeclarations) === null || _a === void 0 ? void 0 : _a[i]);
                    }
                    else if (isTupleType(type)) {
                        var elements = getTypeArguments(type);
                        if (elements.length + expandedTypes.length >= 10000) {
                            error(currentNode, ts.isPartOfTypeNode(currentNode)
                                ? ts.Diagnostics.Type_produces_a_tuple_type_that_is_too_large_to_represent
                                : ts.Diagnostics.Expression_produces_a_tuple_type_that_is_too_large_to_represent);
                            return { value: errorType };
                        }
                        // Spread variadic elements with tuple types into the resulting tuple.
                        ts.forEach(elements, function (t, n) { var _a; return addElement(t, type.target.elementFlags[n], (_a = type.target.labeledElementDeclarations) === null || _a === void 0 ? void 0 : _a[n]); });
                    }
                    else {
                        // Treat everything else as an array type and create a rest element.
                        addElement(isArrayLikeType(type) && getIndexTypeOfType(type, numberType) || errorType, 4 /* ElementFlags.Rest */, (_b = target.labeledElementDeclarations) === null || _b === void 0 ? void 0 : _b[i]);
                    }
                }
                else {
                    // Copy other element kinds with no change.
                    addElement(type, flags, (_c = target.labeledElementDeclarations) === null || _c === void 0 ? void 0 : _c[i]);
                }
            };
            for (var i = 0; i < elementTypes.length; i++) {
                var state_5 = _loop_17(i);
                if (typeof state_5 === "object")
                    return state_5.value;
            }
            // Turn optional elements preceding the last required element into required elements
            for (var i = 0; i < lastRequiredIndex; i++) {
                if (expandedFlags[i] & 2 /* ElementFlags.Optional */)
                    expandedFlags[i] = 1 /* ElementFlags.Required */;
            }
            if (firstRestIndex >= 0 && firstRestIndex < lastOptionalOrRestIndex) {
                // Turn elements between first rest and last optional/rest into a single rest element
                expandedTypes[firstRestIndex] = getUnionType(ts.sameMap(expandedTypes.slice(firstRestIndex, lastOptionalOrRestIndex + 1), function (t, i) { return expandedFlags[firstRestIndex + i] & 8 /* ElementFlags.Variadic */ ? getIndexedAccessType(t, numberType) : t; }));
                expandedTypes.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
                expandedFlags.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
                expandedDeclarations === null || expandedDeclarations === void 0 ? void 0 : expandedDeclarations.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
            }
            var tupleTarget = getTupleTargetType(expandedFlags, target.readonly, expandedDeclarations);
            return tupleTarget === emptyGenericType ? emptyObjectType :
                expandedFlags.length ? createTypeReference(tupleTarget, expandedTypes) :
                    tupleTarget;
            function addElement(type, flags, declaration) {
                if (flags & 1 /* ElementFlags.Required */) {
                    lastRequiredIndex = expandedFlags.length;
                }
                if (flags & 4 /* ElementFlags.Rest */ && firstRestIndex < 0) {
                    firstRestIndex = expandedFlags.length;
                }
                if (flags & (2 /* ElementFlags.Optional */ | 4 /* ElementFlags.Rest */)) {
                    lastOptionalOrRestIndex = expandedFlags.length;
                }
                expandedTypes.push(flags & 2 /* ElementFlags.Optional */ ? addOptionality(type, /*isProperty*/ true) : type);
                expandedFlags.push(flags);
                if (expandedDeclarations && declaration) {
                    expandedDeclarations.push(declaration);
                }
                else {
                    expandedDeclarations = undefined;
                }
            }
        }
        function sliceTupleType(type, index, endSkipCount) {
            if (endSkipCount === void 0) { endSkipCount = 0; }
            var target = type.target;
            var endIndex = getTypeReferenceArity(type) - endSkipCount;
            return index > target.fixedLength ? getRestArrayTypeOfTupleType(type) || createTupleType(ts.emptyArray) :
                createTupleType(getTypeArguments(type).slice(index, endIndex), target.elementFlags.slice(index, endIndex), 
                /*readonly*/ false, target.labeledElementDeclarations && target.labeledElementDeclarations.slice(index, endIndex));
        }
        function getKnownKeysOfTupleType(type) {
            return getUnionType(ts.append(ts.arrayOf(type.target.fixedLength, function (i) { return getStringLiteralType("" + i); }), getIndexType(type.target.readonly ? globalReadonlyArrayType : globalArrayType)));
        }
        // Return count of starting consecutive tuple elements of the given kind(s)
        function getStartElementCount(type, flags) {
            var index = ts.findIndex(type.elementFlags, function (f) { return !(f & flags); });
            return index >= 0 ? index : type.elementFlags.length;
        }
        // Return count of ending consecutive tuple elements of the given kind(s)
        function getEndElementCount(type, flags) {
            return type.elementFlags.length - ts.findLastIndex(type.elementFlags, function (f) { return !(f & flags); }) - 1;
        }
        function getTypeFromOptionalTypeNode(node) {
            return addOptionality(getTypeFromTypeNode(node.type), /*isProperty*/ true);
        }
        function getTypeId(type) {
            return type.id;
        }
        function containsType(types, type) {
            return ts.binarySearch(types, type, getTypeId, ts.compareValues) >= 0;
        }
        function insertType(types, type) {
            var index = ts.binarySearch(types, type, getTypeId, ts.compareValues);
            if (index < 0) {
                types.splice(~index, 0, type);
                return true;
            }
            return false;
        }
        function addTypeToUnion(typeSet, includes, type) {
            var flags = type.flags;
            if (flags & 1048576 /* TypeFlags.Union */) {
                return addTypesToUnion(typeSet, includes | (isNamedUnionType(type) ? 1048576 /* TypeFlags.Union */ : 0), type.types);
            }
            // We ignore 'never' types in unions
            if (!(flags & 131072 /* TypeFlags.Never */)) {
                includes |= flags & 205258751 /* TypeFlags.IncludesMask */;
                if (flags & 465829888 /* TypeFlags.Instantiable */)
                    includes |= 33554432 /* TypeFlags.IncludesInstantiable */;
                if (type === wildcardType)
                    includes |= 8388608 /* TypeFlags.IncludesWildcard */;
                if (!strictNullChecks && flags & 98304 /* TypeFlags.Nullable */) {
                    if (!(ts.getObjectFlags(type) & 65536 /* ObjectFlags.ContainsWideningType */))
                        includes |= 4194304 /* TypeFlags.IncludesNonWideningType */;
                }
                else {
                    var len = typeSet.length;
                    var index = len && type.id > typeSet[len - 1].id ? ~len : ts.binarySearch(typeSet, type, getTypeId, ts.compareValues);
                    if (index < 0) {
                        typeSet.splice(~index, 0, type);
                    }
                }
            }
            return includes;
        }
        // Add the given types to the given type set. Order is preserved, duplicates are removed,
        // and nested types of the given kind are flattened into the set.
        function addTypesToUnion(typeSet, includes, types) {
            for (var _i = 0, types_9 = types; _i < types_9.length; _i++) {
                var type = types_9[_i];
                includes = addTypeToUnion(typeSet, includes, type);
            }
            return includes;
        }
        function removeSubtypes(types, hasObjectTypes) {
            // [] and [T] immediately reduce to [] and [T] respectively
            if (types.length < 2) {
                return types;
            }
            var id = getTypeListId(types);
            var match = subtypeReductionCache.get(id);
            if (match) {
                return match;
            }
            // We assume that redundant primitive types have already been removed from the types array and that there
            // are no any and unknown types in the array. Thus, the only possible supertypes for primitive types are empty
            // object types, and if none of those are present we can exclude primitive types from the subtype check.
            var hasEmptyObject = hasObjectTypes && ts.some(types, function (t) { return !!(t.flags & 524288 /* TypeFlags.Object */) && !isGenericMappedType(t) && isEmptyResolvedType(resolveStructuredTypeMembers(t)); });
            var len = types.length;
            var i = len;
            var count = 0;
            while (i > 0) {
                i--;
                var source = types[i];
                if (hasEmptyObject || source.flags & 469499904 /* TypeFlags.StructuredOrInstantiable */) {
                    // Find the first property with a unit type, if any. When constituents have a property by the same name
                    // but of a different unit type, we can quickly disqualify them from subtype checks. This helps subtype
                    // reduction of large discriminated union types.
                    var keyProperty = source.flags & (524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */ | 58982400 /* TypeFlags.InstantiableNonPrimitive */) ?
                        ts.find(getPropertiesOfType(source), function (p) { return isUnitType(getTypeOfSymbol(p)); }) :
                        undefined;
                    var keyPropertyType = keyProperty && getRegularTypeOfLiteralType(getTypeOfSymbol(keyProperty));
                    for (var _i = 0, types_10 = types; _i < types_10.length; _i++) {
                        var target = types_10[_i];
                        if (source !== target) {
                            if (count === 100000) {
                                // After 100000 subtype checks we estimate the remaining amount of work by assuming the
                                // same ratio of checks per element. If the estimated number of remaining type checks is
                                // greater than 1M we deem the union type too complex to represent. This for example
                                // caps union types at 1000 unique object types.
                                var estimatedCount = (count / (len - i)) * len;
                                if (estimatedCount > 1000000) {
                                    ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.instant("checkTypes" /* tracing.Phase.CheckTypes */, "removeSubtypes_DepthLimit", { typeIds: types.map(function (t) { return t.id; }) });
                                    error(currentNode, ts.Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);
                                    return undefined;
                                }
                            }
                            count++;
                            if (keyProperty && target.flags & (524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */ | 58982400 /* TypeFlags.InstantiableNonPrimitive */)) {
                                var t = getTypeOfPropertyOfType(target, keyProperty.escapedName);
                                if (t && isUnitType(t) && getRegularTypeOfLiteralType(t) !== keyPropertyType) {
                                    continue;
                                }
                            }
                            if (isTypeRelatedTo(source, target, strictSubtypeRelation) && (!(ts.getObjectFlags(getTargetType(source)) & 1 /* ObjectFlags.Class */) ||
                                !(ts.getObjectFlags(getTargetType(target)) & 1 /* ObjectFlags.Class */) ||
                                isTypeDerivedFrom(source, target))) {
                                ts.orderedRemoveItemAt(types, i);
                                break;
                            }
                        }
                    }
                }
            }
            subtypeReductionCache.set(id, types);
            return types;
        }
        function removeRedundantLiteralTypes(types, includes, reduceVoidUndefined) {
            var i = types.length;
            while (i > 0) {
                i--;
                var t = types[i];
                var flags = t.flags;
                var remove = flags & (128 /* TypeFlags.StringLiteral */ | 134217728 /* TypeFlags.TemplateLiteral */ | 268435456 /* TypeFlags.StringMapping */) && includes & 4 /* TypeFlags.String */ ||
                    flags & 256 /* TypeFlags.NumberLiteral */ && includes & 8 /* TypeFlags.Number */ ||
                    flags & 2048 /* TypeFlags.BigIntLiteral */ && includes & 64 /* TypeFlags.BigInt */ ||
                    flags & 8192 /* TypeFlags.UniqueESSymbol */ && includes & 4096 /* TypeFlags.ESSymbol */ ||
                    reduceVoidUndefined && flags & 32768 /* TypeFlags.Undefined */ && includes & 16384 /* TypeFlags.Void */ ||
                    isFreshLiteralType(t) && containsType(types, t.regularType);
                if (remove) {
                    ts.orderedRemoveItemAt(types, i);
                }
            }
        }
        function removeStringLiteralsMatchedByTemplateLiterals(types) {
            var templates = ts.filter(types, isPatternLiteralType);
            if (templates.length) {
                var i = types.length;
                var _loop_18 = function () {
                    i--;
                    var t = types[i];
                    if (t.flags & 128 /* TypeFlags.StringLiteral */ && ts.some(templates, function (template) { return isTypeMatchedByTemplateLiteralType(t, template); })) {
                        ts.orderedRemoveItemAt(types, i);
                    }
                };
                while (i > 0) {
                    _loop_18();
                }
            }
        }
        function isNamedUnionType(type) {
            return !!(type.flags & 1048576 /* TypeFlags.Union */ && (type.aliasSymbol || type.origin));
        }
        function addNamedUnions(namedUnions, types) {
            for (var _i = 0, types_11 = types; _i < types_11.length; _i++) {
                var t = types_11[_i];
                if (t.flags & 1048576 /* TypeFlags.Union */) {
                    var origin = t.origin;
                    if (t.aliasSymbol || origin && !(origin.flags & 1048576 /* TypeFlags.Union */)) {
                        ts.pushIfUnique(namedUnions, t);
                    }
                    else if (origin && origin.flags & 1048576 /* TypeFlags.Union */) {
                        addNamedUnions(namedUnions, origin.types);
                    }
                }
            }
        }
        function createOriginUnionOrIntersectionType(flags, types) {
            var result = createOriginType(flags);
            result.types = types;
            return result;
        }
        // We sort and deduplicate the constituent types based on object identity. If the subtypeReduction
        // flag is specified we also reduce the constituent type set to only include types that aren't subtypes
        // of other types. Subtype reduction is expensive for large union types and is possible only when union
        // types are known not to circularly reference themselves (as is the case with union types created by
        // expression constructs such as array literals and the || and ?: operators). Named types can
        // circularly reference themselves and therefore cannot be subtype reduced during their declaration.
        // For example, "type Item = string | (() => Item" is a named type that circularly references itself.
        function getUnionType(types, unionReduction, aliasSymbol, aliasTypeArguments, origin) {
            if (unionReduction === void 0) { unionReduction = 1 /* UnionReduction.Literal */; }
            if (types.length === 0) {
                return neverType;
            }
            if (types.length === 1) {
                return types[0];
            }
            var typeSet = [];
            var includes = addTypesToUnion(typeSet, 0, types);
            if (unionReduction !== 0 /* UnionReduction.None */) {
                if (includes & 3 /* TypeFlags.AnyOrUnknown */) {
                    return includes & 1 /* TypeFlags.Any */ ?
                        includes & 8388608 /* TypeFlags.IncludesWildcard */ ? wildcardType : anyType :
                        includes & 65536 /* TypeFlags.Null */ || containsType(typeSet, unknownType) ? unknownType : nonNullUnknownType;
                }
                if (exactOptionalPropertyTypes && includes & 32768 /* TypeFlags.Undefined */) {
                    var missingIndex = ts.binarySearch(typeSet, missingType, getTypeId, ts.compareValues);
                    if (missingIndex >= 0 && containsType(typeSet, undefinedType)) {
                        ts.orderedRemoveItemAt(typeSet, missingIndex);
                    }
                }
                if (includes & (2944 /* TypeFlags.Literal */ | 8192 /* TypeFlags.UniqueESSymbol */ | 134217728 /* TypeFlags.TemplateLiteral */ | 268435456 /* TypeFlags.StringMapping */) || includes & 16384 /* TypeFlags.Void */ && includes & 32768 /* TypeFlags.Undefined */) {
                    removeRedundantLiteralTypes(typeSet, includes, !!(unionReduction & 2 /* UnionReduction.Subtype */));
                }
                if (includes & 128 /* TypeFlags.StringLiteral */ && includes & 134217728 /* TypeFlags.TemplateLiteral */) {
                    removeStringLiteralsMatchedByTemplateLiterals(typeSet);
                }
                if (unionReduction === 2 /* UnionReduction.Subtype */) {
                    typeSet = removeSubtypes(typeSet, !!(includes & 524288 /* TypeFlags.Object */));
                    if (!typeSet) {
                        return errorType;
                    }
                }
                if (typeSet.length === 0) {
                    return includes & 65536 /* TypeFlags.Null */ ? includes & 4194304 /* TypeFlags.IncludesNonWideningType */ ? nullType : nullWideningType :
                        includes & 32768 /* TypeFlags.Undefined */ ? includes & 4194304 /* TypeFlags.IncludesNonWideningType */ ? undefinedType : undefinedWideningType :
                            neverType;
                }
            }
            if (!origin && includes & 1048576 /* TypeFlags.Union */) {
                var namedUnions = [];
                addNamedUnions(namedUnions, types);
                var reducedTypes = [];
                var _loop_19 = function (t) {
                    if (!ts.some(namedUnions, function (union) { return containsType(union.types, t); })) {
                        reducedTypes.push(t);
                    }
                };
                for (var _i = 0, typeSet_1 = typeSet; _i < typeSet_1.length; _i++) {
                    var t = typeSet_1[_i];
                    _loop_19(t);
                }
                if (!aliasSymbol && namedUnions.length === 1 && reducedTypes.length === 0) {
                    return namedUnions[0];
                }
                // We create a denormalized origin type only when the union was created from one or more named unions
                // (unions with alias symbols or origins) and when there is no overlap between those named unions.
                var namedTypesCount = ts.reduceLeft(namedUnions, function (sum, union) { return sum + union.types.length; }, 0);
                if (namedTypesCount + reducedTypes.length === typeSet.length) {
                    for (var _a = 0, namedUnions_1 = namedUnions; _a < namedUnions_1.length; _a++) {
                        var t = namedUnions_1[_a];
                        insertType(reducedTypes, t);
                    }
                    origin = createOriginUnionOrIntersectionType(1048576 /* TypeFlags.Union */, reducedTypes);
                }
            }
            var objectFlags = (includes & 36323363 /* TypeFlags.NotPrimitiveUnion */ ? 0 : 32768 /* ObjectFlags.PrimitiveUnion */) |
                (includes & 2097152 /* TypeFlags.Intersection */ ? 16777216 /* ObjectFlags.ContainsIntersections */ : 0);
            return getUnionTypeFromSortedList(typeSet, objectFlags, aliasSymbol, aliasTypeArguments, origin);
        }
        function getUnionOrIntersectionTypePredicate(signatures, kind) {
            var first;
            var types = [];
            for (var _i = 0, signatures_6 = signatures; _i < signatures_6.length; _i++) {
                var sig = signatures_6[_i];
                var pred = getTypePredicateOfSignature(sig);
                if (!pred || pred.kind === 2 /* TypePredicateKind.AssertsThis */ || pred.kind === 3 /* TypePredicateKind.AssertsIdentifier */) {
                    if (kind !== 2097152 /* TypeFlags.Intersection */) {
                        continue;
                    }
                    else {
                        return; // intersections demand all members be type predicates for the result to have a predicate
                    }
                }
                if (first) {
                    if (!typePredicateKindsMatch(first, pred)) {
                        // No common type predicate.
                        return undefined;
                    }
                }
                else {
                    first = pred;
                }
                types.push(pred.type);
            }
            if (!first) {
                // No signatures had a type predicate.
                return undefined;
            }
            var compositeType = getUnionOrIntersectionType(types, kind);
            return createTypePredicate(first.kind, first.parameterName, first.parameterIndex, compositeType);
        }
        function typePredicateKindsMatch(a, b) {
            return a.kind === b.kind && a.parameterIndex === b.parameterIndex;
        }
        // This function assumes the constituent type list is sorted and deduplicated.
        function getUnionTypeFromSortedList(types, objectFlags, aliasSymbol, aliasTypeArguments, origin) {
            if (types.length === 0) {
                return neverType;
            }
            if (types.length === 1) {
                return types[0];
            }
            var typeKey = !origin ? getTypeListId(types) :
                origin.flags & 1048576 /* TypeFlags.Union */ ? "|".concat(getTypeListId(origin.types)) :
                    origin.flags & 2097152 /* TypeFlags.Intersection */ ? "&".concat(getTypeListId(origin.types)) :
                        "#".concat(origin.type.id, "|").concat(getTypeListId(types)); // origin type id alone is insufficient, as `keyof x` may resolve to multiple WIP values while `x` is still resolving
            var id = typeKey + getAliasId(aliasSymbol, aliasTypeArguments);
            var type = unionTypes.get(id);
            if (!type) {
                type = createType(1048576 /* TypeFlags.Union */);
                type.objectFlags = objectFlags | getPropagatingFlagsOfTypes(types, /*excludeKinds*/ 98304 /* TypeFlags.Nullable */);
                type.types = types;
                type.origin = origin;
                type.aliasSymbol = aliasSymbol;
                type.aliasTypeArguments = aliasTypeArguments;
                if (types.length === 2 && types[0].flags & 512 /* TypeFlags.BooleanLiteral */ && types[1].flags & 512 /* TypeFlags.BooleanLiteral */) {
                    type.flags |= 16 /* TypeFlags.Boolean */;
                    type.intrinsicName = "boolean";
                }
                unionTypes.set(id, type);
            }
            return type;
        }
        function getTypeFromUnionTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                links.resolvedType = getUnionType(ts.map(node.types, getTypeFromTypeNode), 1 /* UnionReduction.Literal */, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol));
            }
            return links.resolvedType;
        }
        function addTypeToIntersection(typeSet, includes, type) {
            var flags = type.flags;
            if (flags & 2097152 /* TypeFlags.Intersection */) {
                return addTypesToIntersection(typeSet, includes, type.types);
            }
            if (isEmptyAnonymousObjectType(type)) {
                if (!(includes & 16777216 /* TypeFlags.IncludesEmptyObject */)) {
                    includes |= 16777216 /* TypeFlags.IncludesEmptyObject */;
                    typeSet.set(type.id.toString(), type);
                }
            }
            else {
                if (flags & 3 /* TypeFlags.AnyOrUnknown */) {
                    if (type === wildcardType)
                        includes |= 8388608 /* TypeFlags.IncludesWildcard */;
                }
                else if (strictNullChecks || !(flags & 98304 /* TypeFlags.Nullable */)) {
                    if (exactOptionalPropertyTypes && type === missingType) {
                        includes |= 262144 /* TypeFlags.IncludesMissingType */;
                        type = undefinedType;
                    }
                    if (!typeSet.has(type.id.toString())) {
                        if (type.flags & 109440 /* TypeFlags.Unit */ && includes & 109440 /* TypeFlags.Unit */) {
                            // We have seen two distinct unit types which means we should reduce to an
                            // empty intersection. Adding TypeFlags.NonPrimitive causes that to happen.
                            includes |= 67108864 /* TypeFlags.NonPrimitive */;
                        }
                        typeSet.set(type.id.toString(), type);
                    }
                }
                includes |= flags & 205258751 /* TypeFlags.IncludesMask */;
            }
            return includes;
        }
        // Add the given types to the given type set. Order is preserved, freshness is removed from literal
        // types, duplicates are removed, and nested types of the given kind are flattened into the set.
        function addTypesToIntersection(typeSet, includes, types) {
            for (var _i = 0, types_12 = types; _i < types_12.length; _i++) {
                var type = types_12[_i];
                includes = addTypeToIntersection(typeSet, includes, getRegularTypeOfLiteralType(type));
            }
            return includes;
        }
        function removeRedundantSupertypes(types, includes) {
            var i = types.length;
            while (i > 0) {
                i--;
                var t = types[i];
                var remove = t.flags & 4 /* TypeFlags.String */ && includes & (128 /* TypeFlags.StringLiteral */ | 134217728 /* TypeFlags.TemplateLiteral */ | 268435456 /* TypeFlags.StringMapping */) ||
                    t.flags & 8 /* TypeFlags.Number */ && includes & 256 /* TypeFlags.NumberLiteral */ ||
                    t.flags & 64 /* TypeFlags.BigInt */ && includes & 2048 /* TypeFlags.BigIntLiteral */ ||
                    t.flags & 4096 /* TypeFlags.ESSymbol */ && includes & 8192 /* TypeFlags.UniqueESSymbol */ ||
                    t.flags & 16384 /* TypeFlags.Void */ && includes & 32768 /* TypeFlags.Undefined */ ||
                    isEmptyAnonymousObjectType(t) && includes & 470302716 /* TypeFlags.DefinitelyNonNullable */;
                if (remove) {
                    ts.orderedRemoveItemAt(types, i);
                }
            }
        }
        // Check that the given type has a match in every union. A given type is matched by
        // an identical type, and a literal type is additionally matched by its corresponding
        // primitive type.
        function eachUnionContains(unionTypes, type) {
            for (var _i = 0, unionTypes_1 = unionTypes; _i < unionTypes_1.length; _i++) {
                var u = unionTypes_1[_i];
                if (!containsType(u.types, type)) {
                    var primitive = type.flags & 128 /* TypeFlags.StringLiteral */ ? stringType :
                        type.flags & 256 /* TypeFlags.NumberLiteral */ ? numberType :
                            type.flags & 2048 /* TypeFlags.BigIntLiteral */ ? bigintType :
                                type.flags & 8192 /* TypeFlags.UniqueESSymbol */ ? esSymbolType :
                                    undefined;
                    if (!primitive || !containsType(u.types, primitive)) {
                        return false;
                    }
                }
            }
            return true;
        }
        /**
         * Returns `true` if the intersection of the template literals and string literals is the empty set, eg `get${string}` & "setX", and should reduce to `never`
         */
        function extractRedundantTemplateLiterals(types) {
            var i = types.length;
            var literals = ts.filter(types, function (t) { return !!(t.flags & 128 /* TypeFlags.StringLiteral */); });
            while (i > 0) {
                i--;
                var t = types[i];
                if (!(t.flags & 134217728 /* TypeFlags.TemplateLiteral */))
                    continue;
                for (var _i = 0, literals_1 = literals; _i < literals_1.length; _i++) {
                    var t2 = literals_1[_i];
                    if (isTypeSubtypeOf(t2, t)) {
                        // eg, ``get${T}` & "getX"` is just `"getX"`
                        ts.orderedRemoveItemAt(types, i);
                        break;
                    }
                    else if (isPatternLiteralType(t)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function eachIsUnionContaining(types, flag) {
            return ts.every(types, function (t) { return !!(t.flags & 1048576 /* TypeFlags.Union */) && ts.some(t.types, function (tt) { return !!(tt.flags & flag); }); });
        }
        function removeFromEach(types, flag) {
            for (var i = 0; i < types.length; i++) {
                types[i] = filterType(types[i], function (t) { return !(t.flags & flag); });
            }
        }
        // If the given list of types contains more than one union of primitive types, replace the
        // first with a union containing an intersection of those primitive types, then remove the
        // other unions and return true. Otherwise, do nothing and return false.
        function intersectUnionsOfPrimitiveTypes(types) {
            var unionTypes;
            var index = ts.findIndex(types, function (t) { return !!(ts.getObjectFlags(t) & 32768 /* ObjectFlags.PrimitiveUnion */); });
            if (index < 0) {
                return false;
            }
            var i = index + 1;
            // Remove all but the first union of primitive types and collect them in
            // the unionTypes array.
            while (i < types.length) {
                var t = types[i];
                if (ts.getObjectFlags(t) & 32768 /* ObjectFlags.PrimitiveUnion */) {
                    (unionTypes || (unionTypes = [types[index]])).push(t);
                    ts.orderedRemoveItemAt(types, i);
                }
                else {
                    i++;
                }
            }
            // Return false if there was only one union of primitive types
            if (!unionTypes) {
                return false;
            }
            // We have more than one union of primitive types, now intersect them. For each
            // type in each union we check if the type is matched in every union and if so
            // we include it in the result.
            var checked = [];
            var result = [];
            for (var _i = 0, unionTypes_2 = unionTypes; _i < unionTypes_2.length; _i++) {
                var u = unionTypes_2[_i];
                for (var _a = 0, _b = u.types; _a < _b.length; _a++) {
                    var t = _b[_a];
                    if (insertType(checked, t)) {
                        if (eachUnionContains(unionTypes, t)) {
                            insertType(result, t);
                        }
                    }
                }
            }
            // Finally replace the first union with the result
            types[index] = getUnionTypeFromSortedList(result, 32768 /* ObjectFlags.PrimitiveUnion */);
            return true;
        }
        function createIntersectionType(types, aliasSymbol, aliasTypeArguments) {
            var result = createType(2097152 /* TypeFlags.Intersection */);
            result.objectFlags = getPropagatingFlagsOfTypes(types, /*excludeKinds*/ 98304 /* TypeFlags.Nullable */);
            result.types = types;
            result.aliasSymbol = aliasSymbol;
            result.aliasTypeArguments = aliasTypeArguments;
            return result;
        }
        // We normalize combinations of intersection and union types based on the distributive property of the '&'
        // operator. Specifically, because X & (A | B) is equivalent to X & A | X & B, we can transform intersection
        // types with union type constituents into equivalent union types with intersection type constituents and
        // effectively ensure that union types are always at the top level in type representations.
        //
        // We do not perform structural deduplication on intersection types. Intersection types are created only by the &
        // type operator and we can't reduce those because we want to support recursive intersection types. For example,
        // a type alias of the form "type List<T> = T & { next: List<T> }" cannot be reduced during its declaration.
        // Also, unlike union types, the order of the constituent types is preserved in order that overload resolution
        // for intersections of types with signatures can be deterministic.
        function getIntersectionType(types, aliasSymbol, aliasTypeArguments, noSupertypeReduction) {
            var typeMembershipMap = new ts.Map();
            var includes = addTypesToIntersection(typeMembershipMap, 0, types);
            var typeSet = ts.arrayFrom(typeMembershipMap.values());
            // An intersection type is considered empty if it contains
            // the type never, or
            // more than one unit type or,
            // an object type and a nullable type (null or undefined), or
            // a string-like type and a type known to be non-string-like, or
            // a number-like type and a type known to be non-number-like, or
            // a symbol-like type and a type known to be non-symbol-like, or
            // a void-like type and a type known to be non-void-like, or
            // a non-primitive type and a type known to be primitive.
            if (includes & 131072 /* TypeFlags.Never */) {
                return ts.contains(typeSet, silentNeverType) ? silentNeverType : neverType;
            }
            if (strictNullChecks && includes & 98304 /* TypeFlags.Nullable */ && includes & (524288 /* TypeFlags.Object */ | 67108864 /* TypeFlags.NonPrimitive */ | 16777216 /* TypeFlags.IncludesEmptyObject */) ||
                includes & 67108864 /* TypeFlags.NonPrimitive */ && includes & (469892092 /* TypeFlags.DisjointDomains */ & ~67108864 /* TypeFlags.NonPrimitive */) ||
                includes & 402653316 /* TypeFlags.StringLike */ && includes & (469892092 /* TypeFlags.DisjointDomains */ & ~402653316 /* TypeFlags.StringLike */) ||
                includes & 296 /* TypeFlags.NumberLike */ && includes & (469892092 /* TypeFlags.DisjointDomains */ & ~296 /* TypeFlags.NumberLike */) ||
                includes & 2112 /* TypeFlags.BigIntLike */ && includes & (469892092 /* TypeFlags.DisjointDomains */ & ~2112 /* TypeFlags.BigIntLike */) ||
                includes & 12288 /* TypeFlags.ESSymbolLike */ && includes & (469892092 /* TypeFlags.DisjointDomains */ & ~12288 /* TypeFlags.ESSymbolLike */) ||
                includes & 49152 /* TypeFlags.VoidLike */ && includes & (469892092 /* TypeFlags.DisjointDomains */ & ~49152 /* TypeFlags.VoidLike */)) {
                return neverType;
            }
            if (includes & 134217728 /* TypeFlags.TemplateLiteral */ && includes & 128 /* TypeFlags.StringLiteral */ && extractRedundantTemplateLiterals(typeSet)) {
                return neverType;
            }
            if (includes & 1 /* TypeFlags.Any */) {
                return includes & 8388608 /* TypeFlags.IncludesWildcard */ ? wildcardType : anyType;
            }
            if (!strictNullChecks && includes & 98304 /* TypeFlags.Nullable */) {
                return includes & 16777216 /* TypeFlags.IncludesEmptyObject */ ? neverType : includes & 32768 /* TypeFlags.Undefined */ ? undefinedType : nullType;
            }
            if (includes & 4 /* TypeFlags.String */ && includes & (128 /* TypeFlags.StringLiteral */ | 134217728 /* TypeFlags.TemplateLiteral */ | 268435456 /* TypeFlags.StringMapping */) ||
                includes & 8 /* TypeFlags.Number */ && includes & 256 /* TypeFlags.NumberLiteral */ ||
                includes & 64 /* TypeFlags.BigInt */ && includes & 2048 /* TypeFlags.BigIntLiteral */ ||
                includes & 4096 /* TypeFlags.ESSymbol */ && includes & 8192 /* TypeFlags.UniqueESSymbol */ ||
                includes & 16384 /* TypeFlags.Void */ && includes & 32768 /* TypeFlags.Undefined */ ||
                includes & 16777216 /* TypeFlags.IncludesEmptyObject */ && includes & 470302716 /* TypeFlags.DefinitelyNonNullable */) {
                if (!noSupertypeReduction)
                    removeRedundantSupertypes(typeSet, includes);
            }
            if (includes & 262144 /* TypeFlags.IncludesMissingType */) {
                typeSet[typeSet.indexOf(undefinedType)] = missingType;
            }
            if (typeSet.length === 0) {
                return unknownType;
            }
            if (typeSet.length === 1) {
                return typeSet[0];
            }
            var id = getTypeListId(typeSet) + getAliasId(aliasSymbol, aliasTypeArguments);
            var result = intersectionTypes.get(id);
            if (!result) {
                if (includes & 1048576 /* TypeFlags.Union */) {
                    if (intersectUnionsOfPrimitiveTypes(typeSet)) {
                        // When the intersection creates a reduced set (which might mean that *all* union types have
                        // disappeared), we restart the operation to get a new set of combined flags. Once we have
                        // reduced we'll never reduce again, so this occurs at most once.
                        result = getIntersectionType(typeSet, aliasSymbol, aliasTypeArguments);
                    }
                    else if (eachIsUnionContaining(typeSet, 32768 /* TypeFlags.Undefined */)) {
                        var undefinedOrMissingType = exactOptionalPropertyTypes && ts.some(typeSet, function (t) { return containsType(t.types, missingType); }) ? missingType : undefinedType;
                        removeFromEach(typeSet, 32768 /* TypeFlags.Undefined */);
                        result = getUnionType([getIntersectionType(typeSet), undefinedOrMissingType], 1 /* UnionReduction.Literal */, aliasSymbol, aliasTypeArguments);
                    }
                    else if (eachIsUnionContaining(typeSet, 65536 /* TypeFlags.Null */)) {
                        removeFromEach(typeSet, 65536 /* TypeFlags.Null */);
                        result = getUnionType([getIntersectionType(typeSet), nullType], 1 /* UnionReduction.Literal */, aliasSymbol, aliasTypeArguments);
                    }
                    else {
                        // We are attempting to construct a type of the form X & (A | B) & (C | D). Transform this into a type of
                        // the form X & A & C | X & A & D | X & B & C | X & B & D. If the estimated size of the resulting union type
                        // exceeds 100000 constituents, report an error.
                        if (!checkCrossProductUnion(typeSet)) {
                            return errorType;
                        }
                        var constituents = getCrossProductIntersections(typeSet);
                        // We attach a denormalized origin type when at least one constituent of the cross-product union is an
                        // intersection (i.e. when the intersection didn't just reduce one or more unions to smaller unions) and
                        // the denormalized origin has fewer constituents than the union itself.
                        var origin = ts.some(constituents, function (t) { return !!(t.flags & 2097152 /* TypeFlags.Intersection */); }) && getConstituentCountOfTypes(constituents) > getConstituentCountOfTypes(typeSet) ? createOriginUnionOrIntersectionType(2097152 /* TypeFlags.Intersection */, typeSet) : undefined;
                        result = getUnionType(constituents, 1 /* UnionReduction.Literal */, aliasSymbol, aliasTypeArguments, origin);
                    }
                }
                else {
                    result = createIntersectionType(typeSet, aliasSymbol, aliasTypeArguments);
                }
                intersectionTypes.set(id, result);
            }
            return result;
        }
        function getCrossProductUnionSize(types) {
            return ts.reduceLeft(types, function (n, t) { return t.flags & 1048576 /* TypeFlags.Union */ ? n * t.types.length : t.flags & 131072 /* TypeFlags.Never */ ? 0 : n; }, 1);
        }
        function checkCrossProductUnion(types) {
            var size = getCrossProductUnionSize(types);
            if (size >= 100000) {
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.instant("checkTypes" /* tracing.Phase.CheckTypes */, "checkCrossProductUnion_DepthLimit", { typeIds: types.map(function (t) { return t.id; }), size: size });
                error(currentNode, ts.Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);
                return false;
            }
            return true;
        }
        function getCrossProductIntersections(types) {
            var count = getCrossProductUnionSize(types);
            var intersections = [];
            for (var i = 0; i < count; i++) {
                var constituents = types.slice();
                var n = i;
                for (var j = types.length - 1; j >= 0; j--) {
                    if (types[j].flags & 1048576 /* TypeFlags.Union */) {
                        var sourceTypes = types[j].types;
                        var length_5 = sourceTypes.length;
                        constituents[j] = sourceTypes[n % length_5];
                        n = Math.floor(n / length_5);
                    }
                }
                var t = getIntersectionType(constituents);
                if (!(t.flags & 131072 /* TypeFlags.Never */))
                    intersections.push(t);
            }
            return intersections;
        }
        function getConstituentCount(type) {
            return !(type.flags & 3145728 /* TypeFlags.UnionOrIntersection */) || type.aliasSymbol ? 1 :
                type.flags & 1048576 /* TypeFlags.Union */ && type.origin ? getConstituentCount(type.origin) :
                    getConstituentCountOfTypes(type.types);
        }
        function getConstituentCountOfTypes(types) {
            return ts.reduceLeft(types, function (n, t) { return n + getConstituentCount(t); }, 0);
        }
        function getTypeFromIntersectionTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                var types = ts.map(node.types, getTypeFromTypeNode);
                var noSupertypeReduction = types.length === 2 && !!(types[0].flags & (4 /* TypeFlags.String */ | 8 /* TypeFlags.Number */ | 64 /* TypeFlags.BigInt */)) && types[1] === emptyTypeLiteralType;
                links.resolvedType = getIntersectionType(types, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol), noSupertypeReduction);
            }
            return links.resolvedType;
        }
        function createIndexType(type, stringsOnly) {
            var result = createType(4194304 /* TypeFlags.Index */);
            result.type = type;
            result.stringsOnly = stringsOnly;
            return result;
        }
        function createOriginIndexType(type) {
            var result = createOriginType(4194304 /* TypeFlags.Index */);
            result.type = type;
            return result;
        }
        function getIndexTypeForGenericType(type, stringsOnly) {
            return stringsOnly ?
                type.resolvedStringIndexType || (type.resolvedStringIndexType = createIndexType(type, /*stringsOnly*/ true)) :
                type.resolvedIndexType || (type.resolvedIndexType = createIndexType(type, /*stringsOnly*/ false));
        }
        /**
         * This roughly mirrors `resolveMappedTypeMembers` in the nongeneric case, except only reports a union of the keys calculated,
         * rather than manufacturing the properties. We can't just fetch the `constraintType` since that would ignore mappings
         * and mapping the `constraintType` directly ignores how mapped types map _properties_ and not keys (thus ignoring subtype
         * reduction in the constraintType) when possible.
         * @param noIndexSignatures Indicates if _string_ index signatures should be elided. (other index signatures are always reported)
         */
        function getIndexTypeForMappedType(type, stringsOnly, noIndexSignatures) {
            var typeParameter = getTypeParameterFromMappedType(type);
            var constraintType = getConstraintTypeFromMappedType(type);
            var nameType = getNameTypeFromMappedType(type.target || type);
            if (!nameType && !noIndexSignatures) {
                // no mapping and no filtering required, just quickly bail to returning the constraint in the common case
                return constraintType;
            }
            var keyTypes = [];
            if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
                // We have a { [P in keyof T]: X }
                // `getApparentType` on the T in a generic mapped type can trigger a circularity
                // (conditionals and `infer` types create a circular dependency in the constraint resolution)
                // so we only eagerly manifest the keys if the constraint is nongeneric
                if (!isGenericIndexType(constraintType)) {
                    var modifiersType = getApparentType(getModifiersTypeFromMappedType(type)); // The 'T' in 'keyof T'
                    forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, 8576 /* TypeFlags.StringOrNumberLiteralOrUnique */, stringsOnly, addMemberForKeyType);
                }
                else {
                    // we have a generic index and a homomorphic mapping (but a distributive key remapping) - we need to defer the whole `keyof whatever` for later
                    // since it's not safe to resolve the shape of modifier type
                    return getIndexTypeForGenericType(type, stringsOnly);
                }
            }
            else {
                forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType);
            }
            if (isGenericIndexType(constraintType)) { // include the generic component in the resulting type
                forEachType(constraintType, addMemberForKeyType);
            }
            // we had to pick apart the constraintType to potentially map/filter it - compare the final resulting list with the original constraintType,
            // so we can return the union that preserves aliases/origin data if possible
            var result = noIndexSignatures ? filterType(getUnionType(keyTypes), function (t) { return !(t.flags & (1 /* TypeFlags.Any */ | 4 /* TypeFlags.String */)); }) : getUnionType(keyTypes);
            if (result.flags & 1048576 /* TypeFlags.Union */ && constraintType.flags & 1048576 /* TypeFlags.Union */ && getTypeListId(result.types) === getTypeListId(constraintType.types)) {
                return constraintType;
            }
            return result;
            function addMemberForKeyType(keyType) {
                var propNameType = nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType;
                // `keyof` currently always returns `string | number` for concrete `string` index signatures - the below ternary keeps that behavior for mapped types
                // See `getLiteralTypeFromProperties` where there's a similar ternary to cause the same behavior.
                keyTypes.push(propNameType === stringType ? stringOrNumberType : propNameType);
            }
        }
        // Ordinarily we reduce a keyof M, where M is a mapped type { [P in K as N<P>]: X }, to simply N<K>. This however presumes
        // that N distributes over union types, i.e. that N<A | B | C> is equivalent to N<A> | N<B> | N<C>. Specifically, we only
        // want to perform the reduction when the name type of a mapped type is distributive with respect to the type variable
        // introduced by the 'in' clause of the mapped type. Note that non-generic types are considered to be distributive because
        // they're the same type regardless of what's being distributed over.
        function hasDistributiveNameType(mappedType) {
            var typeVariable = getTypeParameterFromMappedType(mappedType);
            return isDistributive(getNameTypeFromMappedType(mappedType) || typeVariable);
            function isDistributive(type) {
                return type.flags & (3 /* TypeFlags.AnyOrUnknown */ | 131068 /* TypeFlags.Primitive */ | 131072 /* TypeFlags.Never */ | 262144 /* TypeFlags.TypeParameter */ | 524288 /* TypeFlags.Object */ | 67108864 /* TypeFlags.NonPrimitive */) ? true :
                    type.flags & 16777216 /* TypeFlags.Conditional */ ? type.root.isDistributive && type.checkType === typeVariable :
                        type.flags & (3145728 /* TypeFlags.UnionOrIntersection */ | 134217728 /* TypeFlags.TemplateLiteral */) ? ts.every(type.types, isDistributive) :
                            type.flags & 8388608 /* TypeFlags.IndexedAccess */ ? isDistributive(type.objectType) && isDistributive(type.indexType) :
                                type.flags & 33554432 /* TypeFlags.Substitution */ ? isDistributive(type.baseType) && isDistributive(type.constraint) :
                                    type.flags & 268435456 /* TypeFlags.StringMapping */ ? isDistributive(type.type) :
                                        false;
            }
        }
        function getLiteralTypeFromPropertyName(name) {
            if (ts.isPrivateIdentifier(name)) {
                return neverType;
            }
            return ts.isIdentifier(name) ? getStringLiteralType(ts.unescapeLeadingUnderscores(name.escapedText)) :
                getRegularTypeOfLiteralType(ts.isComputedPropertyName(name) ? checkComputedPropertyName(name) : checkExpression(name));
        }
        function getLiteralTypeFromProperty(prop, include, includeNonPublic) {
            if (includeNonPublic || !(ts.getDeclarationModifierFlagsFromSymbol(prop) & 24 /* ModifierFlags.NonPublicAccessibilityModifier */)) {
                var type = getSymbolLinks(getLateBoundSymbol(prop)).nameType;
                if (!type) {
                    var name = ts.getNameOfDeclaration(prop.valueDeclaration);
                    type = prop.escapedName === "default" /* InternalSymbolName.Default */ ? getStringLiteralType("default") :
                        name && getLiteralTypeFromPropertyName(name) || (!ts.isKnownSymbol(prop) ? getStringLiteralType(ts.symbolName(prop)) : undefined);
                }
                if (type && type.flags & include) {
                    return type;
                }
            }
            return neverType;
        }
        function isKeyTypeIncluded(keyType, include) {
            return !!(keyType.flags & include || keyType.flags & 2097152 /* TypeFlags.Intersection */ && ts.some(keyType.types, function (t) { return isKeyTypeIncluded(t, include); }));
        }
        function getLiteralTypeFromProperties(type, include, includeOrigin) {
            var origin = includeOrigin && (ts.getObjectFlags(type) & (3 /* ObjectFlags.ClassOrInterface */ | 4 /* ObjectFlags.Reference */) || type.aliasSymbol) ? createOriginIndexType(type) : undefined;
            var propertyTypes = ts.map(getPropertiesOfType(type), function (prop) { return getLiteralTypeFromProperty(prop, include); });
            var indexKeyTypes = ts.map(getIndexInfosOfType(type), function (info) { return info !== enumNumberIndexInfo && isKeyTypeIncluded(info.keyType, include) ?
                info.keyType === stringType && include & 8 /* TypeFlags.Number */ ? stringOrNumberType : info.keyType : neverType; });
            return getUnionType(ts.concatenate(propertyTypes, indexKeyTypes), 1 /* UnionReduction.Literal */, 
            /*aliasSymbol*/ undefined, /*aliasTypeArguments*/ undefined, origin);
        }
        /**
         * A union type which is reducible upon instantiation (meaning some members are removed under certain instantiations)
         * must be kept generic, as that instantiation information needs to flow through the type system. By replacing all
         * type parameters in the union with a special never type that is treated as a literal in `getReducedType`, we can cause the `getReducedType` logic
         * to reduce the resulting type if possible (since only intersections with conflicting literal-typed properties are reducible).
         */
        function isPossiblyReducibleByInstantiation(type) {
            var uniqueFilled = getUniqueLiteralFilledInstantiation(type);
            return getReducedType(uniqueFilled) !== uniqueFilled;
        }
        function shouldDeferIndexType(type) {
            return !!(type.flags & 58982400 /* TypeFlags.InstantiableNonPrimitive */ ||
                isGenericTupleType(type) ||
                isGenericMappedType(type) && !hasDistributiveNameType(type) ||
                type.flags & 1048576 /* TypeFlags.Union */ && ts.some(type.types, isPossiblyReducibleByInstantiation) ||
                type.flags & 2097152 /* TypeFlags.Intersection */ && maybeTypeOfKind(type, 465829888 /* TypeFlags.Instantiable */) && ts.some(type.types, isEmptyAnonymousObjectType));
        }
        function getIndexType(type, stringsOnly, noIndexSignatures) {
            if (stringsOnly === void 0) { stringsOnly = keyofStringsOnly; }
            type = getReducedType(type);
            return shouldDeferIndexType(type) ? getIndexTypeForGenericType(type, stringsOnly) :
                type.flags & 1048576 /* TypeFlags.Union */ ? getIntersectionType(ts.map(type.types, function (t) { return getIndexType(t, stringsOnly, noIndexSignatures); })) :
                    type.flags & 2097152 /* TypeFlags.Intersection */ ? getUnionType(ts.map(type.types, function (t) { return getIndexType(t, stringsOnly, noIndexSignatures); })) :
                        ts.getObjectFlags(type) & 32 /* ObjectFlags.Mapped */ ? getIndexTypeForMappedType(type, stringsOnly, noIndexSignatures) :
                            type === wildcardType ? wildcardType :
                                type.flags & 2 /* TypeFlags.Unknown */ ? neverType :
                                    type.flags & (1 /* TypeFlags.Any */ | 131072 /* TypeFlags.Never */) ? keyofConstraintType :
                                        getLiteralTypeFromProperties(type, (noIndexSignatures ? 128 /* TypeFlags.StringLiteral */ : 402653316 /* TypeFlags.StringLike */) | (stringsOnly ? 0 : 296 /* TypeFlags.NumberLike */ | 12288 /* TypeFlags.ESSymbolLike */), stringsOnly === keyofStringsOnly && !noIndexSignatures);
        }
        function getExtractStringType(type) {
            if (keyofStringsOnly) {
                return type;
            }
            var extractTypeAlias = getGlobalExtractSymbol();
            return extractTypeAlias ? getTypeAliasInstantiation(extractTypeAlias, [type, stringType]) : stringType;
        }
        function getIndexTypeOrString(type) {
            var indexType = getExtractStringType(getIndexType(type));
            return indexType.flags & 131072 /* TypeFlags.Never */ ? stringType : indexType;
        }
        function getTypeFromTypeOperatorNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                switch (node.operator) {
                    case 141 /* SyntaxKind.KeyOfKeyword */:
                        links.resolvedType = getIndexType(getTypeFromTypeNode(node.type));
                        break;
                    case 156 /* SyntaxKind.UniqueKeyword */:
                        links.resolvedType = node.type.kind === 153 /* SyntaxKind.SymbolKeyword */
                            ? getESSymbolLikeTypeForNode(ts.walkUpParenthesizedTypes(node.parent))
                            : errorType;
                        break;
                    case 146 /* SyntaxKind.ReadonlyKeyword */:
                        links.resolvedType = getTypeFromTypeNode(node.type);
                        break;
                    default:
                        throw ts.Debug.assertNever(node.operator);
                }
            }
            return links.resolvedType;
        }
        function getTypeFromTemplateTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = getTemplateLiteralType(__spreadArray([node.head.text], ts.map(node.templateSpans, function (span) { return span.literal.text; }), true), ts.map(node.templateSpans, function (span) { return getTypeFromTypeNode(span.type); }));
            }
            return links.resolvedType;
        }
        function getTemplateLiteralType(texts, types) {
            var unionIndex = ts.findIndex(types, function (t) { return !!(t.flags & (131072 /* TypeFlags.Never */ | 1048576 /* TypeFlags.Union */)); });
            if (unionIndex >= 0) {
                return checkCrossProductUnion(types) ?
                    mapType(types[unionIndex], function (t) { return getTemplateLiteralType(texts, ts.replaceElement(types, unionIndex, t)); }) :
                    errorType;
            }
            if (ts.contains(types, wildcardType)) {
                return wildcardType;
            }
            var newTypes = [];
            var newTexts = [];
            var text = texts[0];
            if (!addSpans(texts, types)) {
                return stringType;
            }
            if (newTypes.length === 0) {
                return getStringLiteralType(text);
            }
            newTexts.push(text);
            if (ts.every(newTexts, function (t) { return t === ""; })) {
                if (ts.every(newTypes, function (t) { return !!(t.flags & 4 /* TypeFlags.String */); })) {
                    return stringType;
                }
                // Normalize `${Mapping<xxx>}` into Mapping<xxx>
                if (newTypes.length === 1 && isPatternLiteralType(newTypes[0])) {
                    return newTypes[0];
                }
            }
            var id = "".concat(getTypeListId(newTypes), "|").concat(ts.map(newTexts, function (t) { return t.length; }).join(","), "|").concat(newTexts.join(""));
            var type = templateLiteralTypes.get(id);
            if (!type) {
                templateLiteralTypes.set(id, type = createTemplateLiteralType(newTexts, newTypes));
            }
            return type;
            function addSpans(texts, types) {
                var isTextsArray = ts.isArray(texts);
                for (var i = 0; i < types.length; i++) {
                    var t = types[i];
                    var addText = isTextsArray ? texts[i + 1] : texts;
                    if (t.flags & (2944 /* TypeFlags.Literal */ | 65536 /* TypeFlags.Null */ | 32768 /* TypeFlags.Undefined */)) {
                        text += getTemplateStringForType(t) || "";
                        text += addText;
                        if (!isTextsArray)
                            return true;
                    }
                    else if (t.flags & 134217728 /* TypeFlags.TemplateLiteral */) {
                        text += t.texts[0];
                        if (!addSpans(t.texts, t.types))
                            return false;
                        text += addText;
                        if (!isTextsArray)
                            return true;
                    }
                    else if (isGenericIndexType(t) || isPatternLiteralPlaceholderType(t)) {
                        newTypes.push(t);
                        newTexts.push(text);
                        text = addText;
                    }
                    else if (t.flags & 2097152 /* TypeFlags.Intersection */) {
                        var added = addSpans(texts[i + 1], t.types);
                        if (!added)
                            return false;
                    }
                    else if (isTextsArray) {
                        return false;
                    }
                }
                return true;
            }
        }
        function getTemplateStringForType(type) {
            return type.flags & 128 /* TypeFlags.StringLiteral */ ? type.value :
                type.flags & 256 /* TypeFlags.NumberLiteral */ ? "" + type.value :
                    type.flags & 2048 /* TypeFlags.BigIntLiteral */ ? ts.pseudoBigIntToString(type.value) :
                        type.flags & (512 /* TypeFlags.BooleanLiteral */ | 98304 /* TypeFlags.Nullable */) ? type.intrinsicName :
                            undefined;
        }
        function createTemplateLiteralType(texts, types) {
            var type = createType(134217728 /* TypeFlags.TemplateLiteral */);
            type.texts = texts;
            type.types = types;
            return type;
        }
        function getStringMappingType(symbol, type) {
            return type.flags & (1048576 /* TypeFlags.Union */ | 131072 /* TypeFlags.Never */) ? mapType(type, function (t) { return getStringMappingType(symbol, t); }) :
                type.flags & 128 /* TypeFlags.StringLiteral */ ? getStringLiteralType(applyStringMapping(symbol, type.value)) :
                    type.flags & 134217728 /* TypeFlags.TemplateLiteral */ ? getTemplateLiteralType.apply(void 0, applyTemplateStringMapping(symbol, type.texts, type.types)) :
                        // Mapping<Mapping<T>> === Mapping<T>
                        type.flags & 268435456 /* TypeFlags.StringMapping */ && symbol === type.symbol ? type :
                            type.flags & (1 /* TypeFlags.Any */ | 4 /* TypeFlags.String */ | 268435456 /* TypeFlags.StringMapping */) || isGenericIndexType(type) ? getStringMappingTypeForGenericType(symbol, type) :
                                // This handles Mapping<`${number}`> and Mapping<`${bigint}`>
                                isPatternLiteralPlaceholderType(type) ? getStringMappingTypeForGenericType(symbol, getTemplateLiteralType(["", ""], [type])) :
                                    type;
        }
        function applyStringMapping(symbol, str) {
            switch (intrinsicTypeKinds.get(symbol.escapedName)) {
                case 0 /* IntrinsicTypeKind.Uppercase */: return str.toUpperCase();
                case 1 /* IntrinsicTypeKind.Lowercase */: return str.toLowerCase();
                case 2 /* IntrinsicTypeKind.Capitalize */: return str.charAt(0).toUpperCase() + str.slice(1);
                case 3 /* IntrinsicTypeKind.Uncapitalize */: return str.charAt(0).toLowerCase() + str.slice(1);
            }
            return str;
        }
        function applyTemplateStringMapping(symbol, texts, types) {
            switch (intrinsicTypeKinds.get(symbol.escapedName)) {
                case 0 /* IntrinsicTypeKind.Uppercase */: return [texts.map(function (t) { return t.toUpperCase(); }), types.map(function (t) { return getStringMappingType(symbol, t); })];
                case 1 /* IntrinsicTypeKind.Lowercase */: return [texts.map(function (t) { return t.toLowerCase(); }), types.map(function (t) { return getStringMappingType(symbol, t); })];
                case 2 /* IntrinsicTypeKind.Capitalize */: return [texts[0] === "" ? texts : __spreadArray([texts[0].charAt(0).toUpperCase() + texts[0].slice(1)], texts.slice(1), true), texts[0] === "" ? __spreadArray([getStringMappingType(symbol, types[0])], types.slice(1), true) : types];
                case 3 /* IntrinsicTypeKind.Uncapitalize */: return [texts[0] === "" ? texts : __spreadArray([texts[0].charAt(0).toLowerCase() + texts[0].slice(1)], texts.slice(1), true), texts[0] === "" ? __spreadArray([getStringMappingType(symbol, types[0])], types.slice(1), true) : types];
            }
            return [texts, types];
        }
        function getStringMappingTypeForGenericType(symbol, type) {
            var id = "".concat(getSymbolId(symbol), ",").concat(getTypeId(type));
            var result = stringMappingTypes.get(id);
            if (!result) {
                stringMappingTypes.set(id, result = createStringMappingType(symbol, type));
            }
            return result;
        }
        function createStringMappingType(symbol, type) {
            var result = createType(268435456 /* TypeFlags.StringMapping */);
            result.symbol = symbol;
            result.type = type;
            return result;
        }
        function createIndexedAccessType(objectType, indexType, accessFlags, aliasSymbol, aliasTypeArguments) {
            var type = createType(8388608 /* TypeFlags.IndexedAccess */);
            type.objectType = objectType;
            type.indexType = indexType;
            type.accessFlags = accessFlags;
            type.aliasSymbol = aliasSymbol;
            type.aliasTypeArguments = aliasTypeArguments;
            return type;
        }
        /**
         * Returns if a type is or consists of a JSLiteral object type
         * In addition to objects which are directly literals,
         * * unions where every element is a jsliteral
         * * intersections where at least one element is a jsliteral
         * * and instantiable types constrained to a jsliteral
         * Should all count as literals and not print errors on access or assignment of possibly existing properties.
         * This mirrors the behavior of the index signature propagation, to which this behaves similarly (but doesn't affect assignability or inference).
         */
        function isJSLiteralType(type) {
            if (noImplicitAny) {
                return false; // Flag is meaningless under `noImplicitAny` mode
            }
            if (ts.getObjectFlags(type) & 4096 /* ObjectFlags.JSLiteral */) {
                return true;
            }
            if (type.flags & 1048576 /* TypeFlags.Union */) {
                return ts.every(type.types, isJSLiteralType);
            }
            if (type.flags & 2097152 /* TypeFlags.Intersection */) {
                return ts.some(type.types, isJSLiteralType);
            }
            if (type.flags & 465829888 /* TypeFlags.Instantiable */) {
                var constraint = getResolvedBaseConstraint(type);
                return constraint !== type && isJSLiteralType(constraint);
            }
            return false;
        }
        function getPropertyNameFromIndex(indexType, accessNode) {
            return isTypeUsableAsPropertyName(indexType) ?
                getPropertyNameFromType(indexType) :
                accessNode && ts.isPropertyName(accessNode) ?
                    // late bound names are handled in the first branch, so here we only need to handle normal names
                    ts.getPropertyNameForPropertyNameNode(accessNode) :
                    undefined;
        }
        function isUncalledFunctionReference(node, symbol) {
            if (symbol.flags & (16 /* SymbolFlags.Function */ | 8192 /* SymbolFlags.Method */)) {
                var parent = ts.findAncestor(node.parent, function (n) { return !ts.isAccessExpression(n); }) || node.parent;
                if (ts.isCallLikeExpression(parent)) {
                    return ts.isCallOrNewExpression(parent) && ts.isIdentifier(node) && hasMatchingArgument(parent, node);
                }
                return ts.every(symbol.declarations, function (d) { return !ts.isFunctionLike(d) || !!(ts.getCombinedNodeFlags(d) & 268435456 /* NodeFlags.Deprecated */); });
            }
            return true;
        }
        function getPropertyTypeForIndexType(originalObjectType, objectType, indexType, fullIndexType, accessNode, accessFlags) {
            var _a;
            var accessExpression = accessNode && accessNode.kind === 209 /* SyntaxKind.ElementAccessExpression */ ? accessNode : undefined;
            var propName = accessNode && ts.isPrivateIdentifier(accessNode) ? undefined : getPropertyNameFromIndex(indexType, accessNode);
            if (propName !== undefined) {
                if (accessFlags & 256 /* AccessFlags.Contextual */) {
                    return getTypeOfPropertyOfContextualType(objectType, propName) || anyType;
                }
                var prop = getPropertyOfType(objectType, propName);
                if (prop) {
                    if (accessFlags & 64 /* AccessFlags.ReportDeprecated */ && accessNode && prop.declarations && isDeprecatedSymbol(prop) && isUncalledFunctionReference(accessNode, prop)) {
                        var deprecatedNode = (_a = accessExpression === null || accessExpression === void 0 ? void 0 : accessExpression.argumentExpression) !== null && _a !== void 0 ? _a : (ts.isIndexedAccessTypeNode(accessNode) ? accessNode.indexType : accessNode);
                        addDeprecatedSuggestion(deprecatedNode, prop.declarations, propName);
                    }
                    if (accessExpression) {
                        markPropertyAsReferenced(prop, accessExpression, isSelfTypeAccess(accessExpression.expression, objectType.symbol));
                        if (isAssignmentToReadonlyEntity(accessExpression, prop, ts.getAssignmentTargetKind(accessExpression))) {
                            error(accessExpression.argumentExpression, ts.Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(prop));
                            return undefined;
                        }
                        if (accessFlags & 8 /* AccessFlags.CacheSymbol */) {
                            getNodeLinks(accessNode).resolvedSymbol = prop;
                        }
                        if (isThisPropertyAccessInConstructor(accessExpression, prop)) {
                            return autoType;
                        }
                    }
                    var propType = getTypeOfSymbol(prop);
                    return accessExpression && ts.getAssignmentTargetKind(accessExpression) !== 1 /* AssignmentKind.Definite */ ?
                        getFlowTypeOfReference(accessExpression, propType) :
                        propType;
                }
                if (everyType(objectType, isTupleType) && ts.isNumericLiteralName(propName)) {
                    var index = +propName;
                    if (accessNode && everyType(objectType, function (t) { return !t.target.hasRestElement; }) && !(accessFlags & 16 /* AccessFlags.NoTupleBoundsCheck */)) {
                        var indexNode = getIndexNodeForAccessExpression(accessNode);
                        if (isTupleType(objectType)) {
                            if (index < 0) {
                                error(indexNode, ts.Diagnostics.A_tuple_type_cannot_be_indexed_with_a_negative_value);
                                return undefinedType;
                            }
                            error(indexNode, ts.Diagnostics.Tuple_type_0_of_length_1_has_no_element_at_index_2, typeToString(objectType), getTypeReferenceArity(objectType), ts.unescapeLeadingUnderscores(propName));
                        }
                        else {
                            error(indexNode, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.unescapeLeadingUnderscores(propName), typeToString(objectType));
                        }
                    }
                    if (index >= 0) {
                        errorIfWritingToReadonlyIndex(getIndexInfoOfType(objectType, numberType));
                        return mapType(objectType, function (t) {
                            var restType = getRestTypeOfTupleType(t) || undefinedType;
                            return accessFlags & 1 /* AccessFlags.IncludeUndefined */ ? getUnionType([restType, undefinedType]) : restType;
                        });
                    }
                }
            }
            if (!(indexType.flags & 98304 /* TypeFlags.Nullable */) && isTypeAssignableToKind(indexType, 402653316 /* TypeFlags.StringLike */ | 296 /* TypeFlags.NumberLike */ | 12288 /* TypeFlags.ESSymbolLike */)) {
                if (objectType.flags & (1 /* TypeFlags.Any */ | 131072 /* TypeFlags.Never */)) {
                    return objectType;
                }
                // If no index signature is applicable, we default to the string index signature. In effect, this means the string
                // index signature applies even when accessing with a symbol-like type.
                var indexInfo = getApplicableIndexInfo(objectType, indexType) || getIndexInfoOfType(objectType, stringType);
                if (indexInfo) {
                    if (accessFlags & 2 /* AccessFlags.NoIndexSignatures */ && indexInfo.keyType !== numberType) {
                        if (accessExpression) {
                            error(accessExpression, ts.Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(originalObjectType));
                        }
                        return undefined;
                    }
                    if (accessNode && indexInfo.keyType === stringType && !isTypeAssignableToKind(indexType, 4 /* TypeFlags.String */ | 8 /* TypeFlags.Number */)) {
                        var indexNode = getIndexNodeForAccessExpression(accessNode);
                        error(indexNode, ts.Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
                        return accessFlags & 1 /* AccessFlags.IncludeUndefined */ ? getUnionType([indexInfo.type, undefinedType]) : indexInfo.type;
                    }
                    errorIfWritingToReadonlyIndex(indexInfo);
                    // When accessing an enum object with its own type,
                    // e.g. E[E.A] for enum E { A }, undefined shouldn't
                    // be included in the result type
                    if ((accessFlags & 1 /* AccessFlags.IncludeUndefined */) &&
                        !(objectType.symbol &&
                            objectType.symbol.flags & (256 /* SymbolFlags.RegularEnum */ | 128 /* SymbolFlags.ConstEnum */) &&
                            (indexType.symbol &&
                                indexType.flags & 1024 /* TypeFlags.EnumLiteral */ &&
                                getParentOfSymbol(indexType.symbol) === objectType.symbol))) {
                        return getUnionType([indexInfo.type, undefinedType]);
                    }
                    return indexInfo.type;
                }
                if (indexType.flags & 131072 /* TypeFlags.Never */) {
                    return neverType;
                }
                if (isJSLiteralType(objectType)) {
                    return anyType;
                }
                if (accessExpression && !isConstEnumObjectType(objectType)) {
                    if (isObjectLiteralType(objectType)) {
                        if (noImplicitAny && indexType.flags & (128 /* TypeFlags.StringLiteral */ | 256 /* TypeFlags.NumberLiteral */)) {
                            diagnostics.add(ts.createDiagnosticForNode(accessExpression, ts.Diagnostics.Property_0_does_not_exist_on_type_1, indexType.value, typeToString(objectType)));
                            return undefinedType;
                        }
                        else if (indexType.flags & (8 /* TypeFlags.Number */ | 4 /* TypeFlags.String */)) {
                            var types = ts.map(objectType.properties, function (property) {
                                return getTypeOfSymbol(property);
                            });
                            return getUnionType(ts.append(types, undefinedType));
                        }
                    }
                    if (objectType.symbol === globalThisSymbol && propName !== undefined && globalThisSymbol.exports.has(propName) && (globalThisSymbol.exports.get(propName).flags & 418 /* SymbolFlags.BlockScoped */)) {
                        error(accessExpression, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.unescapeLeadingUnderscores(propName), typeToString(objectType));
                    }
                    else if (noImplicitAny && !compilerOptions.suppressImplicitAnyIndexErrors && !(accessFlags & 128 /* AccessFlags.SuppressNoImplicitAnyError */)) {
                        if (propName !== undefined && typeHasStaticProperty(propName, objectType)) {
                            var typeName = typeToString(objectType);
                            error(accessExpression, ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName, typeName, typeName + "[" + ts.getTextOfNode(accessExpression.argumentExpression) + "]");
                        }
                        else if (getIndexTypeOfType(objectType, numberType)) {
                            error(accessExpression.argumentExpression, ts.Diagnostics.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number);
                        }
                        else {
                            var suggestion = void 0;
                            if (propName !== undefined && (suggestion = getSuggestionForNonexistentProperty(propName, objectType))) {
                                if (suggestion !== undefined) {
                                    error(accessExpression.argumentExpression, ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName, typeToString(objectType), suggestion);
                                }
                            }
                            else {
                                var suggestion_1 = getSuggestionForNonexistentIndexSignature(objectType, accessExpression, indexType);
                                if (suggestion_1 !== undefined) {
                                    error(accessExpression, ts.Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1, typeToString(objectType), suggestion_1);
                                }
                                else {
                                    var errorInfo = void 0;
                                    if (indexType.flags & 1024 /* TypeFlags.EnumLiteral */) {
                                        errorInfo = ts.chainDiagnosticMessages(/* details */ undefined, ts.Diagnostics.Property_0_does_not_exist_on_type_1, "[" + typeToString(indexType) + "]", typeToString(objectType));
                                    }
                                    else if (indexType.flags & 8192 /* TypeFlags.UniqueESSymbol */) {
                                        var symbolName_2 = getFullyQualifiedName(indexType.symbol, accessExpression);
                                        errorInfo = ts.chainDiagnosticMessages(/* details */ undefined, ts.Diagnostics.Property_0_does_not_exist_on_type_1, "[" + symbolName_2 + "]", typeToString(objectType));
                                    }
                                    else if (indexType.flags & 128 /* TypeFlags.StringLiteral */) {
                                        errorInfo = ts.chainDiagnosticMessages(/* details */ undefined, ts.Diagnostics.Property_0_does_not_exist_on_type_1, indexType.value, typeToString(objectType));
                                    }
                                    else if (indexType.flags & 256 /* TypeFlags.NumberLiteral */) {
                                        errorInfo = ts.chainDiagnosticMessages(/* details */ undefined, ts.Diagnostics.Property_0_does_not_exist_on_type_1, indexType.value, typeToString(objectType));
                                    }
                                    else if (indexType.flags & (8 /* TypeFlags.Number */ | 4 /* TypeFlags.String */)) {
                                        errorInfo = ts.chainDiagnosticMessages(/* details */ undefined, ts.Diagnostics.No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1, typeToString(indexType), typeToString(objectType));
                                    }
                                    errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1, typeToString(fullIndexType), typeToString(objectType));
                                    diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(accessExpression, errorInfo));
                                }
                            }
                        }
                    }
                    return undefined;
                }
            }
            if (isJSLiteralType(objectType)) {
                return anyType;
            }
            if (accessNode) {
                var indexNode = getIndexNodeForAccessExpression(accessNode);
                if (indexType.flags & (128 /* TypeFlags.StringLiteral */ | 256 /* TypeFlags.NumberLiteral */)) {
                    error(indexNode, ts.Diagnostics.Property_0_does_not_exist_on_type_1, "" + indexType.value, typeToString(objectType));
                }
                else if (indexType.flags & (4 /* TypeFlags.String */ | 8 /* TypeFlags.Number */)) {
                    error(indexNode, ts.Diagnostics.Type_0_has_no_matching_index_signature_for_type_1, typeToString(objectType), typeToString(indexType));
                }
                else {
                    error(indexNode, ts.Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
                }
            }
            if (isTypeAny(indexType)) {
                return indexType;
            }
            return undefined;
            function errorIfWritingToReadonlyIndex(indexInfo) {
                if (indexInfo && indexInfo.isReadonly && accessExpression && (ts.isAssignmentTarget(accessExpression) || ts.isDeleteTarget(accessExpression))) {
                    error(accessExpression, ts.Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
                }
            }
        }
        function getIndexNodeForAccessExpression(accessNode) {
            return accessNode.kind === 209 /* SyntaxKind.ElementAccessExpression */ ? accessNode.argumentExpression :
                accessNode.kind === 196 /* SyntaxKind.IndexedAccessType */ ? accessNode.indexType :
                    accessNode.kind === 164 /* SyntaxKind.ComputedPropertyName */ ? accessNode.expression :
                        accessNode;
        }
        function isPatternLiteralPlaceholderType(type) {
            return !!(type.flags & (1 /* TypeFlags.Any */ | 4 /* TypeFlags.String */ | 8 /* TypeFlags.Number */ | 64 /* TypeFlags.BigInt */)) || isPatternLiteralType(type);
        }
        function isPatternLiteralType(type) {
            return !!(type.flags & 134217728 /* TypeFlags.TemplateLiteral */) && ts.every(type.types, isPatternLiteralPlaceholderType) ||
                !!(type.flags & 268435456 /* TypeFlags.StringMapping */) && isPatternLiteralPlaceholderType(type.type);
        }
        function isGenericType(type) {
            return !!getGenericObjectFlags(type);
        }
        function isGenericObjectType(type) {
            return !!(getGenericObjectFlags(type) & 4194304 /* ObjectFlags.IsGenericObjectType */);
        }
        function isGenericIndexType(type) {
            return !!(getGenericObjectFlags(type) & 8388608 /* ObjectFlags.IsGenericIndexType */);
        }
        function getGenericObjectFlags(type) {
            if (type.flags & 3145728 /* TypeFlags.UnionOrIntersection */) {
                if (!(type.objectFlags & 2097152 /* ObjectFlags.IsGenericTypeComputed */)) {
                    type.objectFlags |= 2097152 /* ObjectFlags.IsGenericTypeComputed */ |
                        ts.reduceLeft(type.types, function (flags, t) { return flags | getGenericObjectFlags(t); }, 0);
                }
                return type.objectFlags & 12582912 /* ObjectFlags.IsGenericType */;
            }
            if (type.flags & 33554432 /* TypeFlags.Substitution */) {
                if (!(type.objectFlags & 2097152 /* ObjectFlags.IsGenericTypeComputed */)) {
                    type.objectFlags |= 2097152 /* ObjectFlags.IsGenericTypeComputed */ |
                        getGenericObjectFlags(type.baseType) | getGenericObjectFlags(type.constraint);
                }
                return type.objectFlags & 12582912 /* ObjectFlags.IsGenericType */;
            }
            return (type.flags & 58982400 /* TypeFlags.InstantiableNonPrimitive */ || isGenericMappedType(type) || isGenericTupleType(type) ? 4194304 /* ObjectFlags.IsGenericObjectType */ : 0) |
                (type.flags & (58982400 /* TypeFlags.InstantiableNonPrimitive */ | 4194304 /* TypeFlags.Index */ | 134217728 /* TypeFlags.TemplateLiteral */ | 268435456 /* TypeFlags.StringMapping */) && !isPatternLiteralType(type) ? 8388608 /* ObjectFlags.IsGenericIndexType */ : 0);
        }
        function getSimplifiedType(type, writing) {
            return type.flags & 8388608 /* TypeFlags.IndexedAccess */ ? getSimplifiedIndexedAccessType(type, writing) :
                type.flags & 16777216 /* TypeFlags.Conditional */ ? getSimplifiedConditionalType(type, writing) :
                    type;
        }
        function distributeIndexOverObjectType(objectType, indexType, writing) {
            // (T | U)[K] -> T[K] | U[K] (reading)
            // (T | U)[K] -> T[K] & U[K] (writing)
            // (T & U)[K] -> T[K] & U[K]
            if (objectType.flags & 1048576 /* TypeFlags.Union */ || objectType.flags & 2097152 /* TypeFlags.Intersection */ && !shouldDeferIndexType(objectType)) {
                var types = ts.map(objectType.types, function (t) { return getSimplifiedType(getIndexedAccessType(t, indexType), writing); });
                return objectType.flags & 2097152 /* TypeFlags.Intersection */ || writing ? getIntersectionType(types) : getUnionType(types);
            }
        }
        function distributeObjectOverIndexType(objectType, indexType, writing) {
            // T[A | B] -> T[A] | T[B] (reading)
            // T[A | B] -> T[A] & T[B] (writing)
            if (indexType.flags & 1048576 /* TypeFlags.Union */) {
                var types = ts.map(indexType.types, function (t) { return getSimplifiedType(getIndexedAccessType(objectType, t), writing); });
                return writing ? getIntersectionType(types) : getUnionType(types);
            }
        }
        // Transform an indexed access to a simpler form, if possible. Return the simpler form, or return
        // the type itself if no transformation is possible. The writing flag indicates that the type is
        // the target of an assignment.
        function getSimplifiedIndexedAccessType(type, writing) {
            var cache = writing ? "simplifiedForWriting" : "simplifiedForReading";
            if (type[cache]) {
                return type[cache] === circularConstraintType ? type : type[cache];
            }
            type[cache] = circularConstraintType;
            // We recursively simplify the object type as it may in turn be an indexed access type. For example, with
            // '{ [P in T]: { [Q in U]: number } }[T][U]' we want to first simplify the inner indexed access type.
            var objectType = getSimplifiedType(type.objectType, writing);
            var indexType = getSimplifiedType(type.indexType, writing);
            // T[A | B] -> T[A] | T[B] (reading)
            // T[A | B] -> T[A] & T[B] (writing)
            var distributedOverIndex = distributeObjectOverIndexType(objectType, indexType, writing);
            if (distributedOverIndex) {
                return type[cache] = distributedOverIndex;
            }
            // Only do the inner distributions if the index can no longer be instantiated to cause index distribution again
            if (!(indexType.flags & 465829888 /* TypeFlags.Instantiable */)) {
                // (T | U)[K] -> T[K] | U[K] (reading)
                // (T | U)[K] -> T[K] & U[K] (writing)
                // (T & U)[K] -> T[K] & U[K]
                var distributedOverObject = distributeIndexOverObjectType(objectType, indexType, writing);
                if (distributedOverObject) {
                    return type[cache] = distributedOverObject;
                }
            }
            // So ultimately (reading):
            // ((A & B) | C)[K1 | K2] -> ((A & B) | C)[K1] | ((A & B) | C)[K2] -> (A & B)[K1] | C[K1] | (A & B)[K2] | C[K2] -> (A[K1] & B[K1]) | C[K1] | (A[K2] & B[K2]) | C[K2]
            // A generic tuple type indexed by a number exists only when the index type doesn't select a
            // fixed element. We simplify to either the combined type of all elements (when the index type
            // the actual number type) or to the combined type of all non-fixed elements.
            if (isGenericTupleType(objectType) && indexType.flags & 296 /* TypeFlags.NumberLike */) {
                var elementType = getElementTypeOfSliceOfTupleType(objectType, indexType.flags & 8 /* TypeFlags.Number */ ? 0 : objectType.target.fixedLength, /*endSkipCount*/ 0, writing);
                if (elementType) {
                    return type[cache] = elementType;
                }
            }
            // If the object type is a mapped type { [P in K]: E }, where K is generic, or { [P in K as N]: E }, where
            // K is generic and N is assignable to P, instantiate E using a mapper that substitutes the index type for P.
            // For example, for an index access { [P in K]: Box<T[P]> }[X], we construct the type Box<T[X]>.
            if (isGenericMappedType(objectType)) {
                var nameType = getNameTypeFromMappedType(objectType);
                if (!nameType || isTypeAssignableTo(nameType, getTypeParameterFromMappedType(objectType))) {
                    return type[cache] = mapType(substituteIndexedMappedType(objectType, type.indexType), function (t) { return getSimplifiedType(t, writing); });
                }
            }
            return type[cache] = type;
        }
        function getSimplifiedConditionalType(type, writing) {
            var checkType = type.checkType;
            var extendsType = type.extendsType;
            var trueType = getTrueTypeFromConditionalType(type);
            var falseType = getFalseTypeFromConditionalType(type);
            // Simplifications for types of the form `T extends U ? T : never` and `T extends U ? never : T`.
            if (falseType.flags & 131072 /* TypeFlags.Never */ && getActualTypeVariable(trueType) === getActualTypeVariable(checkType)) {
                if (checkType.flags & 1 /* TypeFlags.Any */ || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType))) { // Always true
                    return getSimplifiedType(trueType, writing);
                }
                else if (isIntersectionEmpty(checkType, extendsType)) { // Always false
                    return neverType;
                }
            }
            else if (trueType.flags & 131072 /* TypeFlags.Never */ && getActualTypeVariable(falseType) === getActualTypeVariable(checkType)) {
                if (!(checkType.flags & 1 /* TypeFlags.Any */) && isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType))) { // Always true
                    return neverType;
                }
                else if (checkType.flags & 1 /* TypeFlags.Any */ || isIntersectionEmpty(checkType, extendsType)) { // Always false
                    return getSimplifiedType(falseType, writing);
                }
            }
            return type;
        }
        /**
         * Invokes union simplification logic to determine if an intersection is considered empty as a union constituent
         */
        function isIntersectionEmpty(type1, type2) {
            return !!(getUnionType([intersectTypes(type1, type2), neverType]).flags & 131072 /* TypeFlags.Never */);
        }
        function substituteIndexedMappedType(objectType, index) {
            var mapper = createTypeMapper([getTypeParameterFromMappedType(objectType)], [index]);
            var templateMapper = combineTypeMappers(objectType.mapper, mapper);
            return instantiateType(getTemplateTypeFromMappedType(objectType.target || objectType), templateMapper);
        }
        function getIndexedAccessType(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) {
            if (accessFlags === void 0) { accessFlags = 0 /* AccessFlags.None */; }
            return getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) || (accessNode ? errorType : unknownType);
        }
        function indexTypeLessThan(indexType, limit) {
            return everyType(indexType, function (t) {
                if (t.flags & 384 /* TypeFlags.StringOrNumberLiteral */) {
                    var propName = getPropertyNameFromType(t);
                    if (ts.isNumericLiteralName(propName)) {
                        var index = +propName;
                        return index >= 0 && index < limit;
                    }
                }
                return false;
            });
        }
        function getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) {
            if (accessFlags === void 0) { accessFlags = 0 /* AccessFlags.None */; }
            if (objectType === wildcardType || indexType === wildcardType) {
                return wildcardType;
            }
            // If the object type has a string index signature and no other members we know that the result will
            // always be the type of that index signature and we can simplify accordingly.
            if (isStringIndexSignatureOnlyType(objectType) && !(indexType.flags & 98304 /* TypeFlags.Nullable */) && isTypeAssignableToKind(indexType, 4 /* TypeFlags.String */ | 8 /* TypeFlags.Number */)) {
                indexType = stringType;
            }
            // In noUncheckedIndexedAccess mode, indexed access operations that occur in an expression in a read position and resolve to
            // an index signature have 'undefined' included in their type.
            if (compilerOptions.noUncheckedIndexedAccess && accessFlags & 32 /* AccessFlags.ExpressionPosition */)
                accessFlags |= 1 /* AccessFlags.IncludeUndefined */;
            // If the index type is generic, or if the object type is generic and doesn't originate in an expression and
            // the operation isn't exclusively indexing the fixed (non-variadic) portion of a tuple type, we are performing
            // a higher-order index access where we cannot meaningfully access the properties of the object type. Note that
            // for a generic T and a non-generic K, we eagerly resolve T[K] if it originates in an expression. This is to
            // preserve backwards compatibility. For example, an element access 'this["foo"]' has always been resolved
            // eagerly using the constraint type of 'this' at the given location.
            if (isGenericIndexType(indexType) || (accessNode && accessNode.kind !== 196 /* SyntaxKind.IndexedAccessType */ ?
                isGenericTupleType(objectType) && !indexTypeLessThan(indexType, objectType.target.fixedLength) :
                isGenericObjectType(objectType) && !(isTupleType(objectType) && indexTypeLessThan(indexType, objectType.target.fixedLength)))) {
                if (objectType.flags & 3 /* TypeFlags.AnyOrUnknown */) {
                    return objectType;
                }
                // Defer the operation by creating an indexed access type.
                var persistentAccessFlags = accessFlags & 1 /* AccessFlags.Persistent */;
                var id = objectType.id + "," + indexType.id + "," + persistentAccessFlags + getAliasId(aliasSymbol, aliasTypeArguments);
                var type = indexedAccessTypes.get(id);
                if (!type) {
                    indexedAccessTypes.set(id, type = createIndexedAccessType(objectType, indexType, persistentAccessFlags, aliasSymbol, aliasTypeArguments));
                }
                return type;
            }
            // In the following we resolve T[K] to the type of the property in T selected by K.
            // We treat boolean as different from other unions to improve errors;
            // skipping straight to getPropertyTypeForIndexType gives errors with 'boolean' instead of 'true'.
            var apparentObjectType = getReducedApparentType(objectType);
            if (indexType.flags & 1048576 /* TypeFlags.Union */ && !(indexType.flags & 16 /* TypeFlags.Boolean */)) {
                var propTypes = [];
                var wasMissingProp = false;
                for (var _i = 0, _a = indexType.types; _i < _a.length; _i++) {
                    var t = _a[_i];
                    var propType = getPropertyTypeForIndexType(objectType, apparentObjectType, t, indexType, accessNode, accessFlags | (wasMissingProp ? 128 /* AccessFlags.SuppressNoImplicitAnyError */ : 0));
                    if (propType) {
                        propTypes.push(propType);
                    }
                    else if (!accessNode) {
                        // If there's no error node, we can immeditely stop, since error reporting is off
                        return undefined;
                    }
                    else {
                        // Otherwise we set a flag and return at the end of the loop so we still mark all errors
                        wasMissingProp = true;
                    }
                }
                if (wasMissingProp) {
                    return undefined;
                }
                return accessFlags & 4 /* AccessFlags.Writing */
                    ? getIntersectionType(propTypes, aliasSymbol, aliasTypeArguments)
                    : getUnionType(propTypes, 1 /* UnionReduction.Literal */, aliasSymbol, aliasTypeArguments);
            }
            return getPropertyTypeForIndexType(objectType, apparentObjectType, indexType, indexType, accessNode, accessFlags | 8 /* AccessFlags.CacheSymbol */ | 64 /* AccessFlags.ReportDeprecated */);
        }
        function getTypeFromIndexedAccessTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var objectType = getTypeFromTypeNode(node.objectType);
                var indexType = getTypeFromTypeNode(node.indexType);
                var potentialAlias = getAliasSymbolForTypeNode(node);
                links.resolvedType = getIndexedAccessType(objectType, indexType, 0 /* AccessFlags.None */, node, potentialAlias, getTypeArgumentsForAliasSymbol(potentialAlias));
            }
            return links.resolvedType;
        }
        function getTypeFromMappedTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var type = createObjectType(32 /* ObjectFlags.Mapped */, node.symbol);
                type.declaration = node;
                type.aliasSymbol = getAliasSymbolForTypeNode(node);
                type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(type.aliasSymbol);
                links.resolvedType = type;
                // Eagerly resolve the constraint type which forces an error if the constraint type circularly
                // references itself through one or more type aliases.
                getConstraintTypeFromMappedType(type);
            }
            return links.resolvedType;
        }
        function getActualTypeVariable(type) {
            if (type.flags & 33554432 /* TypeFlags.Substitution */) {
                return type.baseType;
            }
            if (type.flags & 8388608 /* TypeFlags.IndexedAccess */ && (type.objectType.flags & 33554432 /* TypeFlags.Substitution */ ||
                type.indexType.flags & 33554432 /* TypeFlags.Substitution */)) {
                return getIndexedAccessType(getActualTypeVariable(type.objectType), getActualTypeVariable(type.indexType));
            }
            return type;
        }
        function maybeCloneTypeParameter(p) {
            var constraint = getConstraintOfTypeParameter(p);
            return constraint && (isGenericObjectType(constraint) || isGenericIndexType(constraint)) ? cloneTypeParameter(p) : p;
        }
        function isTypicalNondistributiveConditional(root) {
            return !root.isDistributive && isSingletonTupleType(root.node.checkType) && isSingletonTupleType(root.node.extendsType);
        }
        function isSingletonTupleType(node) {
            return ts.isTupleTypeNode(node) &&
                ts.length(node.elements) === 1 &&
                !ts.isOptionalTypeNode(node.elements[0]) &&
                !ts.isRestTypeNode(node.elements[0]) &&
                !(ts.isNamedTupleMember(node.elements[0]) && (node.elements[0].questionToken || node.elements[0].dotDotDotToken));
        }
        /**
         * We syntactually check for common nondistributive conditional shapes and unwrap them into
         * the intended comparison - we do this so we can check if the unwrapped types are generic or
         * not and appropriately defer condition calculation
         */
        function unwrapNondistributiveConditionalTuple(root, type) {
            return isTypicalNondistributiveConditional(root) && isTupleType(type) ? getTypeArguments(type)[0] : type;
        }
        function getConditionalType(root, mapper, aliasSymbol, aliasTypeArguments) {
            var result;
            var extraTypes;
            var tailCount = 0;
            // We loop here for an immediately nested conditional type in the false position, effectively treating
            // types of the form 'A extends B ? X : C extends D ? Y : E extends F ? Z : ...' as a single construct for
            // purposes of resolution. We also loop here when resolution of a conditional type ends in resolution of
            // another (or, through recursion, possibly the same) conditional type. In the potentially tail-recursive
            // cases we increment the tail recursion counter and stop after 1000 iterations.
            while (true) {
                if (tailCount === 1000) {
                    error(currentNode, ts.Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);
                    result = errorType;
                    break;
                }
                var isUnwrapped = isTypicalNondistributiveConditional(root);
                var checkType = instantiateType(unwrapNondistributiveConditionalTuple(root, getActualTypeVariable(root.checkType)), mapper);
                var checkTypeInstantiable = isGenericType(checkType);
                var extendsType = instantiateType(unwrapNondistributiveConditionalTuple(root, root.extendsType), mapper);
                if (checkType === wildcardType || extendsType === wildcardType) {
                    return wildcardType;
                }
                var combinedMapper = void 0;
                if (root.inferTypeParameters) {
                    // When we're looking at making an inference for an infer type, when we get its constraint, it'll automagically be
                    // instantiated with the context, so it doesn't need the mapper for the inference contex - however the constraint
                    // may refer to another _root_, _uncloned_ `infer` type parameter [1], or to something mapped by `mapper` [2].
                    // [1] Eg, if we have `Foo<T, U extends T>` and `Foo<number, infer B>` - `B` is constrained to `T`, which, in turn, has been instantiated
                    // as `number`
                    // Conversely, if we have `Foo<infer A, infer B>`, `B` is still constrained to `T` and `T` is instantiated as `A`
                    // [2] Eg, if we have `Foo<T, U extends T>` and `Foo<Q, infer B>` where `Q` is mapped by `mapper` into `number` - `B` is constrained to `T`
                    // which is in turn instantiated as `Q`, which is in turn instantiated as `number`.
                    // So we need to:
                    //    * Clone the type parameters so their constraints can be instantiated in the context of `mapper` (otherwise theyd only get inference context information)
                    //    * Set the clones to both map the conditional's enclosing `mapper` and the original params
                    //    * instantiate the extends type with the clones
                    //    * incorporate all of the component mappers into the combined mapper for the true and false members
                    // This means we have three mappers that need applying:
                    //    * The original `mapper` used to create this conditional
                    //    * The mapper that maps the old root type parameter to the clone (`freshMapper`)
                    //    * The mapper that maps the clone to its inference result (`context.mapper`)
                    var freshParams = ts.sameMap(root.inferTypeParameters, maybeCloneTypeParameter);
                    var freshMapper = freshParams !== root.inferTypeParameters ? createTypeMapper(root.inferTypeParameters, freshParams) : undefined;
                    var context = createInferenceContext(freshParams, /*signature*/ undefined, 0 /* InferenceFlags.None */);
                    if (freshMapper) {
                        var freshCombinedMapper = combineTypeMappers(mapper, freshMapper);
                        for (var _i = 0, freshParams_1 = freshParams; _i < freshParams_1.length; _i++) {
                            var p = freshParams_1[_i];
                            if (root.inferTypeParameters.indexOf(p) === -1) {
                                p.mapper = freshCombinedMapper;
                            }
                        }
                    }
                    if (!checkTypeInstantiable) {
                        // We don't want inferences from constraints as they may cause us to eagerly resolve the
                        // conditional type instead of deferring resolution. Also, we always want strict function
                        // types rules (i.e. proper contravariance) for inferences.
                        inferTypes(context.inferences, checkType, instantiateType(extendsType, freshMapper), 512 /* InferencePriority.NoConstraints */ | 1024 /* InferencePriority.AlwaysStrict */);
                    }
                    var innerMapper = combineTypeMappers(freshMapper, context.mapper);
                    // It's possible for 'infer T' type paramteters to be given uninstantiated constraints when the
                    // those type parameters are used in type references (see getInferredTypeParameterConstraint). For
                    // that reason we need context.mapper to be first in the combined mapper. See #42636 for examples.
                    combinedMapper = mapper ? combineTypeMappers(innerMapper, mapper) : innerMapper;
                }
                // Instantiate the extends type including inferences for 'infer T' type parameters
                var inferredExtendsType = combinedMapper ? instantiateType(unwrapNondistributiveConditionalTuple(root, root.extendsType), combinedMapper) : extendsType;
                // We attempt to resolve the conditional type only when the check and extends types are non-generic
                if (!checkTypeInstantiable && !isGenericType(inferredExtendsType)) {
                    // Return falseType for a definitely false extends check. We check an instantiations of the two
                    // types with type parameters mapped to the wildcard type, the most permissive instantiations
                    // possible (the wildcard type is assignable to and from all types). If those are not related,
                    // then no instantiations will be and we can just return the false branch type.
                    if (!(inferredExtendsType.flags & 3 /* TypeFlags.AnyOrUnknown */) && ((checkType.flags & 1 /* TypeFlags.Any */ && !isUnwrapped) || !isTypeAssignableTo(getPermissiveInstantiation(checkType), getPermissiveInstantiation(inferredExtendsType)))) {
                        // Return union of trueType and falseType for 'any' since it matches anything
                        if (checkType.flags & 1 /* TypeFlags.Any */ && !isUnwrapped) {
                            (extraTypes || (extraTypes = [])).push(instantiateType(getTypeFromTypeNode(root.node.trueType), combinedMapper || mapper));
                        }
                        // If falseType is an immediately nested conditional type that isn't distributive or has an
                        // identical checkType, switch to that type and loop.
                        var falseType_1 = getTypeFromTypeNode(root.node.falseType);
                        if (falseType_1.flags & 16777216 /* TypeFlags.Conditional */) {
                            var newRoot = falseType_1.root;
                            if (newRoot.node.parent === root.node && (!newRoot.isDistributive || newRoot.checkType === root.checkType)) {
                                root = newRoot;
                                continue;
                            }
                            if (canTailRecurse(falseType_1, mapper)) {
                                continue;
                            }
                        }
                        result = instantiateType(falseType_1, mapper);
                        break;
                    }
                    // Return trueType for a definitely true extends check. We check instantiations of the two
                    // types with type parameters mapped to their restrictive form, i.e. a form of the type parameter
                    // that has no constraint. This ensures that, for example, the type
                    //   type Foo<T extends { x: any }> = T extends { x: string } ? string : number
                    // doesn't immediately resolve to 'string' instead of being deferred.
                    if (inferredExtendsType.flags & 3 /* TypeFlags.AnyOrUnknown */ || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(inferredExtendsType))) {
                        var trueType_1 = getTypeFromTypeNode(root.node.trueType);
                        var trueMapper = combinedMapper || mapper;
                        if (canTailRecurse(trueType_1, trueMapper)) {
                            continue;
                        }
                        result = instantiateType(trueType_1, trueMapper);
                        break;
                    }
                }
                // Return a deferred type for a check that is neither definitely true nor definitely false
                result = createType(16777216 /* TypeFlags.Conditional */);
                result.root = root;
                result.checkType = instantiateType(root.checkType, mapper);
                result.extendsType = instantiateType(root.extendsType, mapper);
                result.mapper = mapper;
                result.combinedMapper = combinedMapper;
                result.aliasSymbol = aliasSymbol || root.aliasSymbol;
                result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(root.aliasTypeArguments, mapper); // TODO: GH#18217
                break;
            }
            return extraTypes ? getUnionType(ts.append(extraTypes, result)) : result;
            // We tail-recurse for generic conditional types that (a) have not already been evaluated and cached, and
            // (b) are non distributive, have a check type that is unaffected by instantiation, or have a non-union check
            // type. Note that recursion is possible only through aliased conditional types, so we only increment the tail
            // recursion counter for those.
            function canTailRecurse(newType, newMapper) {
                if (newType.flags & 16777216 /* TypeFlags.Conditional */ && newMapper) {
                    var newRoot = newType.root;
                    if (newRoot.outerTypeParameters) {
                        var typeParamMapper_1 = combineTypeMappers(newType.mapper, newMapper);
                        var typeArguments = ts.map(newRoot.outerTypeParameters, function (t) { return getMappedType(t, typeParamMapper_1); });
                        var newRootMapper = createTypeMapper(newRoot.outerTypeParameters, typeArguments);
                        var newCheckType = newRoot.isDistributive ? getMappedType(newRoot.checkType, newRootMapper) : undefined;
                        if (!newCheckType || newCheckType === newRoot.checkType || !(newCheckType.flags & (1048576 /* TypeFlags.Union */ | 131072 /* TypeFlags.Never */))) {
                            root = newRoot;
                            mapper = newRootMapper;
                            aliasSymbol = undefined;
                            aliasTypeArguments = undefined;
                            if (newRoot.aliasSymbol) {
                                tailCount++;
                            }
                            return true;
                        }
                    }
                }
                return false;
            }
        }
        function getTrueTypeFromConditionalType(type) {
            return type.resolvedTrueType || (type.resolvedTrueType = instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.mapper));
        }
        function getFalseTypeFromConditionalType(type) {
            return type.resolvedFalseType || (type.resolvedFalseType = instantiateType(getTypeFromTypeNode(type.root.node.falseType), type.mapper));
        }
        function getInferredTrueTypeFromConditionalType(type) {
            return type.resolvedInferredTrueType || (type.resolvedInferredTrueType = type.combinedMapper ? instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.combinedMapper) : getTrueTypeFromConditionalType(type));
        }
        function getInferTypeParameters(node) {
            var result;
            if (node.locals) {
                node.locals.forEach(function (symbol) {
                    if (symbol.flags & 262144 /* SymbolFlags.TypeParameter */) {
                        result = ts.append(result, getDeclaredTypeOfSymbol(symbol));
                    }
                });
            }
            return result;
        }
        function isDistributionDependent(root) {
            return root.isDistributive && (isTypeParameterPossiblyReferenced(root.checkType, root.node.trueType) ||
                isTypeParameterPossiblyReferenced(root.checkType, root.node.falseType));
        }
        function getTypeFromConditionalTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var checkType = getTypeFromTypeNode(node.checkType);
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                var aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
                var allOuterTypeParameters = getOuterTypeParameters(node, /*includeThisTypes*/ true);
                var outerTypeParameters = aliasTypeArguments ? allOuterTypeParameters : ts.filter(allOuterTypeParameters, function (tp) { return isTypeParameterPossiblyReferenced(tp, node); });
                var root = {
                    node: node,
                    checkType: checkType,
                    extendsType: getTypeFromTypeNode(node.extendsType),
                    isDistributive: !!(checkType.flags & 262144 /* TypeFlags.TypeParameter */),
                    inferTypeParameters: getInferTypeParameters(node),
                    outerTypeParameters: outerTypeParameters,
                    instantiations: undefined,
                    aliasSymbol: aliasSymbol,
                    aliasTypeArguments: aliasTypeArguments
                };
                links.resolvedType = getConditionalType(root, /*mapper*/ undefined);
                if (outerTypeParameters) {
                    root.instantiations = new ts.Map();
                    root.instantiations.set(getTypeListId(outerTypeParameters), links.resolvedType);
                }
            }
            return links.resolvedType;
        }
        function getTypeFromInferTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = getDeclaredTypeOfTypeParameter(getSymbolOfNode(node.typeParameter));
            }
            return links.resolvedType;
        }
        function getIdentifierChain(node) {
            if (ts.isIdentifier(node)) {
                return [node];
            }
            else {
                return ts.append(getIdentifierChain(node.left), node.right);
            }
        }
        function getTypeFromImportTypeNode(node) {
            var _a;
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                if (node.isTypeOf && node.typeArguments) { // Only the non-typeof form can make use of type arguments
                    error(node, ts.Diagnostics.Type_arguments_cannot_be_used_here);
                    links.resolvedSymbol = unknownSymbol;
                    return links.resolvedType = errorType;
                }
                if (!ts.isLiteralImportTypeNode(node)) {
                    error(node.argument, ts.Diagnostics.String_literal_expected);
                    links.resolvedSymbol = unknownSymbol;
                    return links.resolvedType = errorType;
                }
                var targetMeaning = node.isTypeOf ? 111551 /* SymbolFlags.Value */ : node.flags & 8388608 /* NodeFlags.JSDoc */ ? 111551 /* SymbolFlags.Value */ | 788968 /* SymbolFlags.Type */ : 788968 /* SymbolFlags.Type */;
                // TODO: Future work: support unions/generics/whatever via a deferred import-type
                var innerModuleSymbol = resolveExternalModuleName(node, node.argument.literal);
                if (!innerModuleSymbol) {
                    links.resolvedSymbol = unknownSymbol;
                    return links.resolvedType = errorType;
                }
                var isExportEquals = !!((_a = innerModuleSymbol.exports) === null || _a === void 0 ? void 0 : _a.get("export=" /* InternalSymbolName.ExportEquals */));
                var moduleSymbol = resolveExternalModuleSymbol(innerModuleSymbol, /*dontResolveAlias*/ false);
                if (!ts.nodeIsMissing(node.qualifier)) {
                    var nameStack = getIdentifierChain(node.qualifier);
                    var currentNamespace = moduleSymbol;
                    var current = void 0;
                    while (current = nameStack.shift()) {
                        var meaning = nameStack.length ? 1920 /* SymbolFlags.Namespace */ : targetMeaning;
                        // typeof a.b.c is normally resolved using `checkExpression` which in turn defers to `checkQualifiedName`
                        // That, in turn, ultimately uses `getPropertyOfType` on the type of the symbol, which differs slightly from
                        // the `exports` lookup process that only looks up namespace members which is used for most type references
                        var mergedResolvedSymbol = getMergedSymbol(resolveSymbol(currentNamespace));
                        var symbolFromVariable = node.isTypeOf || ts.isInJSFile(node) && isExportEquals
                            ? getPropertyOfType(getTypeOfSymbol(mergedResolvedSymbol), current.escapedText, /*skipObjectFunctionPropertyAugment*/ false, /*includeTypeOnlyMembers*/ true)
                            : undefined;
                        var symbolFromModule = node.isTypeOf ? undefined : getSymbol(getExportsOfSymbol(mergedResolvedSymbol), current.escapedText, meaning);
                        var next = symbolFromModule !== null && symbolFromModule !== void 0 ? symbolFromModule : symbolFromVariable;
                        if (!next) {
                            error(current, ts.Diagnostics.Namespace_0_has_no_exported_member_1, getFullyQualifiedName(currentNamespace), ts.declarationNameToString(current));
                            return links.resolvedType = errorType;
                        }
                        getNodeLinks(current).resolvedSymbol = next;
                        getNodeLinks(current.parent).resolvedSymbol = next;
                        currentNamespace = next;
                    }
                    links.resolvedType = resolveImportSymbolType(node, links, currentNamespace, targetMeaning);
                }
                else {
                    if (moduleSymbol.flags & targetMeaning) {
                        links.resolvedType = resolveImportSymbolType(node, links, moduleSymbol, targetMeaning);
                    }
                    else {
                        var errorMessage = targetMeaning === 111551 /* SymbolFlags.Value */
                            ? ts.Diagnostics.Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here
                            : ts.Diagnostics.Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0;
                        error(node, errorMessage, node.argument.literal.text);
                        links.resolvedSymbol = unknownSymbol;
                        links.resolvedType = errorType;
                    }
                }
            }
            return links.resolvedType;
        }
        function resolveImportSymbolType(node, links, symbol, meaning) {
            var resolvedSymbol = resolveSymbol(symbol);
            links.resolvedSymbol = resolvedSymbol;
            if (meaning === 111551 /* SymbolFlags.Value */) {
                return getTypeOfSymbol(symbol); // intentionally doesn't use resolved symbol so type is cached as expected on the alias
            }
            else {
                return getTypeReferenceType(node, resolvedSymbol); // getTypeReferenceType doesn't handle aliases - it must get the resolved symbol
            }
        }
        function getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                // Deferred resolution of members is handled by resolveObjectTypeMembers
                var aliasSymbol = getAliasSymbolForTypeNode(node);
                if (getMembersOfSymbol(node.symbol).size === 0 && !aliasSymbol) {
                    links.resolvedType = emptyTypeLiteralType;
                }
                else {
                    var type = createObjectType(16 /* ObjectFlags.Anonymous */, node.symbol);
                    type.aliasSymbol = aliasSymbol;
                    type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
                    if (ts.isJSDocTypeLiteral(node) && node.isArrayType) {
                        type = createArrayType(type);
                    }
                    links.resolvedType = type;
                }
            }
            return links.resolvedType;
        }
        function getAliasSymbolForTypeNode(node) {
            var host = node.parent;
            while (ts.isParenthesizedTypeNode(host) || ts.isJSDocTypeExpression(host) || ts.isTypeOperatorNode(host) && host.operator === 146 /* SyntaxKind.ReadonlyKeyword */) {
                host = host.parent;
            }
            return ts.isTypeAlias(host) ? getSymbolOfNode(host) : undefined;
        }
        function getTypeArgumentsForAliasSymbol(symbol) {
            return symbol ? getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol) : undefined;
        }
        function isNonGenericObjectType(type) {
            return !!(type.flags & 524288 /* TypeFlags.Object */) && !isGenericMappedType(type);
        }
        function isEmptyObjectTypeOrSpreadsIntoEmptyObject(type) {
            return isEmptyObjectType(type) || !!(type.flags & (65536 /* TypeFlags.Null */ | 32768 /* TypeFlags.Undefined */ | 528 /* TypeFlags.BooleanLike */ | 296 /* TypeFlags.NumberLike */ | 2112 /* TypeFlags.BigIntLike */ | 402653316 /* TypeFlags.StringLike */ | 1056 /* TypeFlags.EnumLike */ | 67108864 /* TypeFlags.NonPrimitive */ | 4194304 /* TypeFlags.Index */));
        }
        function tryMergeUnionOfObjectTypeAndEmptyObject(type, readonly) {
            if (!(type.flags & 1048576 /* TypeFlags.Union */)) {
                return type;
            }
            if (ts.every(type.types, isEmptyObjectTypeOrSpreadsIntoEmptyObject)) {
                return ts.find(type.types, isEmptyObjectType) || emptyObjectType;
            }
            var firstType = ts.find(type.types, function (t) { return !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t); });
            if (!firstType) {
                return type;
            }
            var secondType = ts.find(type.types, function (t) { return t !== firstType && !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t); });
            if (secondType) {
                return type;
            }
            return getAnonymousPartialType(firstType);
            function getAnonymousPartialType(type) {
                // gets the type as if it had been spread, but where everything in the spread is made optional
                var members = ts.createSymbolTable();
                for (var _i = 0, _a = getPropertiesOfType(type); _i < _a.length; _i++) {
                    var prop = _a[_i];
                    if (ts.getDeclarationModifierFlagsFromSymbol(prop) & (8 /* ModifierFlags.Private */ | 16 /* ModifierFlags.Protected */)) {
                        // do nothing, skip privates
                    }
                    else if (isSpreadableProperty(prop)) {
                        var isSetonlyAccessor = prop.flags & 65536 /* SymbolFlags.SetAccessor */ && !(prop.flags & 32768 /* SymbolFlags.GetAccessor */);
                        var flags = 4 /* SymbolFlags.Property */ | 16777216 /* SymbolFlags.Optional */;
                        var result = createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop) | (readonly ? 8 /* CheckFlags.Readonly */ : 0));
                        result.type = isSetonlyAccessor ? undefinedType : addOptionality(getTypeOfSymbol(prop), /*isProperty*/ true);
                        result.declarations = prop.declarations;
                        result.nameType = getSymbolLinks(prop).nameType;
                        result.syntheticOrigin = prop;
                        members.set(prop.escapedName, result);
                    }
                }
                var spread = createAnonymousType(type.symbol, members, ts.emptyArray, ts.emptyArray, getIndexInfosOfType(type));
                spread.objectFlags |= 128 /* ObjectFlags.ObjectLiteral */ | 131072 /* ObjectFlags.ContainsObjectOrArrayLiteral */;
                return spread;
            }
        }
        /**
         * Since the source of spread types are object literals, which are not binary,
         * this function should be called in a left folding style, with left = previous result of getSpreadType
         * and right = the new element to be spread.
         */
        function getSpreadType(left, right, symbol, objectFlags, readonly) {
            if (left.flags & 1 /* TypeFlags.Any */ || right.flags & 1 /* TypeFlags.Any */) {
                return anyType;
            }
            if (left.flags & 2 /* TypeFlags.Unknown */ || right.flags & 2 /* TypeFlags.Unknown */) {
                return unknownType;
            }
            if (left.flags & 131072 /* TypeFlags.Never */) {
                return right;
            }
            if (right.flags & 131072 /* TypeFlags.Never */) {
                return left;
            }
            left = tryMergeUnionOfObjectTypeAndEmptyObject(left, readonly);
            if (left.flags & 1048576 /* TypeFlags.Union */) {
                return checkCrossProductUnion([left, right])
                    ? mapType(left, function (t) { return getSpreadType(t, right, symbol, objectFlags, readonly); })
                    : errorType;
            }
            right = tryMergeUnionOfObjectTypeAndEmptyObject(right, readonly);
            if (right.flags & 1048576 /* TypeFlags.Union */) {
                return checkCrossProductUnion([left, right])
                    ? mapType(right, function (t) { return getSpreadType(left, t, symbol, objectFlags, readonly); })
                    : errorType;
            }
            if (right.flags & (528 /* TypeFlags.BooleanLike */ | 296 /* TypeFlags.NumberLike */ | 2112 /* TypeFlags.BigIntLike */ | 402653316 /* TypeFlags.StringLike */ | 1056 /* TypeFlags.EnumLike */ | 67108864 /* TypeFlags.NonPrimitive */ | 4194304 /* TypeFlags.Index */)) {
                return left;
            }
            if (isGenericObjectType(left) || isGenericObjectType(right)) {
                if (isEmptyObjectType(left)) {
                    return right;
                }
                // When the left type is an intersection, we may need to merge the last constituent of the
                // intersection with the right type. For example when the left type is 'T & { a: string }'
                // and the right type is '{ b: string }' we produce 'T & { a: string, b: string }'.
                if (left.flags & 2097152 /* TypeFlags.Intersection */) {
                    var types = left.types;
                    var lastLeft = types[types.length - 1];
                    if (isNonGenericObjectType(lastLeft) && isNonGenericObjectType(right)) {
                        return getIntersectionType(ts.concatenate(types.slice(0, types.length - 1), [getSpreadType(lastLeft, right, symbol, objectFlags, readonly)]));
                    }
                }
                return getIntersectionType([left, right]);
            }
            var members = ts.createSymbolTable();
            var skippedPrivateMembers = new ts.Set();
            var indexInfos = left === emptyObjectType ? getIndexInfosOfType(right) : getUnionIndexInfos([left, right]);
            for (var _i = 0, _a = getPropertiesOfType(right); _i < _a.length; _i++) {
                var rightProp = _a[_i];
                if (ts.getDeclarationModifierFlagsFromSymbol(rightProp) & (8 /* ModifierFlags.Private */ | 16 /* ModifierFlags.Protected */)) {
                    skippedPrivateMembers.add(rightProp.escapedName);
                }
                else if (isSpreadableProperty(rightProp)) {
                    members.set(rightProp.escapedName, getSpreadSymbol(rightProp, readonly));
                }
            }
            for (var _b = 0, _c = getPropertiesOfType(left); _b < _c.length; _b++) {
                var leftProp = _c[_b];
                if (skippedPrivateMembers.has(leftProp.escapedName) || !isSpreadableProperty(leftProp)) {
                    continue;
                }
                if (members.has(leftProp.escapedName)) {
                    var rightProp = members.get(leftProp.escapedName);
                    var rightType = getTypeOfSymbol(rightProp);
                    if (rightProp.flags & 16777216 /* SymbolFlags.Optional */) {
                        var declarations = ts.concatenate(leftProp.declarations, rightProp.declarations);
                        var flags = 4 /* SymbolFlags.Property */ | (leftProp.flags & 16777216 /* SymbolFlags.Optional */);
                        var result = createSymbol(flags, leftProp.escapedName);
                        result.type = getUnionType([getTypeOfSymbol(leftProp), removeMissingOrUndefinedType(rightType)], 2 /* UnionReduction.Subtype */);
                        result.leftSpread = leftProp;
                        result.rightSpread = rightProp;
                        result.declarations = declarations;
                        result.nameType = getSymbolLinks(leftProp).nameType;
                        members.set(leftProp.escapedName, result);
                    }
                }
                else {
                    members.set(leftProp.escapedName, getSpreadSymbol(leftProp, readonly));
                }
            }
            var spread = createAnonymousType(symbol, members, ts.emptyArray, ts.emptyArray, ts.sameMap(indexInfos, function (info) { return getIndexInfoWithReadonly(info, readonly); }));
            spread.objectFlags |= 128 /* ObjectFlags.ObjectLiteral */ | 131072 /* ObjectFlags.ContainsObjectOrArrayLiteral */ | 2097152 /* ObjectFlags.ContainsSpread */ | objectFlags;
            return spread;
        }
        /** We approximate own properties as non-methods plus methods that are inside the object literal */
        function isSpreadableProperty(prop) {
            var _a;
            return !ts.some(prop.declarations, ts.isPrivateIdentifierClassElementDeclaration) &&
                (!(prop.flags & (8192 /* SymbolFlags.Method */ | 32768 /* SymbolFlags.GetAccessor */ | 65536 /* SymbolFlags.SetAccessor */)) ||
                    !((_a = prop.declarations) === null || _a === void 0 ? void 0 : _a.some(function (decl) { return ts.isClassLike(decl.parent); })));
        }
        function getSpreadSymbol(prop, readonly) {
            var isSetonlyAccessor = prop.flags & 65536 /* SymbolFlags.SetAccessor */ && !(prop.flags & 32768 /* SymbolFlags.GetAccessor */);
            if (!isSetonlyAccessor && readonly === isReadonlySymbol(prop)) {
                return prop;
            }
            var flags = 4 /* SymbolFlags.Property */ | (prop.flags & 16777216 /* SymbolFlags.Optional */);
            var result = createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop) | (readonly ? 8 /* CheckFlags.Readonly */ : 0));
            result.type = isSetonlyAccessor ? undefinedType : getTypeOfSymbol(prop);
            result.declarations = prop.declarations;
            result.nameType = getSymbolLinks(prop).nameType;
            result.syntheticOrigin = prop;
            return result;
        }
        function getIndexInfoWithReadonly(info, readonly) {
            return info.isReadonly !== readonly ? createIndexInfo(info.keyType, info.type, readonly, info.declaration) : info;
        }
        function createLiteralType(flags, value, symbol, regularType) {
            var type = createType(flags);
            type.symbol = symbol;
            type.value = value;
            type.regularType = regularType || type;
            return type;
        }
        function getFreshTypeOfLiteralType(type) {
            if (type.flags & 2944 /* TypeFlags.Literal */) {
                if (!type.freshType) {
                    var freshType = createLiteralType(type.flags, type.value, type.symbol, type);
                    freshType.freshType = freshType;
                    type.freshType = freshType;
                }
                return type.freshType;
            }
            return type;
        }
        function getRegularTypeOfLiteralType(type) {
            return type.flags & 2944 /* TypeFlags.Literal */ ? type.regularType :
                type.flags & 1048576 /* TypeFlags.Union */ ? (type.regularType || (type.regularType = mapType(type, getRegularTypeOfLiteralType))) :
                    type;
        }
        function isFreshLiteralType(type) {
            return !!(type.flags & 2944 /* TypeFlags.Literal */) && type.freshType === type;
        }
        function getStringLiteralType(value) {
            var type;
            return stringLiteralTypes.get(value) ||
                (stringLiteralTypes.set(value, type = createLiteralType(128 /* TypeFlags.StringLiteral */, value)), type);
        }
        function getNumberLiteralType(value) {
            var type;
            return numberLiteralTypes.get(value) ||
                (numberLiteralTypes.set(value, type = createLiteralType(256 /* TypeFlags.NumberLiteral */, value)), type);
        }
        function getBigIntLiteralType(value) {
            var type;
            var key = ts.pseudoBigIntToString(value);
            return bigIntLiteralTypes.get(key) ||
                (bigIntLiteralTypes.set(key, type = createLiteralType(2048 /* TypeFlags.BigIntLiteral */, value)), type);
        }
        function getEnumLiteralType(value, enumId, symbol) {
            var type;
            var qualifier = typeof value === "string" ? "@" : "#";
            var key = enumId + qualifier + value;
            var flags = 1024 /* TypeFlags.EnumLiteral */ | (typeof value === "string" ? 128 /* TypeFlags.StringLiteral */ : 256 /* TypeFlags.NumberLiteral */);
            return enumLiteralTypes.get(key) ||
                (enumLiteralTypes.set(key, type = createLiteralType(flags, value, symbol)), type);
        }
        function getTypeFromLiteralTypeNode(node) {
            if (node.literal.kind === 104 /* SyntaxKind.NullKeyword */) {
                return nullType;
            }
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = getRegularTypeOfLiteralType(checkExpression(node.literal));
            }
            return links.resolvedType;
        }
        function createUniqueESSymbolType(symbol) {
            var type = createType(8192 /* TypeFlags.UniqueESSymbol */);
            type.symbol = symbol;
            type.escapedName = "__@".concat(type.symbol.escapedName, "@").concat(getSymbolId(type.symbol));
            return type;
        }
        function getESSymbolLikeTypeForNode(node) {
            if (ts.isValidESSymbolDeclaration(node)) {
                var symbol = ts.isCommonJsExportPropertyAssignment(node) ? getSymbolOfNode(node.left) : getSymbolOfNode(node);
                if (symbol) {
                    var links = getSymbolLinks(symbol);
                    return links.uniqueESSymbolType || (links.uniqueESSymbolType = createUniqueESSymbolType(symbol));
                }
            }
            return esSymbolType;
        }
        function getThisType(node) {
            var container = ts.getThisContainer(node, /*includeArrowFunctions*/ false);
            var parent = container && container.parent;
            if (parent && (ts.isClassLike(parent) || parent.kind === 261 /* SyntaxKind.InterfaceDeclaration */)) {
                if (!ts.isStatic(container) &&
                    (!ts.isConstructorDeclaration(container) || ts.isNodeDescendantOf(node, container.body))) {
                    return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent)).thisType;
                }
            }
            // inside x.prototype = { ... }
            if (parent && ts.isObjectLiteralExpression(parent) && ts.isBinaryExpression(parent.parent) && ts.getAssignmentDeclarationKind(parent.parent) === 6 /* AssignmentDeclarationKind.Prototype */) {
                return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent.parent.left).parent).thisType;
            }
            // /** @return {this} */
            // x.prototype.m = function() { ... }
            var host = node.flags & 8388608 /* NodeFlags.JSDoc */ ? ts.getHostSignatureFromJSDoc(node) : undefined;
            if (host && ts.isFunctionExpression(host) && ts.isBinaryExpression(host.parent) && ts.getAssignmentDeclarationKind(host.parent) === 3 /* AssignmentDeclarationKind.PrototypeProperty */) {
                return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(host.parent.left).parent).thisType;
            }
            // inside constructor function C() { ... }
            if (isJSConstructor(container) && ts.isNodeDescendantOf(node, container.body)) {
                return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(container)).thisType;
            }
            error(node, ts.Diagnostics.A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface);
            return errorType;
        }
        function getTypeFromThisTypeNode(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                links.resolvedType = getThisType(node);
            }
            return links.resolvedType;
        }
        function getTypeFromRestTypeNode(node) {
            return getTypeFromTypeNode(getArrayElementTypeNode(node.type) || node.type);
        }
        function getArrayElementTypeNode(node) {
            switch (node.kind) {
                case 193 /* SyntaxKind.ParenthesizedType */:
                    return getArrayElementTypeNode(node.type);
                case 186 /* SyntaxKind.TupleType */:
                    if (node.elements.length === 1) {
                        node = node.elements[0];
                        if (node.kind === 188 /* SyntaxKind.RestType */ || node.kind === 199 /* SyntaxKind.NamedTupleMember */ && node.dotDotDotToken) {
                            return getArrayElementTypeNode(node.type);
                        }
                    }
                    break;
                case 185 /* SyntaxKind.ArrayType */:
                    return node.elementType;
            }
            return undefined;
        }
        function getTypeFromNamedTupleTypeNode(node) {
            var links = getNodeLinks(node);
            return links.resolvedType || (links.resolvedType =
                node.dotDotDotToken ? getTypeFromRestTypeNode(node) :
                    addOptionality(getTypeFromTypeNode(node.type), /*isProperty*/ true, !!node.questionToken));
        }
        function getTypeFromTypeNode(node) {
            return getConditionalFlowTypeOfType(getTypeFromTypeNodeWorker(node), node);
        }
        function getTypeFromTypeNodeWorker(node) {
            switch (node.kind) {
                case 131 /* SyntaxKind.AnyKeyword */:
                case 315 /* SyntaxKind.JSDocAllType */:
                case 316 /* SyntaxKind.JSDocUnknownType */:
                    return anyType;
                case 157 /* SyntaxKind.UnknownKeyword */:
                    return unknownType;
                case 152 /* SyntaxKind.StringKeyword */:
                    return stringType;
                case 148 /* SyntaxKind.NumberKeyword */:
                    return numberType;
                case 160 /* SyntaxKind.BigIntKeyword */:
                    return bigintType;
                case 134 /* SyntaxKind.BooleanKeyword */:
                    return booleanType;
                case 153 /* SyntaxKind.SymbolKeyword */:
                    return esSymbolType;
                case 114 /* SyntaxKind.VoidKeyword */:
                    return voidType;
                case 155 /* SyntaxKind.UndefinedKeyword */:
                    return undefinedType;
                case 104 /* SyntaxKind.NullKeyword */:
                    // TODO(rbuckton): `NullKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service.
                    return nullType;
                case 144 /* SyntaxKind.NeverKeyword */:
                    return neverType;
                case 149 /* SyntaxKind.ObjectKeyword */:
                    return node.flags & 262144 /* NodeFlags.JavaScriptFile */ && !noImplicitAny ? anyType : nonPrimitiveType;
                case 139 /* SyntaxKind.IntrinsicKeyword */:
                    return intrinsicMarkerType;
                case 194 /* SyntaxKind.ThisType */:
                case 108 /* SyntaxKind.ThisKeyword */:
                    // TODO(rbuckton): `ThisKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service and because of `isPartOfTypeNode`.
                    return getTypeFromThisTypeNode(node);
                case 198 /* SyntaxKind.LiteralType */:
                    return getTypeFromLiteralTypeNode(node);
                case 180 /* SyntaxKind.TypeReference */:
                    return getTypeFromTypeReference(node);
                case 179 /* SyntaxKind.TypePredicate */:
                    return node.assertsModifier ? voidType : booleanType;
                case 230 /* SyntaxKind.ExpressionWithTypeArguments */:
                    return getTypeFromTypeReference(node);
                case 183 /* SyntaxKind.TypeQuery */:
                    return getTypeFromTypeQueryNode(node);
                case 185 /* SyntaxKind.ArrayType */:
                case 186 /* SyntaxKind.TupleType */:
                    return getTypeFromArrayOrTupleTypeNode(node);
                case 187 /* SyntaxKind.OptionalType */:
                    return getTypeFromOptionalTypeNode(node);
                case 189 /* SyntaxKind.UnionType */:
                    return getTypeFromUnionTypeNode(node);
                case 190 /* SyntaxKind.IntersectionType */:
                    return getTypeFromIntersectionTypeNode(node);
                case 317 /* SyntaxKind.JSDocNullableType */:
                    return getTypeFromJSDocNullableTypeNode(node);
                case 319 /* SyntaxKind.JSDocOptionalType */:
                    return addOptionality(getTypeFromTypeNode(node.type));
                case 199 /* SyntaxKind.NamedTupleMember */:
                    return getTypeFromNamedTupleTypeNode(node);
                case 193 /* SyntaxKind.ParenthesizedType */:
                case 318 /* SyntaxKind.JSDocNonNullableType */:
                case 312 /* SyntaxKind.JSDocTypeExpression */:
                    return getTypeFromTypeNode(node.type);
                case 188 /* SyntaxKind.RestType */:
                    return getTypeFromRestTypeNode(node);
                case 321 /* SyntaxKind.JSDocVariadicType */:
                    return getTypeFromJSDocVariadicType(node);
                case 181 /* SyntaxKind.FunctionType */:
                case 182 /* SyntaxKind.ConstructorType */:
                case 184 /* SyntaxKind.TypeLiteral */:
                case 325 /* SyntaxKind.JSDocTypeLiteral */:
                case 320 /* SyntaxKind.JSDocFunctionType */:
                case 326 /* SyntaxKind.JSDocSignature */:
                    return getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);
                case 195 /* SyntaxKind.TypeOperator */:
                    return getTypeFromTypeOperatorNode(node);
                case 196 /* SyntaxKind.IndexedAccessType */:
                    return getTypeFromIndexedAccessTypeNode(node);
                case 197 /* SyntaxKind.MappedType */:
                    return getTypeFromMappedTypeNode(node);
                case 191 /* SyntaxKind.ConditionalType */:
                    return getTypeFromConditionalTypeNode(node);
                case 192 /* SyntaxKind.InferType */:
                    return getTypeFromInferTypeNode(node);
                case 200 /* SyntaxKind.TemplateLiteralType */:
                    return getTypeFromTemplateTypeNode(node);
                case 202 /* SyntaxKind.ImportType */:
                    return getTypeFromImportTypeNode(node);
                // This function assumes that an identifier, qualified name, or property access expression is a type expression
                // Callers should first ensure this by calling `isPartOfTypeNode`
                // TODO(rbuckton): These aren't valid TypeNodes, but we treat them as such because of `isPartOfTypeNode`, which returns `true` for things that aren't `TypeNode`s.
                case 79 /* SyntaxKind.Identifier */:
                case 163 /* SyntaxKind.QualifiedName */:
                case 208 /* SyntaxKind.PropertyAccessExpression */:
                    var symbol = getSymbolAtLocation(node);
                    return symbol ? getDeclaredTypeOfSymbol(symbol) : errorType;
                default:
                    return errorType;
            }
        }
        function instantiateList(items, mapper, instantiator) {
            if (items && items.length) {
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    var mapped = instantiator(item, mapper);
                    if (item !== mapped) {
                        var result = i === 0 ? [] : items.slice(0, i);
                        result.push(mapped);
                        for (i++; i < items.length; i++) {
                            result.push(instantiator(items[i], mapper));
                        }
                        return result;
                    }
                }
            }
            return items;
        }
        function instantiateTypes(types, mapper) {
            return instantiateList(types, mapper, instantiateType);
        }
        function instantiateSignatures(signatures, mapper) {
            return instantiateList(signatures, mapper, instantiateSignature);
        }
        function instantiateIndexInfos(indexInfos, mapper) {
            return instantiateList(indexInfos, mapper, instantiateIndexInfo);
        }
        function createTypeMapper(sources, targets) {
            return sources.length === 1 ? makeUnaryTypeMapper(sources[0], targets ? targets[0] : anyType) : makeArrayTypeMapper(sources, targets);
        }
        function getMappedType(type, mapper) {
            switch (mapper.kind) {
                case 0 /* TypeMapKind.Simple */:
                    return type === mapper.source ? mapper.target : type;
                case 1 /* TypeMapKind.Array */: {
                    var sources = mapper.sources;
                    var targets = mapper.targets;
                    for (var i = 0; i < sources.length; i++) {
                        if (type === sources[i]) {
                            return targets ? targets[i] : anyType;
                        }
                    }
                    return type;
                }
                case 2 /* TypeMapKind.Deferred */: {
                    var sources = mapper.sources;
                    var targets = mapper.targets;
                    for (var i = 0; i < sources.length; i++) {
                        if (type === sources[i]) {
                            return targets[i]();
                        }
                    }
                    return type;
                }
                case 3 /* TypeMapKind.Function */:
                    return mapper.func(type);
                case 4 /* TypeMapKind.Composite */:
                case 5 /* TypeMapKind.Merged */:
                    var t1 = getMappedType(type, mapper.mapper1);
                    return t1 !== type && mapper.kind === 4 /* TypeMapKind.Composite */ ? instantiateType(t1, mapper.mapper2) : getMappedType(t1, mapper.mapper2);
            }
        }
        function makeUnaryTypeMapper(source, target) {
            return ts.Debug.attachDebugPrototypeIfDebug({ kind: 0 /* TypeMapKind.Simple */, source: source, target: target });
        }
        function makeArrayTypeMapper(sources, targets) {
            return ts.Debug.attachDebugPrototypeIfDebug({ kind: 1 /* TypeMapKind.Array */, sources: sources, targets: targets });
        }
        function makeFunctionTypeMapper(func, debugInfo) {
            return ts.Debug.attachDebugPrototypeIfDebug({ kind: 3 /* TypeMapKind.Function */, func: func, debugInfo: ts.Debug.isDebugging ? debugInfo : undefined });
        }
        function makeDeferredTypeMapper(sources, targets) {
            return ts.Debug.attachDebugPrototypeIfDebug({ kind: 2 /* TypeMapKind.Deferred */, sources: sources, targets: targets });
        }
        function makeCompositeTypeMapper(kind, mapper1, mapper2) {
            return ts.Debug.attachDebugPrototypeIfDebug({ kind: kind, mapper1: mapper1, mapper2: mapper2 });
        }
        function createTypeEraser(sources) {
            return createTypeMapper(sources, /*targets*/ undefined);
        }
        /**
         * Maps forward-references to later types parameters to the empty object type.
         * This is used during inference when instantiating type parameter defaults.
         */
        function createBackreferenceMapper(context, index) {
            var forwardInferences = context.inferences.slice(index);
            return createTypeMapper(ts.map(forwardInferences, function (i) { return i.typeParameter; }), ts.map(forwardInferences, function () { return unknownType; }));
        }
        function combineTypeMappers(mapper1, mapper2) {
            return mapper1 ? makeCompositeTypeMapper(4 /* TypeMapKind.Composite */, mapper1, mapper2) : mapper2;
        }
        function mergeTypeMappers(mapper1, mapper2) {
            return mapper1 ? makeCompositeTypeMapper(5 /* TypeMapKind.Merged */, mapper1, mapper2) : mapper2;
        }
        function prependTypeMapping(source, target, mapper) {
            return !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(5 /* TypeMapKind.Merged */, makeUnaryTypeMapper(source, target), mapper);
        }
        function appendTypeMapping(mapper, source, target) {
            return !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(5 /* TypeMapKind.Merged */, mapper, makeUnaryTypeMapper(source, target));
        }
        function getRestrictiveTypeParameter(tp) {
            return !tp.constraint && !getConstraintDeclaration(tp) || tp.constraint === noConstraintType ? tp : tp.restrictiveInstantiation || (tp.restrictiveInstantiation = createTypeParameter(tp.symbol),
                tp.restrictiveInstantiation.constraint = noConstraintType,
                tp.restrictiveInstantiation);
        }
        function cloneTypeParameter(typeParameter) {
            var result = createTypeParameter(typeParameter.symbol);
            result.target = typeParameter;
            return result;
        }
        function instantiateTypePredicate(predicate, mapper) {
            return createTypePredicate(predicate.kind, predicate.parameterName, predicate.parameterIndex, instantiateType(predicate.type, mapper));
        }
        function instantiateSignature(signature, mapper, eraseTypeParameters) {
            var freshTypeParameters;
            if (signature.typeParameters && !eraseTypeParameters) {
                // First create a fresh set of type parameters, then include a mapping from the old to the
                // new type parameters in the mapper function. Finally store this mapper in the new type
                // parameters such that we can use it when instantiating constraints.
                freshTypeParameters = ts.map(signature.typeParameters, cloneTypeParameter);
                mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper);
                for (var _i = 0, freshTypeParameters_1 = freshTypeParameters; _i < freshTypeParameters_1.length; _i++) {
                    var tp = freshTypeParameters_1[_i];
                    tp.mapper = mapper;
                }
            }
            // Don't compute resolvedReturnType and resolvedTypePredicate now,
            // because using `mapper` now could trigger inferences to become fixed. (See `createInferenceContext`.)
            // See GH#17600.
            var result = createSignature(signature.declaration, freshTypeParameters, signature.thisParameter && instantiateSymbol(signature.thisParameter, mapper), instantiateList(signature.parameters, mapper, instantiateSymbol), 
            /*resolvedReturnType*/ undefined, 
            /*resolvedTypePredicate*/ undefined, signature.minArgumentCount, signature.flags & 39 /* SignatureFlags.PropagatingFlags */);
            result.target = signature;
            result.mapper = mapper;
            return result;
        }
        function instantiateSymbol(symbol, mapper) {
            var links = getSymbolLinks(symbol);
            if (links.type && !couldContainTypeVariables(links.type)) {
                // If the type of the symbol is already resolved, and if that type could not possibly
                // be affected by instantiation, simply return the symbol itself.
                return symbol;
            }
            if (ts.getCheckFlags(symbol) & 1 /* CheckFlags.Instantiated */) {
                // If symbol being instantiated is itself a instantiation, fetch the original target and combine the
                // type mappers. This ensures that original type identities are properly preserved and that aliases
                // always reference a non-aliases.
                symbol = links.target;
                mapper = combineTypeMappers(links.mapper, mapper);
            }
            // Keep the flags from the symbol we're instantiating.  Mark that is instantiated, and
            // also transient so that we can just store data on it directly.
            var result = createSymbol(symbol.flags, symbol.escapedName, 1 /* CheckFlags.Instantiated */ | ts.getCheckFlags(symbol) & (8 /* CheckFlags.Readonly */ | 4096 /* CheckFlags.Late */ | 16384 /* CheckFlags.OptionalParameter */ | 32768 /* CheckFlags.RestParameter */));
            result.declarations = symbol.declarations;
            result.parent = symbol.parent;
            result.target = symbol;
            result.mapper = mapper;
            if (symbol.valueDeclaration) {
                result.valueDeclaration = symbol.valueDeclaration;
            }
            if (links.nameType) {
                result.nameType = links.nameType;
            }
            return result;
        }
        function getObjectTypeInstantiation(type, mapper, aliasSymbol, aliasTypeArguments) {
            var declaration = type.objectFlags & 4 /* ObjectFlags.Reference */ ? type.node :
                type.objectFlags & 8388608 /* ObjectFlags.InstantiationExpressionType */ ? type.node :
                    type.symbol.declarations[0];
            var links = getNodeLinks(declaration);
            var target = type.objectFlags & 4 /* ObjectFlags.Reference */ ? links.resolvedType :
                type.objectFlags & 64 /* ObjectFlags.Instantiated */ ? type.target : type;
            var typeParameters = links.outerTypeParameters;
            if (!typeParameters) {
                // The first time an anonymous type is instantiated we compute and store a list of the type
                // parameters that are in scope (and therefore potentially referenced). For type literals that
                // aren't the right hand side of a generic type alias declaration we optimize by reducing the
                // set of type parameters to those that are possibly referenced in the literal.
                var outerTypeParameters = getOuterTypeParameters(declaration, /*includeThisTypes*/ true);
                if (isJSConstructor(declaration)) {
                    var templateTagParameters = getTypeParametersFromDeclaration(declaration);
                    outerTypeParameters = ts.addRange(outerTypeParameters, templateTagParameters);
                }
                typeParameters = outerTypeParameters || ts.emptyArray;
                var allDeclarations_1 = type.objectFlags & (4 /* ObjectFlags.Reference */ | 8388608 /* ObjectFlags.InstantiationExpressionType */) ? [declaration] : type.symbol.declarations;
                typeParameters = (target.objectFlags & (4 /* ObjectFlags.Reference */ | 8388608 /* ObjectFlags.InstantiationExpressionType */) || target.symbol.flags & 8192 /* SymbolFlags.Method */ || target.symbol.flags & 2048 /* SymbolFlags.TypeLiteral */) && !target.aliasTypeArguments ?
                    ts.filter(typeParameters, function (tp) { return ts.some(allDeclarations_1, function (d) { return isTypeParameterPossiblyReferenced(tp, d); }); }) :
                    typeParameters;
                links.outerTypeParameters = typeParameters;
            }
            if (typeParameters.length) {
                // We are instantiating an anonymous type that has one or more type parameters in scope. Apply the
                // mapper to the type parameters to produce the effective list of type arguments, and compute the
                // instantiation cache key from the type IDs of the type arguments.
                var combinedMapper_1 = combineTypeMappers(type.mapper, mapper);
                var typeArguments = ts.map(typeParameters, function (t) { return getMappedType(t, combinedMapper_1); });
                var newAliasSymbol = aliasSymbol || type.aliasSymbol;
                var newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
                var id = getTypeListId(typeArguments) + getAliasId(newAliasSymbol, newAliasTypeArguments);
                if (!target.instantiations) {
                    target.instantiations = new ts.Map();
                    target.instantiations.set(getTypeListId(typeParameters) + getAliasId(target.aliasSymbol, target.aliasTypeArguments), target);
                }
                var result = target.instantiations.get(id);
                if (!result) {
                    var newMapper = createTypeMapper(typeParameters, typeArguments);
                    result = target.objectFlags & 4 /* ObjectFlags.Reference */ ? createDeferredTypeReference(type.target, type.node, newMapper, newAliasSymbol, newAliasTypeArguments) :
                        target.objectFlags & 32 /* ObjectFlags.Mapped */ ? instantiateMappedType(target, newMapper, newAliasSymbol, newAliasTypeArguments) :
                            instantiateAnonymousType(target, newMapper, newAliasSymbol, newAliasTypeArguments);
                    target.instantiations.set(id, result);
                }
                return result;
            }
            return type;
        }
        function maybeTypeParameterReference(node) {
            return !(node.parent.kind === 180 /* SyntaxKind.TypeReference */ && node.parent.typeArguments && node === node.parent.typeName ||
                node.parent.kind === 202 /* SyntaxKind.ImportType */ && node.parent.typeArguments && node === node.parent.qualifier);
        }
        function isTypeParameterPossiblyReferenced(tp, node) {
            // If the type parameter doesn't have exactly one declaration, if there are intervening statement blocks
            // between the node and the type parameter declaration, if the node contains actual references to the
            // type parameter, or if the node contains type queries that we can't prove couldn't contain references to the type parameter,
            // we consider the type parameter possibly referenced.
            if (tp.symbol && tp.symbol.declarations && tp.symbol.declarations.length === 1) {
                var container = tp.symbol.declarations[0].parent;
                for (var n = node; n !== container; n = n.parent) {
                    if (!n || n.kind === 238 /* SyntaxKind.Block */ || n.kind === 191 /* SyntaxKind.ConditionalType */ && ts.forEachChild(n.extendsType, containsReference)) {
                        return true;
                    }
                }
                return containsReference(node);
            }
            return true;
            function containsReference(node) {
                switch (node.kind) {
                    case 194 /* SyntaxKind.ThisType */:
                        return !!tp.isThisType;
                    case 79 /* SyntaxKind.Identifier */:
                        return !tp.isThisType && ts.isPartOfTypeNode(node) && maybeTypeParameterReference(node) &&
                            getTypeFromTypeNodeWorker(node) === tp; // use worker because we're looking for === equality
                    case 183 /* SyntaxKind.TypeQuery */:
                        var entityName = node.exprName;
                        var firstIdentifier = ts.getFirstIdentifier(entityName);
                        var firstIdentifierSymbol = getResolvedSymbol(firstIdentifier);
                        var tpDeclaration = tp.symbol.declarations[0]; // There is exactly one declaration, otherwise `containsReference` is not called
                        var tpScope_1;
                        if (tpDeclaration.kind === 165 /* SyntaxKind.TypeParameter */) { // Type parameter is a regular type parameter, e.g. foo<T>
                            tpScope_1 = tpDeclaration.parent;
                        }
                        else if (tp.isThisType) {
                            // Type parameter is the this type, and its declaration is the class declaration.
                            tpScope_1 = tpDeclaration;
                        }
                        else {
                            // Type parameter's declaration was unrecognized.
                            // This could happen if the type parameter comes from e.g. a JSDoc annotation, so we default to returning true.
                            return true;
                        }
                        if (firstIdentifierSymbol.declarations) {
                            return ts.some(firstIdentifierSymbol.declarations, function (idDecl) { return ts.isNodeDescendantOf(idDecl, tpScope_1); }) ||
                                ts.some(node.typeArguments, containsReference);
                        }
                        return true;
                    case 171 /* SyntaxKind.MethodDeclaration */:
                    case 170 /* SyntaxKind.MethodSignature */:
                        return !node.type && !!node.body ||
                            ts.some(node.typeParameters, containsReference) ||
                            ts.some(node.parameters, containsReference) ||
                            !!node.type && containsReference(node.type);
                }
                return !!ts.forEachChild(node, containsReference);
            }
        }
        function getHomomorphicTypeVariable(type) {
            var constraintType = getConstraintTypeFromMappedType(type);
            if (constraintType.flags & 4194304 /* TypeFlags.Index */) {
                var typeVariable = getActualTypeVariable(constraintType.type);
                if (typeVariable.flags & 262144 /* TypeFlags.TypeParameter */) {
                    return typeVariable;
                }
            }
            return undefined;
        }
        function instantiateMappedType(type, mapper, aliasSymbol, aliasTypeArguments) {
            // For a homomorphic mapped type { [P in keyof T]: X }, where T is some type variable, the mapping
            // operation depends on T as follows:
            // * If T is a primitive type no mapping is performed and the result is simply T.
            // * If T is a union type we distribute the mapped type over the union.
            // * If T is an array we map to an array where the element type has been transformed.
            // * If T is a tuple we map to a tuple where the element types have been transformed.
            // * Otherwise we map to an object type where the type of each property has been transformed.
            // For example, when T is instantiated to a union type A | B, we produce { [P in keyof A]: X } |
            // { [P in keyof B]: X }, and when when T is instantiated to a union type A | undefined, we produce
            // { [P in keyof A]: X } | undefined.
            var typeVariable = getHomomorphicTypeVariable(type);
            if (typeVariable) {
                var mappedTypeVariable = instantiateType(typeVariable, mapper);
                if (typeVariable !== mappedTypeVariable) {
                    return mapTypeWithAlias(getReducedType(mappedTypeVariable), function (t) {
                        if (t.flags & (3 /* TypeFlags.AnyOrUnknown */ | 58982400 /* TypeFlags.InstantiableNonPrimitive */ | 524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */) && t !== wildcardType && !isErrorType(t)) {
                            if (!type.declaration.nameType) {
                                var constraint = void 0;
                                if (isArrayType(t) || t.flags & 1 /* TypeFlags.Any */ && findResolutionCycleStartIndex(typeVariable, 4 /* TypeSystemPropertyName.ImmediateBaseConstraint */) < 0 &&
                                    (constraint = getConstraintOfTypeParameter(typeVariable)) && everyType(constraint, isArrayOrTupleType)) {
                                    return instantiateMappedArrayType(t, type, prependTypeMapping(typeVariable, t, mapper));
                                }
                                if (isGenericTupleType(t)) {
                                    return instantiateMappedGenericTupleType(t, type, typeVariable, mapper);
                                }
                                if (isTupleType(t)) {
                                    return instantiateMappedTupleType(t, type, prependTypeMapping(typeVariable, t, mapper));
                                }
                            }
                            return instantiateAnonymousType(type, prependTypeMapping(typeVariable, t, mapper));
                        }
                        return t;
                    }, aliasSymbol, aliasTypeArguments);
                }
            }
            // If the constraint type of the instantiation is the wildcard type, return the wildcard type.
            return instantiateType(getConstraintTypeFromMappedType(type), mapper) === wildcardType ? wildcardType : instantiateAnonymousType(type, mapper, aliasSymbol, aliasTypeArguments);
        }
        function getModifiedReadonlyState(state, modifiers) {
            return modifiers & 1 /* MappedTypeModifiers.IncludeReadonly */ ? true : modifiers & 2 /* MappedTypeModifiers.ExcludeReadonly */ ? false : state;
        }
        function instantiateMappedGenericTupleType(tupleType, mappedType, typeVariable, mapper) {
            // When a tuple type is generic (i.e. when it contains variadic elements), we want to eagerly map the
            // non-generic elements and defer mapping the generic elements. In order to facilitate this, we transform
            // M<[A, B?, ...T, ...C[]] into [...M<[A]>, ...M<[B?]>, ...M<T>, ...M<C[]>] and then rely on tuple type
            // normalization to resolve the non-generic parts of the resulting tuple.
            var elementFlags = tupleType.target.elementFlags;
            var elementTypes = ts.map(getTypeArguments(tupleType), function (t, i) {
                var singleton = elementFlags[i] & 8 /* ElementFlags.Variadic */ ? t :
                    elementFlags[i] & 4 /* ElementFlags.Rest */ ? createArrayType(t) :
                        createTupleType([t], [elementFlags[i]]);
                // The singleton is never a generic tuple type, so it is safe to recurse here.
                return instantiateMappedType(mappedType, prependTypeMapping(typeVariable, singleton, mapper));
            });
            var newReadonly = getModifiedReadonlyState(tupleType.target.readonly, getMappedTypeModifiers(mappedType));
            return createTupleType(elementTypes, ts.map(elementTypes, function (_) { return 8 /* ElementFlags.Variadic */; }), newReadonly);
        }
        function instantiateMappedArrayType(arrayType, mappedType, mapper) {
            var elementType = instantiateMappedTypeTemplate(mappedType, numberType, /*isOptional*/ true, mapper);
            return isErrorType(elementType) ? errorType :
                createArrayType(elementType, getModifiedReadonlyState(isReadonlyArrayType(arrayType), getMappedTypeModifiers(mappedType)));
        }
        function instantiateMappedTupleType(tupleType, mappedType, mapper) {
            var elementFlags = tupleType.target.elementFlags;
            var elementTypes = ts.map(getTypeArguments(tupleType), function (_, i) {
                return instantiateMappedTypeTemplate(mappedType, getStringLiteralType("" + i), !!(elementFlags[i] & 2 /* ElementFlags.Optional */), mapper);
            });
            var modifiers = getMappedTypeModifiers(mappedType);
            var newTupleModifiers = modifiers & 4 /* MappedTypeModifiers.IncludeOptional */ ? ts.map(elementFlags, function (f) { return f & 1 /* ElementFlags.Required */ ? 2 /* ElementFlags.Optional */ : f; }) :
                modifiers & 8 /* MappedTypeModifiers.ExcludeOptional */ ? ts.map(elementFlags, function (f) { return f & 2 /* ElementFlags.Optional */ ? 1 /* ElementFlags.Required */ : f; }) :
                    elementFlags;
            var newReadonly = getModifiedReadonlyState(tupleType.target.readonly, modifiers);
            return ts.contains(elementTypes, errorType) ? errorType :
                createTupleType(elementTypes, newTupleModifiers, newReadonly, tupleType.target.labeledElementDeclarations);
        }
        function instantiateMappedTypeTemplate(type, key, isOptional, mapper) {
            var templateMapper = appendTypeMapping(mapper, getTypeParameterFromMappedType(type), key);
            var propType = instantiateType(getTemplateTypeFromMappedType(type.target || type), templateMapper);
            var modifiers = getMappedTypeModifiers(type);
            return strictNullChecks && modifiers & 4 /* MappedTypeModifiers.IncludeOptional */ && !maybeTypeOfKind(propType, 32768 /* TypeFlags.Undefined */ | 16384 /* TypeFlags.Void */) ? getOptionalType(propType, /*isProperty*/ true) :
                strictNullChecks && modifiers & 8 /* MappedTypeModifiers.ExcludeOptional */ && isOptional ? getTypeWithFacts(propType, 524288 /* TypeFacts.NEUndefined */) :
                    propType;
        }
        function instantiateAnonymousType(type, mapper, aliasSymbol, aliasTypeArguments) {
            var result = createObjectType(type.objectFlags | 64 /* ObjectFlags.Instantiated */, type.symbol);
            if (type.objectFlags & 32 /* ObjectFlags.Mapped */) {
                result.declaration = type.declaration;
                // C.f. instantiateSignature
                var origTypeParameter = getTypeParameterFromMappedType(type);
                var freshTypeParameter = cloneTypeParameter(origTypeParameter);
                result.typeParameter = freshTypeParameter;
                mapper = combineTypeMappers(makeUnaryTypeMapper(origTypeParameter, freshTypeParameter), mapper);
                freshTypeParameter.mapper = mapper;
            }
            if (type.objectFlags & 8388608 /* ObjectFlags.InstantiationExpressionType */) {
                result.node = type.node;
            }
            result.target = type;
            result.mapper = mapper;
            result.aliasSymbol = aliasSymbol || type.aliasSymbol;
            result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
            result.objectFlags |= result.aliasTypeArguments ? getPropagatingFlagsOfTypes(result.aliasTypeArguments) : 0;
            return result;
        }
        function getConditionalTypeInstantiation(type, mapper, aliasSymbol, aliasTypeArguments) {
            var root = type.root;
            if (root.outerTypeParameters) {
                // We are instantiating a conditional type that has one or more type parameters in scope. Apply the
                // mapper to the type parameters to produce the effective list of type arguments, and compute the
                // instantiation cache key from the type IDs of the type arguments.
                var typeArguments = ts.map(root.outerTypeParameters, function (t) { return getMappedType(t, mapper); });
                var id = getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments);
                var result = root.instantiations.get(id);
                if (!result) {
                    var newMapper_1 = createTypeMapper(root.outerTypeParameters, typeArguments);
                    var checkType_1 = root.checkType;
                    var distributionType = root.isDistributive ? getMappedType(checkType_1, newMapper_1) : undefined;
                    // Distributive conditional types are distributed over union types. For example, when the
                    // distributive conditional type T extends U ? X : Y is instantiated with A | B for T, the
                    // result is (A extends U ? X : Y) | (B extends U ? X : Y).
                    result = distributionType && checkType_1 !== distributionType && distributionType.flags & (1048576 /* TypeFlags.Union */ | 131072 /* TypeFlags.Never */) ?
                        mapTypeWithAlias(getReducedType(distributionType), function (t) { return getConditionalType(root, prependTypeMapping(checkType_1, t, newMapper_1)); }, aliasSymbol, aliasTypeArguments) :
                        getConditionalType(root, newMapper_1, aliasSymbol, aliasTypeArguments);
                    root.instantiations.set(id, result);
                }
                return result;
            }
            return type;
        }
        function instantiateType(type, mapper) {
            return type && mapper ? instantiateTypeWithAlias(type, mapper, /*aliasSymbol*/ undefined, /*aliasTypeArguments*/ undefined) : type;
        }
        function instantiateTypeWithAlias(type, mapper, aliasSymbol, aliasTypeArguments) {
            if (!couldContainTypeVariables(type)) {
                return type;
            }
            if (instantiationDepth === 100 || instantiationCount >= 5000000) {
                // We have reached 100 recursive type instantiations, or 5M type instantiations caused by the same statement
                // or expression. There is a very high likelyhood we're dealing with a combination of infinite generic types
                // that perpetually generate new type identities, so we stop the recursion here by yielding the error type.
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.instant("checkTypes" /* tracing.Phase.CheckTypes */, "instantiateType_DepthLimit", { typeId: type.id, instantiationDepth: instantiationDepth, instantiationCount: instantiationCount });
                error(currentNode, ts.Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);
                return errorType;
            }
            totalInstantiationCount++;
            instantiationCount++;
            instantiationDepth++;
            var result = instantiateTypeWorker(type, mapper, aliasSymbol, aliasTypeArguments);
            instantiationDepth--;
            return result;
        }
        function instantiateTypeWorker(type, mapper, aliasSymbol, aliasTypeArguments) {
            var flags = type.flags;
            if (flags & 262144 /* TypeFlags.TypeParameter */) {
                return getMappedType(type, mapper);
            }
            if (flags & 524288 /* TypeFlags.Object */) {
                var objectFlags = type.objectFlags;
                if (objectFlags & (4 /* ObjectFlags.Reference */ | 16 /* ObjectFlags.Anonymous */ | 32 /* ObjectFlags.Mapped */)) {
                    if (objectFlags & 4 /* ObjectFlags.Reference */ && !type.node) {
                        var resolvedTypeArguments = type.resolvedTypeArguments;
                        var newTypeArguments = instantiateTypes(resolvedTypeArguments, mapper);
                        return newTypeArguments !== resolvedTypeArguments ? createNormalizedTypeReference(type.target, newTypeArguments) : type;
                    }
                    if (objectFlags & 1024 /* ObjectFlags.ReverseMapped */) {
                        return instantiateReverseMappedType(type, mapper);
                    }
                    return getObjectTypeInstantiation(type, mapper, aliasSymbol, aliasTypeArguments);
                }
                return type;
            }
            if (flags & 3145728 /* TypeFlags.UnionOrIntersection */) {
                var origin = type.flags & 1048576 /* TypeFlags.Union */ ? type.origin : undefined;
                var types = origin && origin.flags & 3145728 /* TypeFlags.UnionOrIntersection */ ? origin.types : type.types;
                var newTypes = instantiateTypes(types, mapper);
                if (newTypes === types && aliasSymbol === type.aliasSymbol) {
                    return type;
                }
                var newAliasSymbol = aliasSymbol || type.aliasSymbol;
                var newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
                return flags & 2097152 /* TypeFlags.Intersection */ || origin && origin.flags & 2097152 /* TypeFlags.Intersection */ ?
                    getIntersectionType(newTypes, newAliasSymbol, newAliasTypeArguments) :
                    getUnionType(newTypes, 1 /* UnionReduction.Literal */, newAliasSymbol, newAliasTypeArguments);
            }
            if (flags & 4194304 /* TypeFlags.Index */) {
                return getIndexType(instantiateType(type.type, mapper));
            }
            if (flags & 134217728 /* TypeFlags.TemplateLiteral */) {
                return getTemplateLiteralType(type.texts, instantiateTypes(type.types, mapper));
            }
            if (flags & 268435456 /* TypeFlags.StringMapping */) {
                return getStringMappingType(type.symbol, instantiateType(type.type, mapper));
            }
            if (flags & 8388608 /* TypeFlags.IndexedAccess */) {
                var newAliasSymbol = aliasSymbol || type.aliasSymbol;
                var newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
                return getIndexedAccessType(instantiateType(type.objectType, mapper), instantiateType(type.indexType, mapper), type.accessFlags, /*accessNode*/ undefined, newAliasSymbol, newAliasTypeArguments);
            }
            if (flags & 16777216 /* TypeFlags.Conditional */) {
                return getConditionalTypeInstantiation(type, combineTypeMappers(type.mapper, mapper), aliasSymbol, aliasTypeArguments);
            }
            if (flags & 33554432 /* TypeFlags.Substitution */) {
                var newBaseType = instantiateType(type.baseType, mapper);
                var newConstraint = instantiateType(type.constraint, mapper);
                // A substitution type originates in the true branch of a conditional type and can be resolved
                // to just the base type in the same cases as the conditional type resolves to its true branch
                // (because the base type is then known to satisfy the constraint).
                if (newBaseType.flags & 8650752 /* TypeFlags.TypeVariable */ && isGenericType(newConstraint)) {
                    return getSubstitutionType(newBaseType, newConstraint);
                }
                if (newConstraint.flags & 3 /* TypeFlags.AnyOrUnknown */ || isTypeAssignableTo(getRestrictiveInstantiation(newBaseType), getRestrictiveInstantiation(newConstraint))) {
                    return newBaseType;
                }
                return newBaseType.flags & 8650752 /* TypeFlags.TypeVariable */ ? getSubstitutionType(newBaseType, newConstraint) : getIntersectionType([newConstraint, newBaseType]);
            }
            return type;
        }
        function instantiateReverseMappedType(type, mapper) {
            var innerMappedType = instantiateType(type.mappedType, mapper);
            if (!(ts.getObjectFlags(innerMappedType) & 32 /* ObjectFlags.Mapped */)) {
                return type;
            }
            var innerIndexType = instantiateType(type.constraintType, mapper);
            if (!(innerIndexType.flags & 4194304 /* TypeFlags.Index */)) {
                return type;
            }
            var instantiated = inferTypeForHomomorphicMappedType(instantiateType(type.source, mapper), innerMappedType, innerIndexType);
            if (instantiated) {
                return instantiated;
            }
            return type; // Nested invocation of `inferTypeForHomomorphicMappedType` or the `source` instantiated into something unmappable
        }
        function getUniqueLiteralFilledInstantiation(type) {
            return type.flags & (131068 /* TypeFlags.Primitive */ | 3 /* TypeFlags.AnyOrUnknown */ | 131072 /* TypeFlags.Never */) ? type :
                type.uniqueLiteralFilledInstantiation || (type.uniqueLiteralFilledInstantiation = instantiateType(type, uniqueLiteralMapper));
        }
        function getPermissiveInstantiation(type) {
            return type.flags & (131068 /* TypeFlags.Primitive */ | 3 /* TypeFlags.AnyOrUnknown */ | 131072 /* TypeFlags.Never */) ? type :
                type.permissiveInstantiation || (type.permissiveInstantiation = instantiateType(type, permissiveMapper));
        }
        function getRestrictiveInstantiation(type) {
            if (type.flags & (131068 /* TypeFlags.Primitive */ | 3 /* TypeFlags.AnyOrUnknown */ | 131072 /* TypeFlags.Never */)) {
                return type;
            }
            if (type.restrictiveInstantiation) {
                return type.restrictiveInstantiation;
            }
            type.restrictiveInstantiation = instantiateType(type, restrictiveMapper);
            // We set the following so we don't attempt to set the restrictive instance of a restrictive instance
            // which is redundant - we'll produce new type identities, but all type params have already been mapped.
            // This also gives us a way to detect restrictive instances upon comparisons and _disable_ the "distributeive constraint"
            // assignability check for them, which is distinctly unsafe, as once you have a restrctive instance, all the type parameters
            // are constrained to `unknown` and produce tons of false positives/negatives!
            type.restrictiveInstantiation.restrictiveInstantiation = type.restrictiveInstantiation;
            return type.restrictiveInstantiation;
        }
        function instantiateIndexInfo(info, mapper) {
            return createIndexInfo(info.keyType, instantiateType(info.type, mapper), info.isReadonly, info.declaration);
        }
        // Returns true if the given expression contains (at any level of nesting) a function or arrow expression
        // that is subject to contextual typing.
        function isContextSensitive(node) {
            ts.Debug.assert(node.kind !== 171 /* SyntaxKind.MethodDeclaration */ || ts.isObjectLiteralMethod(node));
            switch (node.kind) {
                case 215 /* SyntaxKind.FunctionExpression */:
                case 216 /* SyntaxKind.ArrowFunction */:
                case 171 /* SyntaxKind.MethodDeclaration */:
                case 259 /* SyntaxKind.FunctionDeclaration */: // Function declarations can have context when annotated with a jsdoc @type
                    return isContextSensitiveFunctionLikeDeclaration(node);
                case 207 /* SyntaxKind.ObjectLiteralExpression */:
                    return ts.some(node.properties, isContextSensitive);
                case 206 /* SyntaxKind.ArrayLiteralExpression */:
                    return ts.some(node.elements, isContextSensitive);
                case 224 /* SyntaxKind.ConditionalExpression */:
                    return isContextSensitive(node.whenTrue) ||
                        isContextSensitive(node.whenFalse);
                case 223 /* SyntaxKind.BinaryExpression */:
                    return (node.operatorToken.kind === 56 /* SyntaxKind.BarBarToken */ || node.operatorToken.kind === 60 /* SyntaxKind.QuestionQuestionToken */) &&
                        (isContextSensitive(node.left) || isContextSensitive(node.right));
                case 299 /* SyntaxKind.PropertyAssignment */:
                    return isContextSensitive(node.initializer);
                case 214 /* SyntaxKind.ParenthesizedExpression */:
                    return isContextSensitive(node.expression);
                case 289 /* SyntaxKind.JsxAttributes */:
                    return ts.some(node.properties, isContextSensitive) || ts.isJsxOpeningElement(node.parent) && ts.some(node.parent.parent.children, isContextSensitive);
                case 288 /* SyntaxKind.JsxAttribute */: {
                    // If there is no initializer, JSX attribute has a boolean value of true which is not context sensitive.
                    var initializer = node.initializer;
                    return !!initializer && isContextSensitive(initializer);
                }
                case 291 /* SyntaxKind.JsxExpression */: {
                    // It is possible to that node.expression is undefined (e.g <div x={} />)
                    var expression = node.expression;
                    return !!expression && isContextSensitive(expression);
                }
            }
            return false;
        }
        function isContextSensitiveFunctionLikeDeclaration(node) {
            return ts.hasContextSensitiveParameters(node) || hasContextSensitiveReturnExpression(node);
        }
        function hasContextSensitiveReturnExpression(node) {
            // TODO(anhans): A block should be context-sensitive if it has a context-sensitive return value.
            return !node.typeParameters && !ts.getEffectiveReturnTypeNode(node) && !!node.body && node.body.kind !== 238 /* SyntaxKind.Block */ && isContextSensitive(node.body);
        }
        function isContextSensitiveFunctionOrObjectLiteralMethod(func) {
            return (ts.isFunctionExpressionOrArrowFunction(func) || ts.isObjectLiteralMethod(func)) &&
                isContextSensitiveFunctionLikeDeclaration(func);
        }
        function getTypeWithoutSignatures(type) {
            if (type.flags & 524288 /* TypeFlags.Object */) {
                var resolved = resolveStructuredTypeMembers(type);
                if (resolved.constructSignatures.length || resolved.callSignatures.length) {
                    var result = createObjectType(16 /* ObjectFlags.Anonymous */, type.symbol);
                    result.members = resolved.members;
                    result.properties = resolved.properties;
                    result.callSignatures = ts.emptyArray;
                    result.constructSignatures = ts.emptyArray;
                    result.indexInfos = ts.emptyArray;
                    return result;
                }
            }
            else if (type.flags & 2097152 /* TypeFlags.Intersection */) {
                return getIntersectionType(ts.map(type.types, getTypeWithoutSignatures));
            }
            return type;
        }
        // TYPE CHECKING
        function isTypeIdenticalTo(source, target) {
            return isTypeRelatedTo(source, target, identityRelation);
        }
        function compareTypesIdentical(source, target) {
            return isTypeRelatedTo(source, target, identityRelation) ? -1 /* Ternary.True */ : 0 /* Ternary.False */;
        }
        function compareTypesAssignable(source, target) {
            return isTypeRelatedTo(source, target, assignableRelation) ? -1 /* Ternary.True */ : 0 /* Ternary.False */;
        }
        function compareTypesSubtypeOf(source, target) {
            return isTypeRelatedTo(source, target, subtypeRelation) ? -1 /* Ternary.True */ : 0 /* Ternary.False */;
        }
        function isTypeSubtypeOf(source, target) {
            return isTypeRelatedTo(source, target, subtypeRelation);
        }
        function isTypeAssignableTo(source, target) {
            return isTypeRelatedTo(source, target, assignableRelation);
        }
        // An object type S is considered to be derived from an object type T if
        // S is a union type and every constituent of S is derived from T,
        // T is a union type and S is derived from at least one constituent of T, or
        // S is a type variable with a base constraint that is derived from T,
        // T is one of the global types Object and Function and S is a subtype of T, or
        // T occurs directly or indirectly in an 'extends' clause of S.
        // Note that this check ignores type parameters and only considers the
        // inheritance hierarchy.
        function isTypeDerivedFrom(source, target) {
            return source.flags & 1048576 /* TypeFlags.Union */ ? ts.every(source.types, function (t) { return isTypeDerivedFrom(t, target); }) :
                target.flags & 1048576 /* TypeFlags.Union */ ? ts.some(target.types, function (t) { return isTypeDerivedFrom(source, t); }) :
                    source.flags & 58982400 /* TypeFlags.InstantiableNonPrimitive */ ? isTypeDerivedFrom(getBaseConstraintOfType(source) || unknownType, target) :
                        target === globalObjectType ? !!(source.flags & (524288 /* TypeFlags.Object */ | 67108864 /* TypeFlags.NonPrimitive */)) :
                            target === globalFunctionType ? !!(source.flags & 524288 /* TypeFlags.Object */) && isFunctionObjectType(source) :
                                hasBaseType(source, getTargetType(target)) || (isArrayType(target) && !isReadonlyArrayType(target) && isTypeDerivedFrom(source, globalReadonlyArrayType));
        }
        /**
         * This is *not* a bi-directional relationship.
         * If one needs to check both directions for comparability, use a second call to this function or 'checkTypeComparableTo'.
         *
         * A type S is comparable to a type T if some (but not necessarily all) of the possible values of S are also possible values of T.
         * It is used to check following cases:
         *   - the types of the left and right sides of equality/inequality operators (`===`, `!==`, `==`, `!=`).
         *   - the types of `case` clause expressions and their respective `switch` expressions.
         *   - the type of an expression in a type assertion with the type being asserted.
         */
        function isTypeComparableTo(source, target) {
            return isTypeRelatedTo(source, target, comparableRelation);
        }
        function areTypesComparable(type1, type2) {
            return isTypeComparableTo(type1, type2) || isTypeComparableTo(type2, type1);
        }
        function checkTypeAssignableTo(source, target, errorNode, headMessage, containingMessageChain, errorOutputObject) {
            return checkTypeRelatedTo(source, target, assignableRelation, errorNode, headMessage, containingMessageChain, errorOutputObject);
        }
        /**
         * Like `checkTypeAssignableTo`, but if it would issue an error, instead performs structural comparisons of the types using the given expression node to
         * attempt to issue more specific errors on, for example, specific object literal properties or tuple members.
         */
        function checkTypeAssignableToAndOptionallyElaborate(source, target, errorNode, expr, headMessage, containingMessageChain) {
            return checkTypeRelatedToAndOptionallyElaborate(source, target, assignableRelation, errorNode, expr, headMessage, containingMessageChain, /*errorOutputContainer*/ undefined);
        }
        function checkTypeRelatedToAndOptionallyElaborate(source, target, relation, errorNode, expr, headMessage, containingMessageChain, errorOutputContainer) {
            if (isTypeRelatedTo(source, target, relation))
                return true;
            if (!errorNode || !elaborateError(expr, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)) {
                return checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer);
            }
            return false;
        }
        function isOrHasGenericConditional(type) {
            return !!(type.flags & 16777216 /* TypeFlags.Conditional */ || (type.flags & 2097152 /* TypeFlags.Intersection */ && ts.some(type.types, isOrHasGenericConditional)));
        }
        function elaborateError(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
            if (!node || isOrHasGenericConditional(target))
                return false;
            if (!checkTypeRelatedTo(source, target, relation, /*errorNode*/ undefined)
                && elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)) {
                return true;
            }
            switch (node.kind) {
                case 291 /* SyntaxKind.JsxExpression */:
                case 214 /* SyntaxKind.ParenthesizedExpression */:
                    return elaborateError(node.expression, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);
                case 223 /* SyntaxKind.BinaryExpression */:
                    switch (node.operatorToken.kind) {
                        case 63 /* SyntaxKind.EqualsToken */:
                        case 27 /* SyntaxKind.CommaToken */:
                            return elaborateError(node.right, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);
                    }
                    break;
                case 207 /* SyntaxKind.ObjectLiteralExpression */:
                    return elaborateObjectLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer);
                case 206 /* SyntaxKind.ArrayLiteralExpression */:
                    return elaborateArrayLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer);
                case 289 /* SyntaxKind.JsxAttributes */:
                    return elaborateJsxComponents(node, source, target, relation, containingMessageChain, errorOutputContainer);
                case 216 /* SyntaxKind.ArrowFunction */:
                    return elaborateArrowFunction(node, source, target, relation, containingMessageChain, errorOutputContainer);
            }
            return false;
        }
        function elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
            var callSignatures = getSignaturesOfType(source, 0 /* SignatureKind.Call */);
            var constructSignatures = getSignaturesOfType(source, 1 /* SignatureKind.Construct */);
            for (var _i = 0, _a = [constructSignatures, callSignatures]; _i < _a.length; _i++) {
                var signatures = _a[_i];
                if (ts.some(signatures, function (s) {
                    var returnType = getReturnTypeOfSignature(s);
                    return !(returnType.flags & (1 /* TypeFlags.Any */ | 131072 /* TypeFlags.Never */)) && checkTypeRelatedTo(returnType, target, relation, /*errorNode*/ undefined);
                })) {
                    var resultObj = errorOutputContainer || {};
                    checkTypeAssignableTo(source, target, node, headMessage, containingMessageChain, resultObj);
                    var diagnostic = resultObj.errors[resultObj.errors.length - 1];
                    ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(node, signatures === constructSignatures ? ts.Diagnostics.Did_you_mean_to_use_new_with_this_expression : ts.Diagnostics.Did_you_mean_to_call_this_expression));
                    return true;
                }
            }
            return false;
        }
        function elaborateArrowFunction(node, source, target, relation, containingMessageChain, errorOutputContainer) {
            // Don't elaborate blocks
            if (ts.isBlock(node.body)) {
                return false;
            }
            // Or functions with annotated parameter types
            if (ts.some(node.parameters, ts.hasType)) {
                return false;
            }
            var sourceSig = getSingleCallSignature(source);
            if (!sourceSig) {
                return false;
            }
            var targetSignatures = getSignaturesOfType(target, 0 /* SignatureKind.Call */);
            if (!ts.length(targetSignatures)) {
                return false;
            }
            var returnExpression = node.body;
            var sourceReturn = getReturnTypeOfSignature(sourceSig);
            var targetReturn = getUnionType(ts.map(targetSignatures, getReturnTypeOfSignature));
            if (!checkTypeRelatedTo(sourceReturn, targetReturn, relation, /*errorNode*/ undefined)) {
                var elaborated = returnExpression && elaborateError(returnExpression, sourceReturn, targetReturn, relation, /*headMessage*/ undefined, containingMessageChain, errorOutputContainer);
                if (elaborated) {
                    return elaborated;
                }
                var resultObj = errorOutputContainer || {};
                checkTypeRelatedTo(sourceReturn, targetReturn, relation, returnExpression, /*message*/ undefined, containingMessageChain, resultObj);
                if (resultObj.errors) {
                    if (target.symbol && ts.length(target.symbol.declarations)) {
                        ts.addRelatedInfo(resultObj.errors[resultObj.errors.length - 1], ts.createDiagnosticForNode(target.symbol.declarations[0], ts.Diagnostics.The_expected_type_comes_from_the_return_type_of_this_signature));
                    }
                    if ((ts.getFunctionFlags(node) & 2 /* FunctionFlags.Async */) === 0
                        // exclude cases where source itself is promisy - this way we don't make a suggestion when relating
                        // an IPromise and a Promise that are slightly different
                        && !getTypeOfPropertyOfType(sourceReturn, "then")
                        && checkTypeRelatedTo(createPromiseType(sourceReturn), targetReturn, relation, /*errorNode*/ undefined)) {
                        ts.addRelatedInfo(resultObj.errors[resultObj.errors.length - 1], ts.createDiagnosticForNode(node, ts.Diagnostics.Did_you_mean_to_mark_this_function_as_async));
                    }
                    return true;
                }
            }
            return false;
        }
        function getBestMatchIndexedAccessTypeOrUndefined(source, target, nameType) {
            var idx = getIndexedAccessTypeOrUndefined(target, nameType);
            if (idx) {
                return idx;
            }
            if (target.flags & 1048576 /* TypeFlags.Union */) {
                var best = getBestMatchingType(source, target);
                if (best) {
                    return getIndexedAccessTypeOrUndefined(best, nameType);
                }
            }
        }
        function checkExpressionForMutableLocationWithContextualType(next, sourcePropType) {
            next.contextualType = sourcePropType;
            try {
                return checkExpressionForMutableLocation(next, 1 /* CheckMode.Contextual */, sourcePropType);
            }
            finally {
                next.contextualType = undefined;
            }
        }
        /**
         * For every element returned from the iterator, checks that element to issue an error on a property of that element's type
         * If that element would issue an error, we first attempt to dive into that element's inner expression and issue a more specific error by recuring into `elaborateError`
         * Otherwise, we issue an error on _every_ element which fail the assignability check
         */
        function elaborateElementwise(iterator, source, target, relation, containingMessageChain, errorOutputContainer) {
            // Assignability failure - check each prop individually, and if that fails, fall back on the bad error span
            var reportedError = false;
            for (var status = iterator.next(); !status.done; status = iterator.next()) {
                var _a = status.value, prop = _a.errorNode, next = _a.innerExpression, nameType = _a.nameType, errorMessage = _a.errorMessage;
                var targetPropType = getBestMatchIndexedAccessTypeOrUndefined(source, target, nameType);
                if (!targetPropType || targetPropType.flags & 8388608 /* TypeFlags.IndexedAccess */)
                    continue; // Don't elaborate on indexes on generic variables
                var sourcePropType = getIndexedAccessTypeOrUndefined(source, nameType);
                if (!sourcePropType)
                    continue;
                var propName = getPropertyNameFromIndex(nameType, /*accessNode*/ undefined);
                if (!checkTypeRelatedTo(sourcePropType, targetPropType, relation, /*errorNode*/ undefined)) {
                    var elaborated = next && elaborateError(next, sourcePropType, targetPropType, relation, /*headMessage*/ undefined, containingMessageChain, errorOutputContainer);
                    reportedError = true;
                    if (!elaborated) {
                        // Issue error on the prop itself, since the prop couldn't elaborate the error
                        var resultObj = errorOutputContainer || {};
                        // Use the expression type, if available
                        var specificSource = next ? checkExpressionForMutableLocationWithContextualType(next, sourcePropType) : sourcePropType;
                        if (exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType)) {
                            var diag = ts.createDiagnosticForNode(prop, ts.Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, typeToString(specificSource), typeToString(targetPropType));
                            diagnostics.add(diag);
                            resultObj.errors = [diag];
                        }
                        else {
                            var targetIsOptional = !!(propName && (getPropertyOfType(target, propName) || unknownSymbol).flags & 16777216 /* SymbolFlags.Optional */);
                            var sourceIsOptional = !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags & 16777216 /* SymbolFlags.Optional */);
                            targetPropType = removeMissingType(targetPropType, targetIsOptional);
                            sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional);
                            var result = checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);
                            if (result && specificSource !== sourcePropType) {
                                // If for whatever reason the expression type doesn't yield an error, make sure we still issue an error on the sourcePropType
                                checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);
                            }
                        }
                        if (resultObj.errors) {
                            var reportedDiag = resultObj.errors[resultObj.errors.length - 1];
                            var propertyName = isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined;
                            var targetProp = propertyName !== undefined ? getPropertyOfType(target, propertyName) : undefined;
                            var issuedElaboration = false;
                            if (!targetProp) {
                                var indexInfo = getApplicableIndexInfo(target, nameType);
                                if (indexInfo && indexInfo.declaration && !ts.getSourceFileOfNode(indexInfo.declaration).hasNoDefaultLib) {
                                    issuedElaboration = true;
                                    ts.addRelatedInfo(reportedDiag, ts.createDiagnosticForNode(indexInfo.declaration, ts.Diagnostics.The_expected_type_comes_from_this_index_signature));
                                }
                            }
                            if (!issuedElaboration && (targetProp && ts.length(targetProp.declarations) || target.symbol && ts.length(target.symbol.declarations))) {
                                var targetNode = targetProp && ts.length(targetProp.declarations) ? targetProp.declarations[0] : target.symbol.declarations[0];
                                if (!ts.getSourceFileOfNode(targetNode).hasNoDefaultLib) {
                                    ts.addRelatedInfo(reportedDiag, ts.createDiagnosticForNode(targetNode, ts.Diagnostics.The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1, propertyName && !(nameType.flags & 8192 /* TypeFlags.UniqueESSymbol */) ? ts.unescapeLeadingUnderscores(propertyName) : typeToString(nameType), typeToString(target)));
                                }
                            }
                        }
                    }
                }
            }
            return reportedError;
        }
        function generateJsxAttributes(node) {
            var _i, _a, prop;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!ts.length(node.properties))
                            return [2 /*return*/];
                        _i = 0, _a = node.properties;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 4];
                        prop = _a[_i];
                        if (ts.isJsxSpreadAttribute(prop) || isHyphenatedJsxName(ts.idText(prop.name)))
                            return [3 /*break*/, 3];
                        return [4 /*yield*/, { errorNode: prop.name, innerExpression: prop.initializer, nameType: getStringLiteralType(ts.idText(prop.name)) }];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        }
        function generateJsxChildren(node, getInvalidTextDiagnostic) {
            var memberOffset, i, child, nameType, elem;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!ts.length(node.children))
                            return [2 /*return*/];
                        memberOffset = 0;
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < node.children.length)) return [3 /*break*/, 5];
                        child = node.children[i];
                        nameType = getNumberLiteralType(i - memberOffset);
                        elem = getElaborationElementForJsxChild(child, nameType, getInvalidTextDiagnostic);
                        if (!elem) return [3 /*break*/, 3];
                        return [4 /*yield*/, elem];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        memberOffset++;
                        _a.label = 4;
                    case 4:
                        i++;
                        return [3 /*break*/, 1];
                    case 5: return [2 /*return*/];
                }
            });
        }
        function getElaborationElementForJsxChild(child, nameType, getInvalidTextDiagnostic) {
            switch (child.kind) {
                case 291 /* SyntaxKind.JsxExpression */:
                    // child is of the type of the expression
                    return { errorNode: child, innerExpression: child.expression, nameType: nameType };
                case 11 /* SyntaxKind.JsxText */:
                    if (child.containsOnlyTriviaWhiteSpaces) {
                        break; // Whitespace only jsx text isn't real jsx text
                    }
                    // child is a string
                    return { errorNode: child, innerExpression: undefined, nameType: nameType, errorMessage: getInvalidTextDiagnostic() };
                case 281 /* SyntaxKind.JsxElement */:
                case 282 /* SyntaxKind.JsxSelfClosingElement */:
                case 285 /* SyntaxKind.JsxFragment */:
                    // child is of type JSX.Element
                    return { errorNode: child, innerExpression: child, nameType: nameType };
                default:
                    return ts.Debug.assertNever(child, "Found invalid jsx child");
            }
        }
        function elaborateJsxComponents(node, source, target, relation, containingMessageChain, errorOutputContainer) {
            var result = elaborateElementwise(generateJsxAttributes(node), source, target, relation, containingMessageChain, errorOutputContainer);
            var invalidTextDiagnostic;
            if (ts.isJsxOpeningElement(node.parent) && ts.isJsxElement(node.parent.parent)) {
                var containingElement = node.parent.parent;
                var childPropName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(node));
                var childrenPropName = childPropName === undefined ? "children" : ts.unescapeLeadingUnderscores(childPropName);
                var childrenNameType = getStringLiteralType(childrenPropName);
                var childrenTargetType = getIndexedAccessType(target, childrenNameType);
                var validChildren = ts.getSemanticJsxChildren(containingElement.children);
                if (!ts.length(validChildren)) {
                    return result;
                }
                var moreThanOneRealChildren = ts.length(validChildren) > 1;
                var arrayLikeTargetParts = filterType(childrenTargetType, isArrayOrTupleLikeType);
                var nonArrayLikeTargetParts = filterType(childrenTargetType, function (t) { return !isArrayOrTupleLikeType(t); });
                if (moreThanOneRealChildren) {
                    if (arrayLikeTargetParts !== neverType) {
                        var realSource = createTupleType(checkJsxChildren(containingElement, 0 /* CheckMode.Normal */));
                        var children = generateJsxChildren(containingElement, getInvalidTextualChildDiagnostic);
                        result = elaborateElementwise(children, realSource, arrayLikeTargetParts, relation, containingMessageChain, errorOutputContainer) || result;
                    }
                    else if (!isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation)) {
                        // arity mismatch
                        result = true;
                        var diag = error(containingElement.openingElement.tagName, ts.Diagnostics.This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided, childrenPropName, typeToString(childrenTargetType));
                        if (errorOutputContainer && errorOutputContainer.skipLogging) {
                            (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
                        }
                    }
                }
                else {
                    if (nonArrayLikeTargetParts !== neverType) {
                        var child = validChildren[0];
                        var elem_1 = getElaborationElementForJsxChild(child, childrenNameType, getInvalidTextualChildDiagnostic);
                        if (elem_1) {
                            result = elaborateElementwise((function () { return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, elem_1];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            }); })(), source, target, relation, containingMessageChain, errorOutputContainer) || result;
                        }
                    }
                    else if (!isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation)) {
                        // arity mismatch
                        result = true;
                        var diag = error(containingElement.openingElement.tagName, ts.Diagnostics.This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided, childrenPropName, typeToString(childrenTargetType));
                        if (errorOutputContainer && errorOutputContainer.skipLogging) {
                            (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
                        }
                    }
                }
            }
            return result;
            function getInvalidTextualChildDiagnostic() {
                if (!invalidTextDiagnostic) {
                    var tagNameText = ts.getTextOfNode(node.parent.tagName);
                    var childPropName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(node));
                    var childrenPropName = childPropName === undefined ? "children" : ts.unescapeLeadingUnderscores(childPropName);
                    var childrenTargetType = getIndexedAccessType(target, getStringLiteralType(childrenPropName));
                    var diagnostic = ts.Diagnostics._0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2;
                    invalidTextDiagnostic = __assign(__assign({}, diagnostic), { key: "!!ALREADY FORMATTED!!", message: ts.formatMessage(/*_dummy*/ undefined, diagnostic, tagNameText, childrenPropName, typeToString(childrenTargetType)) });
                }
                return invalidTextDiagnostic;
            }
        }
        function generateLimitedTupleElements(node, target) {
            var len, i, elem, nameType;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        len = ts.length(node.elements);
                        if (!len)
                            return [2 /*return*/];
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < len)) return [3 /*break*/, 4];
                        // Skip elements which do not exist in the target - a length error on the tuple overall is likely better than an error on a mismatched index signature
                        if (isTupleLikeType(target) && !getPropertyOfType(target, ("" + i)))
                            return [3 /*break*/, 3];
                        elem = node.elements[i];
                        if (ts.isOmittedExpression(elem))
                            return [3 /*break*/, 3];
                        nameType = getNumberLiteralType(i);
                        return [4 /*yield*/, { errorNode: elem, innerExpression: elem, nameType: nameType }];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        }
        function elaborateArrayLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer) {
            if (target.flags & (131068 /* TypeFlags.Primitive */ | 131072 /* TypeFlags.Never */))
                return false;
            if (isTupleLikeType(source)) {
                return elaborateElementwise(generateLimitedTupleElements(node, target), source, target, relation, containingMessageChain, errorOutputContainer);
            }
            // recreate a tuple from the elements, if possible
            // Since we're re-doing the expression type, we need to reapply the contextual type
            var oldContext = node.contextualType;
            node.contextualType = target;
            try {
                var tupleizedType = checkArrayLiteral(node, 1 /* CheckMode.Contextual */, /*forceTuple*/ true);
                node.contextualType = oldContext;
                if (isTupleLikeType(tupleizedType)) {
                    return elaborateElementwise(generateLimitedTupleElements(node, target), tupleizedType, target, relation, containingMessageChain, errorOutputContainer);
                }
                return false;
            }
            finally {
                node.contextualType = oldContext;
            }
        }
        function generateObjectLiteralElements(node) {
            var _i, _a, prop, type, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!ts.length(node.properties))
                            return [2 /*return*/];
                        _i = 0, _a = node.properties;
                        _c.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 8];
                        prop = _a[_i];
                        if (ts.isSpreadAssignment(prop))
                            return [3 /*break*/, 7];
                        type = getLiteralTypeFromProperty(getSymbolOfNode(prop), 8576 /* TypeFlags.StringOrNumberLiteralOrUnique */);
                        if (!type || (type.flags & 131072 /* TypeFlags.Never */)) {
                            return [3 /*break*/, 7];
                        }
                        _b = prop.kind;
                        switch (_b) {
                            case 175 /* SyntaxKind.SetAccessor */: return [3 /*break*/, 2];
                            case 174 /* SyntaxKind.GetAccessor */: return [3 /*break*/, 2];
                            case 171 /* SyntaxKind.MethodDeclaration */: return [3 /*break*/, 2];
                            case 300 /* SyntaxKind.ShorthandPropertyAssignment */: return [3 /*break*/, 2];
                            case 299 /* SyntaxKind.PropertyAssignment */: return [3 /*break*/, 4];
                        }
                        return [3 /*break*/, 6];
                    case 2: return [4 /*yield*/, { errorNode: prop.name, innerExpression: undefined, nameType: type }];
                    case 3:
                        _c.sent();
                        return [3 /*break*/, 7];
                    case 4: return [4 /*yield*/, { errorNode: prop.name, innerExpression: prop.initializer, nameType: type, errorMessage: ts.isComputedNonLiteralName(prop.name) ? ts.Diagnostics.Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1 : undefined }];
                    case 5:
                        _c.sent();
                        return [3 /*break*/, 7];
                    case 6:
                        ts.Debug.assertNever(prop);
                        _c.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 1];
                    case 8: return [2 /*return*/];
                }
            });
        }
        function elaborateObjectLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer) {
            if (target.flags & (131068 /* TypeFlags.Primitive */ | 131072 /* TypeFlags.Never */))
                return false;
            return elaborateElementwise(generateObjectLiteralElements(node), source, target, relation, containingMessageChain, errorOutputContainer);
        }
        /**
         * This is *not* a bi-directional relationship.
         * If one needs to check both directions for comparability, use a second call to this function or 'isTypeComparableTo'.
         */
        function checkTypeComparableTo(source, target, errorNode, headMessage, containingMessageChain) {
            return checkTypeRelatedTo(source, target, comparableRelation, errorNode, headMessage, containingMessageChain);
        }
        function isSignatureAssignableTo(source, target, ignoreReturnTypes) {
            return compareSignaturesRelated(source, target, ignoreReturnTypes ? 4 /* SignatureCheckMode.IgnoreReturnTypes */ : 0, /*reportErrors*/ false, 
            /*errorReporter*/ undefined, /*errorReporter*/ undefined, compareTypesAssignable, /*reportUnreliableMarkers*/ undefined) !== 0 /* Ternary.False */;
        }
        /**
         * Returns true if `s` is `(...args: any[]) => any` or `(this: any, ...args: any[]) => any`
         */
        function isAnySignature(s) {
            return !s.typeParameters && (!s.thisParameter || isTypeAny(getTypeOfParameter(s.thisParameter))) && s.parameters.length === 1 &&
                signatureHasRestParameter(s) && (getTypeOfParameter(s.parameters[0]) === anyArrayType || isTypeAny(getTypeOfParameter(s.parameters[0]))) &&
                isTypeAny(getReturnTypeOfSignature(s));
        }
        /**
         * See signatureRelatedTo, compareSignaturesIdentical
         */
        function compareSignaturesRelated(source, target, checkMode, reportErrors, errorReporter, incompatibleErrorReporter, compareTypes, reportUnreliableMarkers) {
            // TODO (drosen): De-duplicate code between related functions.
            if (source === target) {
                return -1 /* Ternary.True */;
            }
            if (isAnySignature(target)) {
                return -1 /* Ternary.True */;
            }
            var targetCount = getParameterCount(target);
            var sourceHasMoreParameters = !hasEffectiveRestParameter(target) &&
                (checkMode & 8 /* SignatureCheckMode.StrictArity */ ? hasEffectiveRestParameter(source) || getParameterCount(source) > targetCount : getMinArgumentCount(source) > targetCount);
            if (sourceHasMoreParameters) {
                return 0 /* Ternary.False */;
            }
            if (source.typeParameters && source.typeParameters !== target.typeParameters) {
                target = getCanonicalSignature(target);
                source = instantiateSignatureInContextOf(source, target, /*inferenceContext*/ undefined, compareTypes);
            }
            var sourceCount = getParameterCount(source);
            var sourceRestType = getNonArrayRestType(source);
            var targetRestType = getNonArrayRestType(target);
            if (sourceRestType || targetRestType) {
                void instantiateType(sourceRestType || targetRestType, reportUnreliableMarkers);
            }
            var kind = target.declaration ? target.declaration.kind : 0 /* SyntaxKind.Unknown */;
            var strictVariance = !(checkMode & 3 /* SignatureCheckMode.Callback */) && strictFunctionTypes && kind !== 171 /* SyntaxKind.MethodDeclaration */ &&
                kind !== 170 /* SyntaxKind.MethodSignature */ && kind !== 173 /* SyntaxKind.Constructor */;
            var result = -1 /* Ternary.True */;
            var sourceThisType = getThisTypeOfSignature(source);
            if (sourceThisType && sourceThisType !== voidType) {
                var targetThisType = getThisTypeOfSignature(target);
                if (targetThisType) {
                    // void sources are assignable to anything.
                    var related = !strictVariance && compareTypes(sourceThisType, targetThisType, /*reportErrors*/ false)
                        || compareTypes(targetThisType, sourceThisType, reportErrors);
                    if (!related) {
                        if (reportErrors) {
                            errorReporter(ts.Diagnostics.The_this_types_of_each_signature_are_incompatible);
                        }
                        return 0 /* Ternary.False */;
                    }
                    result &= related;
                }
            }
            var paramCount = sourceRestType || targetRestType ? Math.min(sourceCount, targetCount) : Math.max(sourceCount, targetCount);
            var restIndex = sourceRestType || targetRestType ? paramCount - 1 : -1;
            for (var i = 0; i < paramCount; i++) {
                var sourceType = i === restIndex ? getRestTypeAtPosition(source, i) : tryGetTypeAtPosition(source, i);
                var targetType = i === restIndex ? getRestTypeAtPosition(target, i) : tryGetTypeAtPosition(target, i);
                if (sourceType && targetType) {
                    // In order to ensure that any generic type Foo<T> is at least co-variant with respect to T no matter
                    // how Foo uses T, we need to relate parameters bi-variantly (given that parameters are input positions,
                    // they naturally relate only contra-variantly). However, if the source and target parameters both have
                    // function types with a single call signature, we know we are relating two callback parameters. In
                    // that case it is sufficient to only relate the parameters of the signatures co-variantly because,
                    // similar to return values, callback parameters are output positions. This means that a Promise<T>,
                    // where T is used only in callback parameter positions, will be co-variant (as opposed to bi-variant)
                    // with respect to T.
                    var sourceSig = checkMode & 3 /* SignatureCheckMode.Callback */ ? undefined : getSingleCallSignature(getNonNullableType(sourceType));
                    var targetSig = checkMode & 3 /* SignatureCheckMode.Callback */ ? undefined : getSingleCallSignature(getNonNullableType(targetType));
                    var callbacks = sourceSig && targetSig && !getTypePredicateOfSignature(sourceSig) && !getTypePredicateOfSignature(targetSig) &&
                        (getTypeFacts(sourceType) & 50331648 /* TypeFacts.IsUndefinedOrNull */) === (getTypeFacts(targetType) & 50331648 /* TypeFacts.IsUndefinedOrNull */);
                    var related = callbacks ?
                        compareSignaturesRelated(targetSig, sourceSig, (checkMode & 8 /* SignatureCheckMode.StrictArity */) | (strictVariance ? 2 /* SignatureCheckMode.StrictCallback */ : 1 /* SignatureCheckMode.BivariantCallback */), reportErrors, errorReporter, incompatibleErrorReporter, compareTypes, reportUnreliableMarkers) :
                        !(checkMode & 3 /* SignatureCheckMode.Callback */) && !strictVariance && compareTypes(sourceType, targetType, /*reportErrors*/ false) || compareTypes(targetType, sourceType, reportErrors);
                    // With strict arity, (x: number | undefined) => void is a subtype of (x?: number | undefined) => void
                    if (related && checkMode & 8 /* SignatureCheckMode.StrictArity */ && i >= getMinArgumentCount(source) && i < getMinArgumentCount(target) && compareTypes(sourceType, targetType, /*reportErrors*/ false)) {
                        related = 0 /* Ternary.False */;
                    }
                    if (!related) {
                        if (reportErrors) {
                            errorReporter(ts.Diagnostics.Types_of_parameters_0_and_1_are_incompatible, ts.unescapeLeadingUnderscores(getParameterNameAtPosition(source, i)), ts.unescapeLeadingUnderscores(getParameterNameAtPosition(target, i)));
                        }
                        return 0 /* Ternary.False */;
                    }
                    result &= related;
                }
            }
            if (!(checkMode & 4 /* SignatureCheckMode.IgnoreReturnTypes */)) {
                // If a signature resolution is already in-flight, skip issuing a circularity error
                // here and just use the `any` type directly
                var targetReturnType = isResolvingReturnTypeOfSignature(target) ? anyType
                    : target.declaration && isJSConstructor(target.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(target.declaration.symbol))
                        : getReturnTypeOfSignature(target);
                if (targetReturnType === voidType || targetReturnType === anyType) {
                    return result;
                }
                var sourceReturnType = isResolvingReturnTypeOfSignature(source) ? anyType
                    : source.declaration && isJSConstructor(source.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(source.declaration.symbol))
                        : getReturnTypeOfSignature(source);
                // The following block preserves behavior forbidding boolean returning functions from being assignable to type guard returning functions
                var targetTypePredicate = getTypePredicateOfSignature(target);
                if (targetTypePredicate) {
                    var sourceTypePredicate = getTypePredicateOfSignature(source);
                    if (sourceTypePredicate) {
                        result &= compareTypePredicateRelatedTo(sourceTypePredicate, targetTypePredicate, reportErrors, errorReporter, compareTypes);
                    }
                    else if (ts.isIdentifierTypePredicate(targetTypePredicate)) {
                        if (reportErrors) {
                            errorReporter(ts.Diagnostics.Signature_0_must_be_a_type_predicate, signatureToString(source));
                        }
                        return 0 /* Ternary.False */;
                    }
                }
                else {
                    // When relating callback signatures, we still need to relate return types bi-variantly as otherwise
                    // the containing type wouldn't be co-variant. For example, interface Foo<T> { add(cb: () => T): void }
                    // wouldn't be co-variant for T without this rule.
                    result &= checkMode & 1 /* SignatureCheckMode.BivariantCallback */ && compareTypes(targetReturnType, sourceReturnType, /*reportErrors*/ false) ||
                        compareTypes(sourceReturnType, targetReturnType, reportErrors);
                    if (!result && reportErrors && incompatibleErrorReporter) {
                        incompatibleErrorReporter(sourceReturnType, targetReturnType);
                    }
                }
            }
            return result;
        }
        function compareTypePredicateRelatedTo(source, target, reportErrors, errorReporter, compareTypes) {
            if (source.kind !== target.kind) {
                if (reportErrors) {
                    errorReporter(ts.Diagnostics.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard);
                    errorReporter(ts.Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
                }
                return 0 /* Ternary.False */;
            }
            if (source.kind === 1 /* TypePredicateKind.Identifier */ || source.kind === 3 /* TypePredicateKind.AssertsIdentifier */) {
                if (source.parameterIndex !== target.parameterIndex) {
                    if (reportErrors) {
                        errorReporter(ts.Diagnostics.Parameter_0_is_not_in_the_same_position_as_parameter_1, source.parameterName, target.parameterName);
                        errorReporter(ts.Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
                    }
                    return 0 /* Ternary.False */;
                }
            }
            var related = source.type === target.type ? -1 /* Ternary.True */ :
                source.type && target.type ? compareTypes(source.type, target.type, reportErrors) :
                    0 /* Ternary.False */;
            if (related === 0 /* Ternary.False */ && reportErrors) {
                errorReporter(ts.Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
            }
            return related;
        }
        function isImplementationCompatibleWithOverload(implementation, overload) {
            var erasedSource = getErasedSignature(implementation);
            var erasedTarget = getErasedSignature(overload);
            // First see if the return types are compatible in either direction.
            var sourceReturnType = getReturnTypeOfSignature(erasedSource);
            var targetReturnType = getReturnTypeOfSignature(erasedTarget);
            if (targetReturnType === voidType
                || isTypeRelatedTo(targetReturnType, sourceReturnType, assignableRelation)
                || isTypeRelatedTo(sourceReturnType, targetReturnType, assignableRelation)) {
                return isSignatureAssignableTo(erasedSource, erasedTarget, /*ignoreReturnTypes*/ true);
            }
            return false;
        }
        function isEmptyResolvedType(t) {
            return t !== anyFunctionType &&
                t.properties.length === 0 &&
                t.callSignatures.length === 0 &&
                t.constructSignatures.length === 0 &&
                t.indexInfos.length === 0;
        }
        function isEmptyObjectType(type) {
            return type.flags & 524288 /* TypeFlags.Object */ ? !isGenericMappedType(type) && isEmptyResolvedType(resolveStructuredTypeMembers(type)) :
                type.flags & 67108864 /* TypeFlags.NonPrimitive */ ? true :
                    type.flags & 1048576 /* TypeFlags.Union */ ? ts.some(type.types, isEmptyObjectType) :
                        type.flags & 2097152 /* TypeFlags.Intersection */ ? ts.every(type.types, isEmptyObjectType) :
                            false;
        }
        function isEmptyAnonymousObjectType(type) {
            return !!(ts.getObjectFlags(type) & 16 /* ObjectFlags.Anonymous */ && (type.members && isEmptyResolvedType(type) ||
                type.symbol && type.symbol.flags & 2048 /* SymbolFlags.TypeLiteral */ && getMembersOfSymbol(type.symbol).size === 0));
        }
        function isUnknownLikeUnionType(type) {
            if (strictNullChecks && type.flags & 1048576 /* TypeFlags.Union */) {
                if (!(type.objectFlags & 33554432 /* ObjectFlags.IsUnknownLikeUnionComputed */)) {
                    var types = type.types;
                    type.objectFlags |= 33554432 /* ObjectFlags.IsUnknownLikeUnionComputed */ | (types.length >= 3 && types[0].flags & 32768 /* TypeFlags.Undefined */ &&
                        types[1].flags & 65536 /* TypeFlags.Null */ && ts.some(types, isEmptyAnonymousObjectType) ? 67108864 /* ObjectFlags.IsUnknownLikeUnion */ : 0);
                }
                return !!(type.objectFlags & 67108864 /* ObjectFlags.IsUnknownLikeUnion */);
            }
            return false;
        }
        function containsUndefinedType(type) {
            return !!((type.flags & 1048576 /* TypeFlags.Union */ ? type.types[0] : type).flags & 32768 /* TypeFlags.Undefined */);
        }
        function isStringIndexSignatureOnlyType(type) {
            return type.flags & 524288 /* TypeFlags.Object */ && !isGenericMappedType(type) && getPropertiesOfType(type).length === 0 && getIndexInfosOfType(type).length === 1 && !!getIndexInfoOfType(type, stringType) ||
                type.flags & 3145728 /* TypeFlags.UnionOrIntersection */ && ts.every(type.types, isStringIndexSignatureOnlyType) ||
                false;
        }
        function isEnumTypeRelatedTo(sourceSymbol, targetSymbol, errorReporter) {
            if (sourceSymbol === targetSymbol) {
                return true;
            }
            var id = getSymbolId(sourceSymbol) + "," + getSymbolId(targetSymbol);
            var entry = enumRelation.get(id);
            if (entry !== undefined && !(!(entry & 4 /* RelationComparisonResult.Reported */) && entry & 2 /* RelationComparisonResult.Failed */ && errorReporter)) {
                return !!(entry & 1 /* RelationComparisonResult.Succeeded */);
            }
            if (sourceSymbol.escapedName !== targetSymbol.escapedName || !(sourceSymbol.flags & 256 /* SymbolFlags.RegularEnum */) || !(targetSymbol.flags & 256 /* SymbolFlags.RegularEnum */)) {
                enumRelation.set(id, 2 /* RelationComparisonResult.Failed */ | 4 /* RelationComparisonResult.Reported */);
                return false;
            }
            var targetEnumType = getTypeOfSymbol(targetSymbol);
            for (var _i = 0, _a = getPropertiesOfType(getTypeOfSymbol(sourceSymbol)); _i < _a.length; _i++) {
                var property = _a[_i];
                if (property.flags & 8 /* SymbolFlags.EnumMember */) {
                    var targetProperty = getPropertyOfType(targetEnumType, property.escapedName);
                    if (!targetProperty || !(targetProperty.flags & 8 /* SymbolFlags.EnumMember */)) {
                        if (errorReporter) {
                            errorReporter(ts.Diagnostics.Property_0_is_missing_in_type_1, ts.symbolName(property), typeToString(getDeclaredTypeOfSymbol(targetSymbol), /*enclosingDeclaration*/ undefined, 64 /* TypeFormatFlags.UseFullyQualifiedType */));
                            enumRelation.set(id, 2 /* RelationComparisonResult.Failed */ | 4 /* RelationComparisonResult.Reported */);
                        }
                        else {
                            enumRelation.set(id, 2 /* RelationComparisonResult.Failed */);
                        }
                        return false;
                    }
                }
            }
            enumRelation.set(id, 1 /* RelationComparisonResult.Succeeded */);
            return true;
        }
        function isSimpleTypeRelatedTo(source, target, relation, errorReporter) {
            var s = source.flags;
            var t = target.flags;
            if (t & 3 /* TypeFlags.AnyOrUnknown */ || s & 131072 /* TypeFlags.Never */ || source === wildcardType)
                return true;
            if (t & 131072 /* TypeFlags.Never */)
                return false;
            if (s & 402653316 /* TypeFlags.StringLike */ && t & 4 /* TypeFlags.String */)
                return true;
            if (s & 128 /* TypeFlags.StringLiteral */ && s & 1024 /* TypeFlags.EnumLiteral */ &&
                t & 128 /* TypeFlags.StringLiteral */ && !(t & 1024 /* TypeFlags.EnumLiteral */) &&
                source.value === target.value)
                return true;
            if (s & 296 /* TypeFlags.NumberLike */ && t & 8 /* TypeFlags.Number */)
                return true;
            if (s & 256 /* TypeFlags.NumberLiteral */ && s & 1024 /* TypeFlags.EnumLiteral */ &&
                t & 256 /* TypeFlags.NumberLiteral */ && !(t & 1024 /* TypeFlags.EnumLiteral */) &&
                source.value === target.value)
                return true;
            if (s & 2112 /* TypeFlags.BigIntLike */ && t & 64 /* TypeFlags.BigInt */)
                return true;
            if (s & 528 /* TypeFlags.BooleanLike */ && t & 16 /* TypeFlags.Boolean */)
                return true;
            if (s & 12288 /* TypeFlags.ESSymbolLike */ && t & 4096 /* TypeFlags.ESSymbol */)
                return true;
            if (s & 32 /* TypeFlags.Enum */ && t & 32 /* TypeFlags.Enum */ && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter))
                return true;
            if (s & 1024 /* TypeFlags.EnumLiteral */ && t & 1024 /* TypeFlags.EnumLiteral */) {
                if (s & 1048576 /* TypeFlags.Union */ && t & 1048576 /* TypeFlags.Union */ && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter))
                    return true;
                if (s & 2944 /* TypeFlags.Literal */ && t & 2944 /* TypeFlags.Literal */ &&
                    source.value === target.value &&
                    isEnumTypeRelatedTo(getParentOfSymbol(source.symbol), getParentOfSymbol(target.symbol), errorReporter))
                    return true;
            }
            // In non-strictNullChecks mode, `undefined` and `null` are assignable to anything except `never`.
            // Since unions and intersections may reduce to `never`, we exclude them here.
            if (s & 32768 /* TypeFlags.Undefined */ && (!strictNullChecks && !(t & 3145728 /* TypeFlags.UnionOrIntersection */) || t & (32768 /* TypeFlags.Undefined */ | 16384 /* TypeFlags.Void */)))
                return true;
            if (s & 65536 /* TypeFlags.Null */ && (!strictNullChecks && !(t & 3145728 /* TypeFlags.UnionOrIntersection */) || t & 65536 /* TypeFlags.Null */))
                return true;
            if (s & 524288 /* TypeFlags.Object */ && t & 67108864 /* TypeFlags.NonPrimitive */ && !(relation === strictSubtypeRelation && isEmptyAnonymousObjectType(source) && !(ts.getObjectFlags(source) & 8192 /* ObjectFlags.FreshLiteral */)))
                return true;
            if (relation === assignableRelation || relation === comparableRelation) {
                if (s & 1 /* TypeFlags.Any */)
                    return true;
                // Type number or any numeric literal type is assignable to any numeric enum type or any
                // numeric enum literal type. This rule exists for backwards compatibility reasons because
                // bit-flag enum types sometimes look like literal enum types with numeric literal values.
                if (s & (8 /* TypeFlags.Number */ | 256 /* TypeFlags.NumberLiteral */) && !(s & 1024 /* TypeFlags.EnumLiteral */) && (t & 32 /* TypeFlags.Enum */ || relation === assignableRelation && t & 256 /* TypeFlags.NumberLiteral */ && t & 1024 /* TypeFlags.EnumLiteral */))
                    return true;
                // Anything is assignable to a union containing undefined, null, and {}
                if (isUnknownLikeUnionType(target))
                    return true;
            }
            return false;
        }
        function isTypeRelatedTo(source, target, relation) {
            if (isFreshLiteralType(source)) {
                source = source.regularType;
            }
            if (isFreshLiteralType(target)) {
                target = target.regularType;
            }
            if (source === target) {
                return true;
            }
            if (relation !== identityRelation) {
                if (relation === comparableRelation && !(target.flags & 131072 /* TypeFlags.Never */) && isSimpleTypeRelatedTo(target, source, relation) || isSimpleTypeRelatedTo(source, target, relation)) {
                    return true;
                }
            }
            else if (!((source.flags | target.flags) & (3145728 /* TypeFlags.UnionOrIntersection */ | 8388608 /* TypeFlags.IndexedAccess */ | 16777216 /* TypeFlags.Conditional */ | 33554432 /* TypeFlags.Substitution */))) {
                // We have excluded types that may simplify to other forms, so types must have identical flags
                if (source.flags !== target.flags)
                    return false;
                if (source.flags & 67358815 /* TypeFlags.Singleton */)
                    return true;
            }
            if (source.flags & 524288 /* TypeFlags.Object */ && target.flags & 524288 /* TypeFlags.Object */) {
                var related = relation.get(getRelationKey(source, target, 0 /* IntersectionState.None */, relation, /*ignoreConstraints*/ false));
                if (related !== undefined) {
                    return !!(related & 1 /* RelationComparisonResult.Succeeded */);
                }
            }
            if (source.flags & 469499904 /* TypeFlags.StructuredOrInstantiable */ || target.flags & 469499904 /* TypeFlags.StructuredOrInstantiable */) {
                return checkTypeRelatedTo(source, target, relation, /*errorNode*/ undefined);
            }
            return false;
        }
        function isIgnoredJsxProperty(source, sourceProp) {
            return ts.getObjectFlags(source) & 2048 /* ObjectFlags.JsxAttributes */ && isHyphenatedJsxName(sourceProp.escapedName);
        }
        function getNormalizedType(type, writing) {
            while (true) {
                var t = isFreshLiteralType(type) ? type.regularType :
                    ts.getObjectFlags(type) & 4 /* ObjectFlags.Reference */ ? type.node ? createTypeReference(type.target, getTypeArguments(type)) : getSingleBaseForNonAugmentingSubtype(type) || type :
                        type.flags & 3145728 /* TypeFlags.UnionOrIntersection */ ? getNormalizedUnionOrIntersectionType(type, writing) :
                            type.flags & 33554432 /* TypeFlags.Substitution */ ? writing ? type.baseType : getSubstitutionIntersection(type) :
                                type.flags & 25165824 /* TypeFlags.Simplifiable */ ? getSimplifiedType(type, writing) :
                                    type;
                if (t === type)
                    return t;
                type = t;
            }
        }
        function getNormalizedUnionOrIntersectionType(type, writing) {
            var reduced = getReducedType(type);
            if (reduced !== type) {
                return reduced;
            }
            if (type.flags & 2097152 /* TypeFlags.Intersection */ && ts.some(type.types, isEmptyAnonymousObjectType)) {
                var normalizedTypes = ts.sameMap(type.types, function (t) { return getNormalizedType(t, writing); });
                if (normalizedTypes !== type.types) {
                    return getIntersectionType(normalizedTypes);
                }
            }
            return type;
        }
        /**
         * Checks if 'source' is related to 'target' (e.g.: is a assignable to).
         * @param source The left-hand-side of the relation.
         * @param target The right-hand-side of the relation.
         * @param relation The relation considered. One of 'identityRelation', 'subtypeRelation', 'assignableRelation', or 'comparableRelation'.
         * Used as both to determine which checks are performed and as a cache of previously computed results.
         * @param errorNode The suggested node upon which all errors will be reported, if defined. This may or may not be the actual node used.
         * @param headMessage If the error chain should be prepended by a head message, then headMessage will be used.
         * @param containingMessageChain A chain of errors to prepend any new errors found.
         * @param errorOutputContainer Return the diagnostic. Do not log if 'skipLogging' is truthy.
         */
        function checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer) {
            var errorInfo;
            var relatedInfo;
            var maybeKeys;
            var sourceStack;
            var targetStack;
            var maybeCount = 0;
            var sourceDepth = 0;
            var targetDepth = 0;
            var expandingFlags = 0 /* ExpandingFlags.None */;
            var overflow = false;
            var overrideNextErrorInfo = 0; // How many `reportRelationError` calls should be skipped in the elaboration pyramid
            var lastSkippedInfo;
            var incompatibleStack;
            var inPropertyCheck = false;
            ts.Debug.assert(relation !== identityRelation || !errorNode, "no error reporting in identity checking");
            var result = isRelatedTo(source, target, 3 /* RecursionFlags.Both */, /*reportErrors*/ !!errorNode, headMessage);
            if (incompatibleStack) {
                reportIncompatibleStack();
            }
            if (overflow) {
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.instant("checkTypes" /* tracing.Phase.CheckTypes */, "checkTypeRelatedTo_DepthLimit", { sourceId: source.id, targetId: target.id, depth: sourceDepth, targetDepth: targetDepth });
                var diag = error(errorNode || currentNode, ts.Diagnostics.Excessive_stack_depth_comparing_types_0_and_1, typeToString(source), typeToString(target));
                if (errorOutputContainer) {
                    (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
                }
            }
            else if (errorInfo) {
                if (containingMessageChain) {
                    var chain = containingMessageChain();
                    if (chain) {
                        ts.concatenateDiagnosticMessageChains(chain, errorInfo);
                        errorInfo = chain;
                    }
                }
                var relatedInformation = void 0;
                // Check if we should issue an extra diagnostic to produce a quickfix for a slightly incorrect import statement
                if (headMessage && errorNode && !result && source.symbol) {
                    var links = getSymbolLinks(source.symbol);
                    if (links.originatingImport && !ts.isImportCall(links.originatingImport)) {
                        var helpfulRetry = checkTypeRelatedTo(getTypeOfSymbol(links.target), target, relation, /*errorNode*/ undefined);
                        if (helpfulRetry) {
                            // Likely an incorrect import. Issue a helpful diagnostic to produce a quickfix to change the import
                            var diag_1 = ts.createDiagnosticForNode(links.originatingImport, ts.Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead);
                            relatedInformation = ts.append(relatedInformation, diag_1); // Cause the error to appear with the error that triggered it
                        }
                    }
                }
                var diag = ts.createDiagnosticForNodeFromMessageChain(errorNode, errorInfo, relatedInformation);
                if (relatedInfo) {
                    ts.addRelatedInfo.apply(void 0, __spreadArray([diag], relatedInfo, false));
                }
                if (errorOutputContainer) {
                    (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
                }
                if (!errorOutputContainer || !errorOutputContainer.skipLogging) {
                    diagnostics.add(diag);
                }
            }
            if (errorNode && errorOutputContainer && errorOutputContainer.skipLogging && result === 0 /* Ternary.False */) {
                ts.Debug.assert(!!errorOutputContainer.errors, "missed opportunity to interact with error.");
            }
            return result !== 0 /* Ternary.False */;
            function resetErrorInfo(saved) {
                errorInfo = saved.errorInfo;
                lastSkippedInfo = saved.lastSkippedInfo;
                incompatibleStack = saved.incompatibleStack;
                overrideNextErrorInfo = saved.overrideNextErrorInfo;
                relatedInfo = saved.relatedInfo;
            }
            function captureErrorCalculationState() {
                return {
                    errorInfo: errorInfo,
                    lastSkippedInfo: lastSkippedInfo,
                    incompatibleStack: incompatibleStack === null || incompatibleStack === void 0 ? void 0 : incompatibleStack.slice(),
                    overrideNextErrorInfo: overrideNextErrorInfo,
                    relatedInfo: relatedInfo === null || relatedInfo === void 0 ? void 0 : relatedInfo.slice(),
                };
            }
            function reportIncompatibleError(message, arg0, arg1, arg2, arg3) {
                overrideNextErrorInfo++; // Suppress the next relation error
                lastSkippedInfo = undefined; // Reset skipped info cache
                (incompatibleStack || (incompatibleStack = [])).push([message, arg0, arg1, arg2, arg3]);
            }
            function reportIncompatibleStack() {
                var stack = incompatibleStack || [];
                incompatibleStack = undefined;
                var info = lastSkippedInfo;
                lastSkippedInfo = undefined;
                if (stack.length === 1) {
                    reportError.apply(void 0, stack[0]);
                    if (info) {
                        // Actually do the last relation error
                        reportRelationError.apply(void 0, __spreadArray([/*headMessage*/ undefined], info, false));
                    }
                    return;
                }
                // The first error will be the innermost, while the last will be the outermost - so by popping off the end,
                // we can build from left to right
                var path = "";
                var secondaryRootErrors = [];
                while (stack.length) {
                    var _a = stack.pop(), msg = _a[0], args = _a.slice(1);
                    switch (msg.code) {
                        case ts.Diagnostics.Types_of_property_0_are_incompatible.code: {
                            // Parenthesize a `new` if there is one
                            if (path.indexOf("new ") === 0) {
                                path = "(".concat(path, ")");
                            }
                            var str = "" + args[0];
                            // If leading, just print back the arg (irrespective of if it's a valid identifier)
                            if (path.length === 0) {
                                path = "".concat(str);
                            }
                            // Otherwise write a dotted name if possible
                            else if (ts.isIdentifierText(str, ts.getEmitScriptTarget(compilerOptions))) {
                                path = "".concat(path, ".").concat(str);
                            }
                            // Failing that, check if the name is already a computed name
                            else if (str[0] === "[" && str[str.length - 1] === "]") {
                                path = "".concat(path).concat(str);
                            }
                            // And finally write out a computed name as a last resort
                            else {
                                path = "".concat(path, "[").concat(str, "]");
                            }
                            break;
                        }
                        case ts.Diagnostics.Call_signature_return_types_0_and_1_are_incompatible.code:
                        case ts.Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code:
                        case ts.Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code:
                        case ts.Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code: {
                            if (path.length === 0) {
                                // Don't flatten signature compatability errors at the start of a chain - instead prefer
                                // to unify (the with no arguments bit is excessive for printback) and print them back
                                var mappedMsg = msg;
                                if (msg.code === ts.Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) {
                                    mappedMsg = ts.Diagnostics.Call_signature_return_types_0_and_1_are_incompatible;
                                }
                                else if (msg.code === ts.Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) {
                                    mappedMsg = ts.Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible;
                                }
                                secondaryRootErrors.unshift([mappedMsg, args[0], args[1]]);
                            }
                            else {
                                var prefix = (msg.code === ts.Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code ||
                                    msg.code === ts.Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code)
                                    ? "new "
                                    : "";
                                var params = (msg.code === ts.Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code ||
                                    msg.code === ts.Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code)
                                    ? ""
                                    : "...";
                                path = "".concat(prefix).concat(path, "(").concat(params, ")");
                            }
                            break;
                        }
                        case ts.Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target.code: {
                            secondaryRootErrors.unshift([ts.Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, args[0], args[1]]);
                            break;
                        }
                        case ts.Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target.code: {
                            secondaryRootErrors.unshift([ts.Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, args[0], args[1], args[2]]);
                            break;
                        }
                        default:
                            return ts.Debug.fail("Unhandled Diagnostic: ".concat(msg.code));
                    }
                }
                if (path) {
                    reportError(path[path.length - 1] === ")"
                        ? ts.Diagnostics.The_types_returned_by_0_are_incompatible_between_these_types
                        : ts.Diagnostics.The_types_of_0_are_incompatible_between_these_types, path);
                }
                else {
                    // Remove the innermost secondary error as it will duplicate the error already reported by `reportRelationError` on entry
                    secondaryRootErrors.shift();
                }
                for (var _i = 0, secondaryRootErrors_1 = secondaryRootErrors; _i < secondaryRootErrors_1.length; _i++) {
                    var _b = secondaryRootErrors_1[_i], msg = _b[0], args = _b.slice(1);
                    var originalValue = msg.elidedInCompatabilityPyramid;
                    msg.elidedInCompatabilityPyramid = false; // Temporarily override elision to ensure error is reported
                    reportError.apply(void 0, __spreadArray([msg], args, false));
                    msg.elidedInCompatabilityPyramid = originalValue;
                }
                if (info) {
                    // Actually do the last relation error
                    reportRelationError.apply(void 0, __spreadArray([/*headMessage*/ undefined], info, false));
                }
            }
            function reportError(message, arg0, arg1, arg2, arg3) {
                ts.Debug.assert(!!errorNode);
                if (incompatibleStack)
                    reportIncompatibleStack();
                if (message.elidedInCompatabilityPyramid)
                    return;
                errorInfo = ts.chainDiagnosticMessages(errorInfo, message, arg0, arg1, arg2, arg3);
            }
            function associateRelatedInfo(info) {
                ts.Debug.assert(!!errorInfo);
                if (!relatedInfo) {
                    relatedInfo = [info];
                }
                else {
                    relatedInfo.push(info);
                }
            }
            function reportRelationError(message, source, target) {
                if (incompatibleStack)
                    reportIncompatibleStack();
                var _a = getTypeNamesForErrorDisplay(source, target), sourceType = _a[0], targetType = _a[1];
                var generalizedSource = source;
                var generalizedSourceType = sourceType;
                if (isLiteralType(source) && !typeCouldHaveTopLevelSingletonTypes(target)) {
                    generalizedSource = getBaseTypeOfLiteralType(source);
                    ts.Debug.assert(!isTypeAssignableTo(generalizedSource, target), "generalized source shouldn't be assignable");
                    generalizedSourceType = getTypeNameForErrorDisplay(generalizedSource);
                }
                if (target.flags & 262144 /* TypeFlags.TypeParameter */ && target !== markerSuperTypeForCheck && target !== markerSubTypeForCheck) {
                    var constraint = getBaseConstraintOfType(target);
                    var needsOriginalSource = void 0;
                    if (constraint && (isTypeAssignableTo(generalizedSource, constraint) || (needsOriginalSource = isTypeAssignableTo(source, constraint)))) {
                        reportError(ts.Diagnostics._0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2, needsOriginalSource ? sourceType : generalizedSourceType, targetType, typeToString(constraint));
                    }
                    else {
                        errorInfo = undefined;
                        reportError(ts.Diagnostics._0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1, targetType, generalizedSourceType);
                    }
                }
                if (!message) {
                    if (relation === comparableRelation) {
                        message = ts.Diagnostics.Type_0_is_not_comparable_to_type_1;
                    }
                    else if (sourceType === targetType) {
                        message = ts.Diagnostics.Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated;
                    }
                    else if (exactOptionalPropertyTypes && getExactOptionalUnassignableProperties(source, target).length) {
                        message = ts.Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties;
                    }
                    else {
                        if (source.flags & 128 /* TypeFlags.StringLiteral */ && target.flags & 1048576 /* TypeFlags.Union */) {
                            var suggestedType = getSuggestedTypeForNonexistentStringLiteralType(source, target);
                            if (suggestedType) {
                                reportError(ts.Diagnostics.Type_0_is_not_assignable_to_type_1_Did_you_mean_2, generalizedSourceType, targetType, typeToString(suggestedType));
                                return;
                            }
                        }
                        message = ts.Diagnostics.Type_0_is_not_assignable_to_type_1;
                    }
                }
                else if (message === ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1
                    && exactOptionalPropertyTypes
                    && getExactOptionalUnassignableProperties(source, target).length) {
                    message = ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties;
                }
                reportError(message, generalizedSourceType, targetType);
            }
            function tryElaborateErrorsForPrimitivesAndObjects(source, target) {
                var sourceType = symbolValueDeclarationIsContextSensitive(source.symbol) ? typeToString(source, source.symbol.valueDeclaration) : typeToString(source);
                var targetType = symbolValueDeclarationIsContextSensitive(target.symbol) ? typeToString(target, target.symbol.valueDeclaration) : typeToString(target);
                if ((globalStringType === source && stringType === target) ||
                    (globalNumberType === source && numberType === target) ||
                    (globalBooleanType === source && booleanType === target) ||
                    (getGlobalESSymbolType() === source && esSymbolType === target)) {
                    reportError(ts.Diagnostics._0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible, targetType, sourceType);
                }
            }
            /**
             * Try and elaborate array and tuple errors. Returns false
             * if we have found an elaboration, or we should ignore
             * any other elaborations when relating the `source` and
             * `target` types.
             */
            function tryElaborateArrayLikeErrors(source, target, reportErrors) {
                /**
                 * The spec for elaboration is:
                 * - If the source is a readonly tuple and the target is a mutable array or tuple, elaborate on mutability and skip property elaborations.
                 * - If the source is a tuple then skip property elaborations if the target is an array or tuple.
                 * - If the source is a readonly array and the target is a mutable array or tuple, elaborate on mutability and skip property elaborations.
                 * - If the source an array then skip property elaborations if the target is a tuple.
                 */
                if (isTupleType(source)) {
                    if (source.target.readonly && isMutableArrayOrTuple(target)) {
                        if (reportErrors) {
                            reportError(ts.Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target));
                        }
                        return false;
                    }
                    return isArrayOrTupleType(target);
                }
                if (isReadonlyArrayType(source) && isMutableArrayOrTuple(target)) {
                    if (reportErrors) {
                        reportError(ts.Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target));
                    }
                    return false;
                }
                if (isTupleType(target)) {
                    return isArrayType(source);
                }
                return true;
            }
            function isRelatedToWorker(source, target, reportErrors) {
                return isRelatedTo(source, target, 3 /* RecursionFlags.Both */, reportErrors);
            }
            /**
             * Compare two types and return
             * * Ternary.True if they are related with no assumptions,
             * * Ternary.Maybe if they are related with assumptions of other relationships, or
             * * Ternary.False if they are not related.
             */
            function isRelatedTo(originalSource, originalTarget, recursionFlags, reportErrors, headMessage, intersectionState) {
                if (recursionFlags === void 0) { recursionFlags = 3 /* RecursionFlags.Both */; }
                if (reportErrors === void 0) { reportErrors = false; }
                if (intersectionState === void 0) { intersectionState = 0 /* IntersectionState.None */; }
                // Before normalization: if `source` is type an object type, and `target` is primitive,
                // skip all the checks we don't need and just return `isSimpleTypeRelatedTo` result
                if (originalSource.flags & 524288 /* TypeFlags.Object */ && originalTarget.flags & 131068 /* TypeFlags.Primitive */) {
                    if (isSimpleTypeRelatedTo(originalSource, originalTarget, relation, reportErrors ? reportError : undefined)) {
                        return -1 /* Ternary.True */;
                    }
                    if (reportErrors) {
                        reportErrorResults(originalSource, originalTarget, originalSource, originalTarget, headMessage);
                    }
                    return 0 /* Ternary.False */;
                }
                // Normalize the source and target types: Turn fresh literal types into regular literal types,
                // turn deferred type references into regular type references, simplify indexed access and
                // conditional types, and resolve substitution types to either the substitution (on the source
                // side) or the type variable (on the target side).
                var source = getNormalizedType(originalSource, /*writing*/ false);
                var target = getNormalizedType(originalTarget, /*writing*/ true);
                if (source === target)
                    return -1 /* Ternary.True */;
                if (relation === identityRelation) {
                    if (source.flags !== target.flags)
                        return 0 /* Ternary.False */;
                    if (source.flags & 67358815 /* TypeFlags.Singleton */)
                        return -1 /* Ternary.True */;
                    traceUnionsOrIntersectionsTooLarge(source, target);
                    return recursiveTypeRelatedTo(source, target, /*reportErrors*/ false, 0 /* IntersectionState.None */, recursionFlags);
                }
                // We fastpath comparing a type parameter to exactly its constraint, as this is _super_ common,
                // and otherwise, for type parameters in large unions, causes us to need to compare the union to itself,
                // as we break down the _target_ union first, _then_ get the source constraint - so for every
                // member of the target, we attempt to find a match in the source. This avoids that in cases where
                // the target is exactly the constraint.
                if (source.flags & 262144 /* TypeFlags.TypeParameter */ && getConstraintOfType(source) === target) {
                    return -1 /* Ternary.True */;
                }
                // See if we're relating a definitely non-nullable type to a union that includes null and/or undefined
                // plus a single non-nullable type. If so, remove null and/or undefined from the target type.
                if (source.flags & 470302716 /* TypeFlags.DefinitelyNonNullable */ && target.flags & 1048576 /* TypeFlags.Union */) {
                    var types = target.types;
                    var candidate = types.length === 2 && types[0].flags & 98304 /* TypeFlags.Nullable */ ? types[1] :
                        types.length === 3 && types[0].flags & 98304 /* TypeFlags.Nullable */ && types[1].flags & 98304 /* TypeFlags.Nullable */ ? types[2] :
                            undefined;
                    if (candidate && !(candidate.flags & 98304 /* TypeFlags.Nullable */)) {
                        target = getNormalizedType(candidate, /*writing*/ true);
                        if (source === target)
                            return -1 /* Ternary.True */;
                    }
                }
                if (relation === comparableRelation && !(target.flags & 131072 /* TypeFlags.Never */) && isSimpleTypeRelatedTo(target, source, relation) ||
                    isSimpleTypeRelatedTo(source, target, relation, reportErrors ? reportError : undefined))
                    return -1 /* Ternary.True */;
                if (source.flags & 469499904 /* TypeFlags.StructuredOrInstantiable */ || target.flags & 469499904 /* TypeFlags.StructuredOrInstantiable */) {
                    var isPerformingExcessPropertyChecks = !(intersectionState & 2 /* IntersectionState.Target */) && (isObjectLiteralType(source) && ts.getObjectFlags(source) & 8192 /* ObjectFlags.FreshLiteral */);
                    if (isPerformingExcessPropertyChecks) {
                        if (hasExcessProperties(source, target, reportErrors)) {
                            if (reportErrors) {
                                reportRelationError(headMessage, source, originalTarget.aliasSymbol ? originalTarget : target);
                            }
                            return 0 /* Ternary.False */;
                        }
                    }
                    var isPerformingCommonPropertyChecks = (relation !== comparableRelation || isUnitType(source)) &&
                        !(intersectionState & 2 /* IntersectionState.Target */) &&
                        source.flags & (131068 /* TypeFlags.Primitive */ | 524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */) && source !== globalObjectType &&
                        target.flags & (524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */) && isWeakType(target) &&
                        (getPropertiesOfType(source).length > 0 || typeHasCallOrConstructSignatures(source));
                    var isComparingJsxAttributes = !!(ts.getObjectFlags(source) & 2048 /* ObjectFlags.JsxAttributes */);
                    if (isPerformingCommonPropertyChecks && !hasCommonProperties(source, target, isComparingJsxAttributes)) {
                        if (reportErrors) {
                            var sourceString = typeToString(originalSource.aliasSymbol ? originalSource : source);
                            var targetString = typeToString(originalTarget.aliasSymbol ? originalTarget : target);
                            var calls = getSignaturesOfType(source, 0 /* SignatureKind.Call */);
                            var constructs = getSignaturesOfType(source, 1 /* SignatureKind.Construct */);
                            if (calls.length > 0 && isRelatedTo(getReturnTypeOfSignature(calls[0]), target, 1 /* RecursionFlags.Source */, /*reportErrors*/ false) ||
                                constructs.length > 0 && isRelatedTo(getReturnTypeOfSignature(constructs[0]), target, 1 /* RecursionFlags.Source */, /*reportErrors*/ false)) {
                                reportError(ts.Diagnostics.Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it, sourceString, targetString);
                            }
                            else {
                                reportError(ts.Diagnostics.Type_0_has_no_properties_in_common_with_type_1, sourceString, targetString);
                            }
                        }
                        return 0 /* Ternary.False */;
                    }
                    traceUnionsOrIntersectionsTooLarge(source, target);
                    var skipCaching = source.flags & 1048576 /* TypeFlags.Union */ && source.types.length < 4 && !(target.flags & 1048576 /* TypeFlags.Union */) ||
                        target.flags & 1048576 /* TypeFlags.Union */ && target.types.length < 4 && !(source.flags & 469499904 /* TypeFlags.StructuredOrInstantiable */);
                    var result_7 = skipCaching ?
                        unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) :
                        recursiveTypeRelatedTo(source, target, reportErrors, intersectionState, recursionFlags);
                    if (result_7) {
                        return result_7;
                    }
                }
                if (reportErrors) {
                    reportErrorResults(originalSource, originalTarget, source, target, headMessage);
                }
                return 0 /* Ternary.False */;
            }
            function reportErrorResults(originalSource, originalTarget, source, target, headMessage) {
                var _a, _b;
                var sourceHasBase = !!getSingleBaseForNonAugmentingSubtype(originalSource);
                var targetHasBase = !!getSingleBaseForNonAugmentingSubtype(originalTarget);
                source = (originalSource.aliasSymbol || sourceHasBase) ? originalSource : source;
                target = (originalTarget.aliasSymbol || targetHasBase) ? originalTarget : target;
                var maybeSuppress = overrideNextErrorInfo > 0;
                if (maybeSuppress) {
                    overrideNextErrorInfo--;
                }
                if (source.flags & 524288 /* TypeFlags.Object */ && target.flags & 524288 /* TypeFlags.Object */) {
                    var currentError = errorInfo;
                    tryElaborateArrayLikeErrors(source, target, /*reportErrors*/ true);
                    if (errorInfo !== currentError) {
                        maybeSuppress = !!errorInfo;
                    }
                }
                if (source.flags & 524288 /* TypeFlags.Object */ && target.flags & 131068 /* TypeFlags.Primitive */) {
                    tryElaborateErrorsForPrimitivesAndObjects(source, target);
                }
                else if (source.symbol && source.flags & 524288 /* TypeFlags.Object */ && globalObjectType === source) {
                    reportError(ts.Diagnostics.The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead);
                }
                else if (ts.getObjectFlags(source) & 2048 /* ObjectFlags.JsxAttributes */ && target.flags & 2097152 /* TypeFlags.Intersection */) {
                    var targetTypes = target.types;
                    var intrinsicAttributes = getJsxType(JsxNames.IntrinsicAttributes, errorNode);
                    var intrinsicClassAttributes = getJsxType(JsxNames.IntrinsicClassAttributes, errorNode);
                    if (!isErrorType(intrinsicAttributes) && !isErrorType(intrinsicClassAttributes) &&
                        (ts.contains(targetTypes, intrinsicAttributes) || ts.contains(targetTypes, intrinsicClassAttributes))) {
                        // do not report top error
                        return;
                    }
                }
                else {
                    errorInfo = elaborateNeverIntersection(errorInfo, originalTarget);
                }
                if (!headMessage && maybeSuppress) {
                    lastSkippedInfo = [source, target];
                    // Used by, eg, missing property checking to replace the top-level message with a more informative one
                    return;
                }
                reportRelationError(headMessage, source, target);
                if (source.flags & 262144 /* TypeFlags.TypeParameter */ && ((_b = (_a = source.symbol) === null || _a === void 0 ? void 0 : _a.declarations) === null || _b === void 0 ? void 0 : _b[0]) && !getConstraintOfType(source)) {
                    var syntheticParam = cloneTypeParameter(source);
                    syntheticParam.constraint = instantiateType(target, makeUnaryTypeMapper(source, syntheticParam));
                    if (hasNonCircularBaseConstraint(syntheticParam)) {
                        var targetConstraintString = typeToString(target, source.symbol.declarations[0]);
                        associateRelatedInfo(ts.createDiagnosticForNode(source.symbol.declarations[0], ts.Diagnostics.This_type_parameter_might_need_an_extends_0_constraint, targetConstraintString));
                    }
                }
            }
            function traceUnionsOrIntersectionsTooLarge(source, target) {
                if (!ts.tracing) {
                    return;
                }
                if ((source.flags & 3145728 /* TypeFlags.UnionOrIntersection */) && (target.flags & 3145728 /* TypeFlags.UnionOrIntersection */)) {
                    var sourceUnionOrIntersection = source;
                    var targetUnionOrIntersection = target;
                    if (sourceUnionOrIntersection.objectFlags & targetUnionOrIntersection.objectFlags & 32768 /* ObjectFlags.PrimitiveUnion */) {
                        // There's a fast path for comparing primitive unions
                        return;
                    }
                    var sourceSize = sourceUnionOrIntersection.types.length;
                    var targetSize = targetUnionOrIntersection.types.length;
                    if (sourceSize * targetSize > 1E6) {
                        ts.tracing.instant("checkTypes" /* tracing.Phase.CheckTypes */, "traceUnionsOrIntersectionsTooLarge_DepthLimit", {
                            sourceId: source.id,
                            sourceSize: sourceSize,
                            targetId: target.id,
                            targetSize: targetSize,
                            pos: errorNode === null || errorNode === void 0 ? void 0 : errorNode.pos,
                            end: errorNode === null || errorNode === void 0 ? void 0 : errorNode.end
                        });
                    }
                }
            }
            function getTypeOfPropertyInTypes(types, name) {
                var appendPropType = function (propTypes, type) {
                    var _a;
                    type = getApparentType(type);
                    var prop = type.flags & 3145728 /* TypeFlags.UnionOrIntersection */ ? getPropertyOfUnionOrIntersectionType(type, name) : getPropertyOfObjectType(type, name);
                    var propType = prop && getTypeOfSymbol(prop) || ((_a = getApplicableIndexInfoForName(type, name)) === null || _a === void 0 ? void 0 : _a.type) || undefinedType;
                    return ts.append(propTypes, propType);
                };
                return getUnionType(ts.reduceLeft(types, appendPropType, /*initial*/ undefined) || ts.emptyArray);
            }
            function hasExcessProperties(source, target, reportErrors) {
                var _a;
                if (!isExcessPropertyCheckTarget(target) || !noImplicitAny && ts.getObjectFlags(target) & 4096 /* ObjectFlags.JSLiteral */) {
                    return false; // Disable excess property checks on JS literals to simulate having an implicit "index signature" - but only outside of noImplicitAny
                }
                var isComparingJsxAttributes = !!(ts.getObjectFlags(source) & 2048 /* ObjectFlags.JsxAttributes */);
                if ((relation === assignableRelation || relation === comparableRelation) &&
                    (isTypeSubsetOf(globalObjectType, target) || (!isComparingJsxAttributes && isEmptyObjectType(target)))) {
                    return false;
                }
                var reducedTarget = target;
                var checkTypes;
                if (target.flags & 1048576 /* TypeFlags.Union */) {
                    reducedTarget = findMatchingDiscriminantType(source, target, isRelatedTo) || filterPrimitivesIfContainsNonPrimitive(target);
                    checkTypes = reducedTarget.flags & 1048576 /* TypeFlags.Union */ ? reducedTarget.types : [reducedTarget];
                }
                var _loop_20 = function (prop) {
                    if (shouldCheckAsExcessProperty(prop, source.symbol) && !isIgnoredJsxProperty(source, prop)) {
                        if (!isKnownProperty(reducedTarget, prop.escapedName, isComparingJsxAttributes)) {
                            if (reportErrors) {
                                // Report error in terms of object types in the target as those are the only ones
                                // we check in isKnownProperty.
                                var errorTarget = filterType(reducedTarget, isExcessPropertyCheckTarget);
                                // We know *exactly* where things went wrong when comparing the types.
                                // Use this property as the error node as this will be more helpful in
                                // reasoning about what went wrong.
                                if (!errorNode)
                                    return { value: ts.Debug.fail() };
                                if (ts.isJsxAttributes(errorNode) || ts.isJsxOpeningLikeElement(errorNode) || ts.isJsxOpeningLikeElement(errorNode.parent)) {
                                    // JsxAttributes has an object-literal flag and undergo same type-assignablity check as normal object-literal.
                                    // However, using an object-literal error message will be very confusing to the users so we give different a message.
                                    if (prop.valueDeclaration && ts.isJsxAttribute(prop.valueDeclaration) && ts.getSourceFileOfNode(errorNode) === ts.getSourceFileOfNode(prop.valueDeclaration.name)) {
                                        // Note that extraneous children (as in `<NoChild>extra</NoChild>`) don't pass this check,
                                        // since `children` is a SyntaxKind.PropertySignature instead of a SyntaxKind.JsxAttribute.
                                        errorNode = prop.valueDeclaration.name;
                                    }
                                    var propName = symbolToString(prop);
                                    var suggestionSymbol = getSuggestedSymbolForNonexistentJSXAttribute(propName, errorTarget);
                                    var suggestion = suggestionSymbol ? symbolToString(suggestionSymbol) : undefined;
                                    if (suggestion) {
                                        reportError(ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName, typeToString(errorTarget), suggestion);
                                    }
                                    else {
                                        reportError(ts.Diagnostics.Property_0_does_not_exist_on_type_1, propName, typeToString(errorTarget));
                                    }
                                }
                                else {
                                    // use the property's value declaration if the property is assigned inside the literal itself
                                    var objectLiteralDeclaration_1 = ((_a = source.symbol) === null || _a === void 0 ? void 0 : _a.declarations) && ts.firstOrUndefined(source.symbol.declarations);
                                    var suggestion = void 0;
                                    if (prop.valueDeclaration && ts.findAncestor(prop.valueDeclaration, function (d) { return d === objectLiteralDeclaration_1; }) && ts.getSourceFileOfNode(objectLiteralDeclaration_1) === ts.getSourceFileOfNode(errorNode)) {
                                        var propDeclaration = prop.valueDeclaration;
                                        ts.Debug.assertNode(propDeclaration, ts.isObjectLiteralElementLike);
                                        errorNode = propDeclaration;
                                        var name = propDeclaration.name;
                                        if (ts.isIdentifier(name)) {
                                            suggestion = getSuggestionForNonexistentProperty(name, errorTarget);
                                        }
                                    }
                                    if (suggestion !== undefined) {
                                        reportError(ts.Diagnostics.Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2, symbolToString(prop), typeToString(errorTarget), suggestion);
                                    }
                                    else {
                                        reportError(ts.Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(prop), typeToString(errorTarget));
                                    }
                                }
                            }
                            return { value: true };
                        }
                        if (checkTypes && !isRelatedTo(getTypeOfSymbol(prop), getTypeOfPropertyInTypes(checkTypes, prop.escapedName), 3 /* RecursionFlags.Both */, reportErrors)) {
                            if (reportErrors) {
                                reportIncompatibleError(ts.Diagnostics.Types_of_property_0_are_incompatible, symbolToString(prop));
                            }
                            return { value: true };
                        }
                    }
                };
                for (var _i = 0, _b = getPropertiesOfType(source); _i < _b.length; _i++) {
                    var prop = _b[_i];
                    var state_6 = _loop_20(prop);
                    if (typeof state_6 === "object")
                        return state_6.value;
                }
                return false;
            }
            function shouldCheckAsExcessProperty(prop, container) {
                return prop.valueDeclaration && container.valueDeclaration && prop.valueDeclaration.parent === container.valueDeclaration;
            }
            function unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) {
                // Note that these checks are specifically ordered to produce correct results. In particular,
                // we need to deconstruct unions before intersections (because unions are always at the top),
                // and we need to handle "each" relations before "some" relations for the same kind of type.
                if (source.flags & 1048576 /* TypeFlags.Union */) {
                    return relation === comparableRelation ?
                        someTypeRelatedToType(source, target, reportErrors && !(source.flags & 131068 /* TypeFlags.Primitive */), intersectionState) :
                        eachTypeRelatedToType(source, target, reportErrors && !(source.flags & 131068 /* TypeFlags.Primitive */), intersectionState);
                }
                if (target.flags & 1048576 /* TypeFlags.Union */) {
                    return typeRelatedToSomeType(getRegularTypeOfObjectLiteral(source), target, reportErrors && !(source.flags & 131068 /* TypeFlags.Primitive */) && !(target.flags & 131068 /* TypeFlags.Primitive */));
                }
                if (target.flags & 2097152 /* TypeFlags.Intersection */) {
                    return typeRelatedToEachType(source, target, reportErrors, 2 /* IntersectionState.Target */);
                }
                // Source is an intersection. For the comparable relation, if the target is a primitive type we hoist the
                // constraints of all non-primitive types in the source into a new intersection. We do this because the
                // intersection may further constrain the constraints of the non-primitive types. For example, given a type
                // parameter 'T extends 1 | 2', the intersection 'T & 1' should be reduced to '1' such that it doesn't
                // appear to be comparable to '2'.
                if (relation === comparableRelation && target.flags & 131068 /* TypeFlags.Primitive */) {
                    var constraints = ts.sameMap(source.types, function (t) { return t.flags & 465829888 /* TypeFlags.Instantiable */ ? getBaseConstraintOfType(t) || unknownType : t; });
                    if (constraints !== source.types) {
                        source = getIntersectionType(constraints);
                        if (source.flags & 131072 /* TypeFlags.Never */) {
                            return 0 /* Ternary.False */;
                        }
                        if (!(source.flags & 2097152 /* TypeFlags.Intersection */)) {
                            return isRelatedTo(source, target, 1 /* RecursionFlags.Source */, /*reportErrors*/ false) ||
                                isRelatedTo(target, source, 1 /* RecursionFlags.Source */, /*reportErrors*/ false);
                        }
                    }
                }
                // Check to see if any constituents of the intersection are immediately related to the target.
                // Don't report errors though. Elaborating on whether a source constituent is related to the target is
                // not actually useful and leads to some confusing error messages. Instead, we rely on the caller
                // checking whether the full intersection viewed as an object is related to the target.
                return someTypeRelatedToType(source, target, /*reportErrors*/ false, 1 /* IntersectionState.Source */);
            }
            function eachTypeRelatedToSomeType(source, target) {
                var result = -1 /* Ternary.True */;
                var sourceTypes = source.types;
                for (var _i = 0, sourceTypes_1 = sourceTypes; _i < sourceTypes_1.length; _i++) {
                    var sourceType = sourceTypes_1[_i];
                    var related = typeRelatedToSomeType(sourceType, target, /*reportErrors*/ false);
                    if (!related) {
                        return 0 /* Ternary.False */;
                    }
                    result &= related;
                }
                return result;
            }
            function typeRelatedToSomeType(source, target, reportErrors) {
                var targetTypes = target.types;
                if (target.flags & 1048576 /* TypeFlags.Union */) {
                    if (containsType(targetTypes, source)) {
                        return -1 /* Ternary.True */;
                    }
                    var match = getMatchingUnionConstituentForType(target, source);
                    if (match) {
                        var related = isRelatedTo(source, match, 2 /* RecursionFlags.Target */, /*reportErrors*/ false);
                        if (related) {
                            return related;
                        }
                    }
                }
                for (var _i = 0, targetTypes_1 = targetTypes; _i < targetTypes_1.length; _i++) {
                    var type = targetTypes_1[_i];
                    var related = isRelatedTo(source, type, 2 /* RecursionFlags.Target */, /*reportErrors*/ false);
                    if (related) {
                        return related;
                    }
                }
                if (reportErrors) {
                    // Elaborate only if we can find a best matching type in the target union
                    var bestMatchingType = getBestMatchingType(source, target, isRelatedTo);
                    if (bestMatchingType) {
                        isRelatedTo(source, bestMatchingType, 2 /* RecursionFlags.Target */, /*reportErrors*/ true);
                    }
                }
                return 0 /* Ternary.False */;
            }
            function typeRelatedToEachType(source, target, reportErrors, intersectionState) {
                var result = -1 /* Ternary.True */;
                var targetTypes = target.types;
                for (var _i = 0, targetTypes_2 = targetTypes; _i < targetTypes_2.length; _i++) {
                    var targetType = targetTypes_2[_i];
                    var related = isRelatedTo(source, targetType, 2 /* RecursionFlags.Target */, reportErrors, /*headMessage*/ undefined, intersectionState);
                    if (!related) {
                        return 0 /* Ternary.False */;
                    }
                    result &= related;
                }
                return result;
            }
            function someTypeRelatedToType(source, target, reportErrors, intersectionState) {
                var sourceTypes = source.types;
                if (source.flags & 1048576 /* TypeFlags.Union */ && containsType(sourceTypes, target)) {
                    return -1 /* Ternary.True */;
                }
                var len = sourceTypes.length;
                for (var i = 0; i < len; i++) {
                    var related = isRelatedTo(sourceTypes[i], target, 1 /* RecursionFlags.Source */, reportErrors && i === len - 1, /*headMessage*/ undefined, intersectionState);
                    if (related) {
                        return related;
                    }
                }
                return 0 /* Ternary.False */;
            }
            function getUndefinedStrippedTargetIfNeeded(source, target) {
                // As a builtin type, `undefined` is a very low type ID - making it almsot always first, making this a very fast check to see
                // if we need to strip `undefined` from the target
                if (source.flags & 1048576 /* TypeFlags.Union */ && target.flags & 1048576 /* TypeFlags.Union */ &&
                    !(source.types[0].flags & 32768 /* TypeFlags.Undefined */) && target.types[0].flags & 32768 /* TypeFlags.Undefined */) {
                    return extractTypesOfKind(target, ~32768 /* TypeFlags.Undefined */);
                }
                return target;
            }
            function eachTypeRelatedToType(source, target, reportErrors, intersectionState) {
                var result = -1 /* Ternary.True */;
                var sourceTypes = source.types;
                // We strip `undefined` from the target if the `source` trivially doesn't contain it for our correspondence-checking fastpath
                // since `undefined` is frequently added by optionality and would otherwise spoil a potentially useful correspondence
                var undefinedStrippedTarget = getUndefinedStrippedTargetIfNeeded(source, target);
                for (var i = 0; i < sourceTypes.length; i++) {
                    var sourceType = sourceTypes[i];
                    if (undefinedStrippedTarget.flags & 1048576 /* TypeFlags.Union */ && sourceTypes.length >= undefinedStrippedTarget.types.length && sourceTypes.length % undefinedStrippedTarget.types.length === 0) {
                        // many unions are mappings of one another; in such cases, simply comparing members at the same index can shortcut the comparison
                        // such unions will have identical lengths, and their corresponding elements will match up. Another common scenario is where a large
                        // union has a union of objects intersected with it. In such cases, if the input was, eg `("a" | "b" | "c") & (string | boolean | {} | {whatever})`,
                        // the result will have the structure `"a" | "b" | "c" | "a" & {} | "b" & {} | "c" & {} | "a" & {whatever} | "b" & {whatever} | "c" & {whatever}`
                        // - the resulting union has a length which is a multiple of the original union, and the elements correspond modulo the length of the original union
                        var related_1 = isRelatedTo(sourceType, undefinedStrippedTarget.types[i % undefinedStrippedTarget.types.length], 3 /* RecursionFlags.Both */, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState);
                        if (related_1) {
                            result &= related_1;
                            continue;
                        }
                    }
                    var related = isRelatedTo(sourceType, target, 1 /* RecursionFlags.Source */, reportErrors, /*headMessage*/ undefined, intersectionState);
                    if (!related) {
                        return 0 /* Ternary.False */;
                    }
                    result &= related;
                }
                return result;
            }
            function typeArgumentsRelatedTo(sources, targets, variances, reportErrors, intersectionState) {
                if (sources === void 0) { sources = ts.emptyArray; }
                if (targets === void 0) { targets = ts.emptyArray; }
                if (variances === void 0) { variances = ts.emptyArray; }
                if (sources.length !== targets.length && relation === identityRelation) {
                    return 0 /* Ternary.False */;
                }
                var length = sources.length <= targets.length ? sources.length : targets.length;
                var result = -1 /* Ternary.True */;
                for (var i = 0; i < length; i++) {
                    // When variance information isn't available we default to covariance. This happens
                    // in the process of computing variance information for recursive types and when
                    // comparing 'this' type arguments.
                    var varianceFlags = i < variances.length ? variances[i] : 1 /* VarianceFlags.Covariant */;
                    var variance = varianceFlags & 7 /* VarianceFlags.VarianceMask */;
                    // We ignore arguments for independent type parameters (because they're never witnessed).
                    if (variance !== 4 /* VarianceFlags.Independent */) {
                        var s = sources[i];
                        var t = targets[i];
                        var related = -1 /* Ternary.True */;
                        if (varianceFlags & 8 /* VarianceFlags.Unmeasurable */) {
                            // Even an `Unmeasurable` variance works out without a structural check if the source and target are _identical_.
                            // We can't simply assume invariance, because `Unmeasurable` marks nonlinear relations, for example, a relation tained by
                            // the `-?` modifier in a mapped type (where, no matter how the inputs are related, the outputs still might not be)
                            related = relation === identityRelation ? isRelatedTo(s, t, 3 /* RecursionFlags.Both */, /*reportErrors*/ false) : compareTypesIdentical(s, t);
                        }
                        else if (variance === 1 /* VarianceFlags.Covariant */) {
                            related = isRelatedTo(s, t, 3 /* RecursionFlags.Both */, reportErrors, /*headMessage*/ undefined, intersectionState);
                        }
                        else if (variance === 2 /* VarianceFlags.Contravariant */) {
                            related = isRelatedTo(t, s, 3 /* RecursionFlags.Both */, reportErrors, /*headMessage*/ undefined, intersectionState);
                        }
                        else if (variance === 3 /* VarianceFlags.Bivariant */) {
                            // In the bivariant case we first compare contravariantly without reporting
                            // errors. Then, if that doesn't succeed, we compare covariantly with error
                            // reporting. Thus, error elaboration will be based on the the covariant check,
                            // which is generally easier to reason about.
                            related = isRelatedTo(t, s, 3 /* RecursionFlags.Both */, /*reportErrors*/ false);
                            if (!related) {
                                related = isRelatedTo(s, t, 3 /* RecursionFlags.Both */, reportErrors, /*headMessage*/ undefined, intersectionState);
                            }
                        }
                        else {
                            // In the invariant case we first compare covariantly, and only when that
                            // succeeds do we proceed to compare contravariantly. Thus, error elaboration
                            // will typically be based on the covariant check.
                            related = isRelatedTo(s, t, 3 /* RecursionFlags.Both */, reportErrors, /*headMessage*/ undefined, intersectionState);
                            if (related) {
                                related &= isRelatedTo(t, s, 3 /* RecursionFlags.Both */, reportErrors, /*headMessage*/ undefined, intersectionState);
                            }
                        }
                        if (!related) {
                            return 0 /* Ternary.False */;
                        }
                        result &= related;
                    }
                }
                return result;
            }
            // Determine if possibly recursive types are related. First, check if the result is already available in the global cache.
            // Second, check if we have already started a comparison of the given two types in which case we assume the result to be true.
            // Third, check if both types are part of deeply nested chains of generic type instantiations and if so assume the types are
            // equal and infinitely expanding. Fourth, if we have reached a depth of 100 nested comparisons, assume we have runaway recursion
            // and issue an error. Otherwise, actually compare the structure of the two types.
            function recursiveTypeRelatedTo(source, target, reportErrors, intersectionState, recursionFlags) {
                if (overflow) {
                    return 0 /* Ternary.False */;
                }
                var id = getRelationKey(source, target, intersectionState, relation, /*ingnoreConstraints*/ false);
                var entry = relation.get(id);
                if (entry !== undefined) {
                    if (reportErrors && entry & 2 /* RelationComparisonResult.Failed */ && !(entry & 4 /* RelationComparisonResult.Reported */)) {
                        // We are elaborating errors and the cached result is an unreported failure. The result will be reported
                        // as a failure, and should be updated as a reported failure by the bottom of this function.
                    }
                    else {
                        if (outofbandVarianceMarkerHandler) {
                            // We're in the middle of variance checking - integrate any unmeasurable/unreliable flags from this cached component
                            var saved = entry & 24 /* RelationComparisonResult.ReportsMask */;
                            if (saved & 8 /* RelationComparisonResult.ReportsUnmeasurable */) {
                                instantiateType(source, reportUnmeasurableMapper);
                            }
                            if (saved & 16 /* RelationComparisonResult.ReportsUnreliable */) {
                                instantiateType(source, reportUnreliableMapper);
                            }
                        }
                        return entry & 1 /* RelationComparisonResult.Succeeded */ ? -1 /* Ternary.True */ : 0 /* Ternary.False */;
                    }
                }
                if (!maybeKeys) {
                    maybeKeys = [];
                    sourceStack = [];
                    targetStack = [];
                }
                else {
                    // A key that starts with "*" is an indication that we have type references that reference constrained
                    // type parameters. For such keys we also check against the key we would have gotten if all type parameters
                    // were unconstrained.
                    var broadestEquivalentId = id.startsWith("*") ? getRelationKey(source, target, intersectionState, relation, /*ignoreConstraints*/ true) : undefined;
                    for (var i = 0; i < maybeCount; i++) {
                        // If source and target are already being compared, consider them related with assumptions
                        if (id === maybeKeys[i] || broadestEquivalentId && broadestEquivalentId === maybeKeys[i]) {
                            return 3 /* Ternary.Maybe */;
                        }
                    }
                    if (sourceDepth === 100 || targetDepth === 100) {
                        overflow = true;
                        return 0 /* Ternary.False */;
                    }
                }
                var maybeStart = maybeCount;
                maybeKeys[maybeCount] = id;
                maybeCount++;
                var saveExpandingFlags = expandingFlags;
                if (recursionFlags & 1 /* RecursionFlags.Source */) {
                    sourceStack[sourceDepth] = source;
                    sourceDepth++;
                    if (!(expandingFlags & 1 /* ExpandingFlags.Source */) && isDeeplyNestedType(source, sourceStack, sourceDepth))
                        expandingFlags |= 1 /* ExpandingFlags.Source */;
                }
                if (recursionFlags & 2 /* RecursionFlags.Target */) {
                    targetStack[targetDepth] = target;
                    targetDepth++;
                    if (!(expandingFlags & 2 /* ExpandingFlags.Target */) && isDeeplyNestedType(target, targetStack, targetDepth))
                        expandingFlags |= 2 /* ExpandingFlags.Target */;
                }
                var originalHandler;
                var propagatingVarianceFlags = 0;
                if (outofbandVarianceMarkerHandler) {
                    originalHandler = outofbandVarianceMarkerHandler;
                    outofbandVarianceMarkerHandler = function (onlyUnreliable) {
                        propagatingVarianceFlags |= onlyUnreliable ? 16 /* RelationComparisonResult.ReportsUnreliable */ : 8 /* RelationComparisonResult.ReportsUnmeasurable */;
                        return originalHandler(onlyUnreliable);
                    };
                }
                var result;
                if (expandingFlags === 3 /* ExpandingFlags.Both */) {
                    ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.instant("checkTypes" /* tracing.Phase.CheckTypes */, "recursiveTypeRelatedTo_DepthLimit", {
                        sourceId: source.id,
                        sourceIdStack: sourceStack.map(function (t) { return t.id; }),
                        targetId: target.id,
                        targetIdStack: targetStack.map(function (t) { return t.id; }),
                        depth: sourceDepth,
                        targetDepth: targetDepth
                    });
                    result = 3 /* Ternary.Maybe */;
                }
                else {
                    ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("checkTypes" /* tracing.Phase.CheckTypes */, "structuredTypeRelatedTo", { sourceId: source.id, targetId: target.id });
                    result = structuredTypeRelatedTo(source, target, reportErrors, intersectionState);
                    ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
                }
                if (outofbandVarianceMarkerHandler) {
                    outofbandVarianceMarkerHandler = originalHandler;
                }
                if (recursionFlags & 1 /* RecursionFlags.Source */) {
                    sourceDepth--;
                }
                if (recursionFlags & 2 /* RecursionFlags.Target */) {
                    targetDepth--;
                }
                expandingFlags = saveExpandingFlags;
                if (result) {
                    if (result === -1 /* Ternary.True */ || (sourceDepth === 0 && targetDepth === 0)) {
                        if (result === -1 /* Ternary.True */ || result === 3 /* Ternary.Maybe */) {
                            // If result is definitely true, record all maybe keys as having succeeded. Also, record Ternary.Maybe
                            // results as having succeeded once we reach depth 0, but never record Ternary.Unknown results.
                            for (var i = maybeStart; i < maybeCount; i++) {
                                relation.set(maybeKeys[i], 1 /* RelationComparisonResult.Succeeded */ | propagatingVarianceFlags);
                            }
                        }
                        maybeCount = maybeStart;
                    }
                }
                else {
                    // A false result goes straight into global cache (when something is false under
                    // assumptions it will also be false without assumptions)
                    relation.set(id, (reportErrors ? 4 /* RelationComparisonResult.Reported */ : 0) | 2 /* RelationComparisonResult.Failed */ | propagatingVarianceFlags);
                    maybeCount = maybeStart;
                }
                return result;
            }
            function structuredTypeRelatedTo(source, target, reportErrors, intersectionState) {
                var saveErrorInfo = captureErrorCalculationState();
                var result = structuredTypeRelatedToWorker(source, target, reportErrors, intersectionState, saveErrorInfo);
                if (relation !== identityRelation) {
                    // The combined constraint of an intersection type is the intersection of the constraints of
                    // the constituents. When an intersection type contains instantiable types with union type
                    // constraints, there are situations where we need to examine the combined constraint. One is
                    // when the target is a union type. Another is when the intersection contains types belonging
                    // to one of the disjoint domains. For example, given type variables T and U, each with the
                    // constraint 'string | number', the combined constraint of 'T & U' is 'string | number' and
                    // we need to check this constraint against a union on the target side. Also, given a type
                    // variable V constrained to 'string | number', 'V & number' has a combined constraint of
                    // 'string & number | number & number' which reduces to just 'number'.
                    // This also handles type parameters, as a type parameter with a union constraint compared against a union
                    // needs to have its constraint hoisted into an intersection with said type parameter, this way
                    // the type param can be compared with itself in the target (with the influence of its constraint to match other parts)
                    // For example, if `T extends 1 | 2` and `U extends 2 | 3` and we compare `T & U` to `T & U & (1 | 2 | 3)`
                    if (!result && (source.flags & 2097152 /* TypeFlags.Intersection */ || source.flags & 262144 /* TypeFlags.TypeParameter */ && target.flags & 1048576 /* TypeFlags.Union */)) {
                        var constraint = getEffectiveConstraintOfIntersection(source.flags & 2097152 /* TypeFlags.Intersection */ ? source.types : [source], !!(target.flags & 1048576 /* TypeFlags.Union */));
                        if (constraint && everyType(constraint, function (c) { return c !== source; })) { // Skip comparison if expansion contains the source itself
                            // TODO: Stack errors so we get a pyramid for the "normal" comparison above, _and_ a second for this
                            result = isRelatedTo(constraint, target, 1 /* RecursionFlags.Source */, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState);
                        }
                    }
                    // For certain combinations involving intersections and optional, excess, or mismatched properties we need
                    // an extra property check where the intersection is viewed as a single object. The following are motivating
                    // examples that all should be errors, but aren't without this extra property check:
                    //
                    //   let obj: { a: { x: string } } & { c: number } = { a: { x: 'hello', y: 2 }, c: 5 };  // Nested excess property
                    //
                    //   declare let wrong: { a: { y: string } };
                    //   let weak: { a?: { x?: number } } & { c?: string } = wrong;  // Nested weak object type
                    //
                    //   function foo<T extends object>(x: { a?: string }, y: T & { a: boolean }) {
                    //     x = y;  // Mismatched property in source intersection
                    //   }
                    //
                    // We suppress recursive intersection property checks because they can generate lots of work when relating
                    // recursive intersections that are structurally similar but not exactly identical. See #37854.
                    if (result && !inPropertyCheck && (target.flags & 2097152 /* TypeFlags.Intersection */ && !isGenericObjectType(target) && source.flags & (524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */) ||
                        isNonGenericObjectType(target) && !isArrayOrTupleType(target) && source.flags & 2097152 /* TypeFlags.Intersection */ && getApparentType(source).flags & 3670016 /* TypeFlags.StructuredType */ && !ts.some(source.types, function (t) { return !!(ts.getObjectFlags(t) & 262144 /* ObjectFlags.NonInferrableType */); }))) {
                        inPropertyCheck = true;
                        result &= propertiesRelatedTo(source, target, reportErrors, /*excludedProperties*/ undefined, 0 /* IntersectionState.None */);
                        inPropertyCheck = false;
                    }
                }
                if (result) {
                    resetErrorInfo(saveErrorInfo);
                }
                return result;
            }
            function structuredTypeRelatedToWorker(source, target, reportErrors, intersectionState, saveErrorInfo) {
                var result;
                var originalErrorInfo;
                var varianceCheckFailed = false;
                var sourceFlags = source.flags;
                var targetFlags = target.flags;
                if (relation === identityRelation) {
                    // We've already checked that source.flags and target.flags are identical
                    if (sourceFlags & 3145728 /* TypeFlags.UnionOrIntersection */) {
                        var result_8 = eachTypeRelatedToSomeType(source, target);
                        if (result_8) {
                            result_8 &= eachTypeRelatedToSomeType(target, source);
                        }
                        return result_8;
                    }
                    if (sourceFlags & 4194304 /* TypeFlags.Index */) {
                        return isRelatedTo(source.type, target.type, 3 /* RecursionFlags.Both */, /*reportErrors*/ false);
                    }
                    if (sourceFlags & 8388608 /* TypeFlags.IndexedAccess */) {
                        if (result = isRelatedTo(source.objectType, target.objectType, 3 /* RecursionFlags.Both */, /*reportErrors*/ false)) {
                            if (result &= isRelatedTo(source.indexType, target.indexType, 3 /* RecursionFlags.Both */, /*reportErrors*/ false)) {
                                return result;
                            }
                        }
                    }
                    if (sourceFlags & 16777216 /* TypeFlags.Conditional */) {
                        if (source.root.isDistributive === target.root.isDistributive) {
                            if (result = isRelatedTo(source.checkType, target.checkType, 3 /* RecursionFlags.Both */, /*reportErrors*/ false)) {
                                if (result &= isRelatedTo(source.extendsType, target.extendsType, 3 /* RecursionFlags.Both */, /*reportErrors*/ false)) {
                                    if (result &= isRelatedTo(getTrueTypeFromConditionalType(source), getTrueTypeFromConditionalType(target), 3 /* RecursionFlags.Both */, /*reportErrors*/ false)) {
                                        if (result &= isRelatedTo(getFalseTypeFromConditionalType(source), getFalseTypeFromConditionalType(target), 3 /* RecursionFlags.Both */, /*reportErrors*/ false)) {
                                            return result;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (sourceFlags & 33554432 /* TypeFlags.Substitution */) {
                        if (result = isRelatedTo(source.baseType, target.baseType, 3 /* RecursionFlags.Both */, /*reportErrors*/ false)) {
                            if (result &= isRelatedTo(source.constraint, target.constraint, 3 /* RecursionFlags.Both */, /*reportErrors*/ false)) {
                                return result;
                            }
                        }
                    }
                    if (!(sourceFlags & 524288 /* TypeFlags.Object */)) {
                        return 0 /* Ternary.False */;
                    }
                }
                else if (sourceFlags & 3145728 /* TypeFlags.UnionOrIntersection */ || targetFlags & 3145728 /* TypeFlags.UnionOrIntersection */) {
                    if (result = unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState)) {
                        return result;
                    }
                    // The ordered decomposition above doesn't handle all cases. Specifically, we also need to handle:
                    // Source is instantiable (e.g. source has union or intersection constraint).
                    // Source is an object, target is a union (e.g. { a, b: boolean } <=> { a, b: true } | { a, b: false }).
                    // Source is an intersection, target is an object (e.g. { a } & { b } <=> { a, b }).
                    // Source is an intersection, target is a union (e.g. { a } & { b: boolean } <=> { a, b: true } | { a, b: false }).
                    // Source is an intersection, target instantiable (e.g. string & { tag } <=> T["a"] constrained to string & { tag }).
                    if (!(sourceFlags & 465829888 /* TypeFlags.Instantiable */ ||
                        sourceFlags & 524288 /* TypeFlags.Object */ && targetFlags & 1048576 /* TypeFlags.Union */ ||
                        sourceFlags & 2097152 /* TypeFlags.Intersection */ && targetFlags & (524288 /* TypeFlags.Object */ | 1048576 /* TypeFlags.Union */ | 465829888 /* TypeFlags.Instantiable */))) {
                        return 0 /* Ternary.False */;
                    }
                }
                // We limit alias variance probing to only object and conditional types since their alias behavior
                // is more predictable than other, interned types, which may or may not have an alias depending on
                // the order in which things were checked.
                if (sourceFlags & (524288 /* TypeFlags.Object */ | 16777216 /* TypeFlags.Conditional */) && source.aliasSymbol && source.aliasTypeArguments &&
                    source.aliasSymbol === target.aliasSymbol && !(isMarkerType(source) || isMarkerType(target))) {
                    var variances = getAliasVariances(source.aliasSymbol);
                    if (variances === ts.emptyArray) {
                        return 1 /* Ternary.Unknown */;
                    }
                    var varianceResult = relateVariances(source.aliasTypeArguments, target.aliasTypeArguments, variances, intersectionState);
                    if (varianceResult !== undefined) {
                        return varianceResult;
                    }
                }
                // For a generic type T and a type U that is assignable to T, [...U] is assignable to T, U is assignable to readonly [...T],
                // and U is assignable to [...T] when U is constrained to a mutable array or tuple type.
                if (isSingleElementGenericTupleType(source) && !source.target.readonly && (result = isRelatedTo(getTypeArguments(source)[0], target, 1 /* RecursionFlags.Source */)) ||
                    isSingleElementGenericTupleType(target) && (target.target.readonly || isMutableArrayOrTuple(getBaseConstraintOfType(source) || source)) && (result = isRelatedTo(source, getTypeArguments(target)[0], 2 /* RecursionFlags.Target */))) {
                    return result;
                }
                if (targetFlags & 262144 /* TypeFlags.TypeParameter */) {
                    // A source type { [P in Q]: X } is related to a target type T if keyof T is related to Q and X is related to T[Q].
                    if (ts.getObjectFlags(source) & 32 /* ObjectFlags.Mapped */ && !source.declaration.nameType && isRelatedTo(getIndexType(target), getConstraintTypeFromMappedType(source), 3 /* RecursionFlags.Both */)) {
                        if (!(getMappedTypeModifiers(source) & 4 /* MappedTypeModifiers.IncludeOptional */)) {
                            var templateType = getTemplateTypeFromMappedType(source);
                            var indexedAccessType = getIndexedAccessType(target, getTypeParameterFromMappedType(source));
                            if (result = isRelatedTo(templateType, indexedAccessType, 3 /* RecursionFlags.Both */, reportErrors)) {
                                return result;
                            }
                        }
                    }
                    if (relation === comparableRelation && sourceFlags & 262144 /* TypeFlags.TypeParameter */) {
                        // This is a carve-out in comparability to essentially forbid comparing a type parameter
                        // with another type parameter unless one extends the other. (Remember: comparability is mostly bidirectional!)
                        var constraint = getConstraintOfTypeParameter(source);
                        if (constraint && hasNonCircularBaseConstraint(source)) {
                            while (constraint && someType(constraint, function (c) { return !!(c.flags & 262144 /* TypeFlags.TypeParameter */); })) {
                                if (result = isRelatedTo(constraint, target, 1 /* RecursionFlags.Source */, /*reportErrors*/ false)) {
                                    return result;
                                }
                                constraint = getConstraintOfTypeParameter(constraint);
                            }
                        }
                        return 0 /* Ternary.False */;
                    }
                }
                else if (targetFlags & 4194304 /* TypeFlags.Index */) {
                    var targetType_1 = target.type;
                    // A keyof S is related to a keyof T if T is related to S.
                    if (sourceFlags & 4194304 /* TypeFlags.Index */) {
                        if (result = isRelatedTo(targetType_1, source.type, 3 /* RecursionFlags.Both */, /*reportErrors*/ false)) {
                            return result;
                        }
                    }
                    if (isTupleType(targetType_1)) {
                        // An index type can have a tuple type target when the tuple type contains variadic elements.
                        // Check if the source is related to the known keys of the tuple type.
                        if (result = isRelatedTo(source, getKnownKeysOfTupleType(targetType_1), 2 /* RecursionFlags.Target */, reportErrors)) {
                            return result;
                        }
                    }
                    else {
                        // A type S is assignable to keyof T if S is assignable to keyof C, where C is the
                        // simplified form of T or, if T doesn't simplify, the constraint of T.
                        var constraint = getSimplifiedTypeOrConstraint(targetType_1);
                        if (constraint) {
                            // We require Ternary.True here such that circular constraints don't cause
                            // false positives. For example, given 'T extends { [K in keyof T]: string }',
                            // 'keyof T' has itself as its constraint and produces a Ternary.Maybe when
                            // related to other types.
                            if (isRelatedTo(source, getIndexType(constraint, target.stringsOnly), 2 /* RecursionFlags.Target */, reportErrors) === -1 /* Ternary.True */) {
                                return -1 /* Ternary.True */;
                            }
                        }
                        else if (isGenericMappedType(targetType_1)) {
                            // generic mapped types that don't simplify or have a constraint still have a very simple set of keys we can compare against
                            // - their nameType or constraintType.
                            // In many ways, this comparison is a deferred version of what `getIndexTypeForMappedType` does to actually resolve the keys for _non_-generic types
                            var nameType_1 = getNameTypeFromMappedType(targetType_1);
                            var constraintType = getConstraintTypeFromMappedType(targetType_1);
                            var targetKeys = void 0;
                            if (nameType_1 && isMappedTypeWithKeyofConstraintDeclaration(targetType_1)) {
                                // we need to get the apparent mappings and union them with the generic mappings, since some properties may be
                                // missing from the `constraintType` which will otherwise be mapped in the object
                                var modifiersType = getApparentType(getModifiersTypeFromMappedType(targetType_1));
                                var mappedKeys_1 = [];
                                forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, 8576 /* TypeFlags.StringOrNumberLiteralOrUnique */, 
                                /*stringsOnly*/ false, function (t) { return void mappedKeys_1.push(instantiateType(nameType_1, appendTypeMapping(targetType_1.mapper, getTypeParameterFromMappedType(targetType_1), t))); });
                                // We still need to include the non-apparent (and thus still generic) keys in the target side of the comparison (in case they're in the source side)
                                targetKeys = getUnionType(__spreadArray(__spreadArray([], mappedKeys_1, true), [nameType_1], false));
                            }
                            else {
                                targetKeys = nameType_1 || constraintType;
                            }
                            if (isRelatedTo(source, targetKeys, 2 /* RecursionFlags.Target */, reportErrors) === -1 /* Ternary.True */) {
                                return -1 /* Ternary.True */;
                            }
                        }
                    }
                }
                else if (targetFlags & 8388608 /* TypeFlags.IndexedAccess */) {
                    if (sourceFlags & 8388608 /* TypeFlags.IndexedAccess */) {
                        // Relate components directly before falling back to constraint relationships
                        // A type S[K] is related to a type T[J] if S is related to T and K is related to J.
                        if (result = isRelatedTo(source.objectType, target.objectType, 3 /* RecursionFlags.Both */, reportErrors)) {
                            result &= isRelatedTo(source.indexType, target.indexType, 3 /* RecursionFlags.Both */, reportErrors);
                        }
                        if (result) {
                            return result;
                        }
                        if (reportErrors) {
                            originalErrorInfo = errorInfo;
                        }
                    }
                    // A type S is related to a type T[K] if S is related to C, where C is the base
                    // constraint of T[K] for writing.
                    if (relation === assignableRelation || relation === comparableRelation) {
                        var objectType = target.objectType;
                        var indexType = target.indexType;
                        var baseObjectType = getBaseConstraintOfType(objectType) || objectType;
                        var baseIndexType = getBaseConstraintOfType(indexType) || indexType;
                        if (!isGenericObjectType(baseObjectType) && !isGenericIndexType(baseIndexType)) {
                            var accessFlags = 4 /* AccessFlags.Writing */ | (baseObjectType !== objectType ? 2 /* AccessFlags.NoIndexSignatures */ : 0);
                            var constraint = getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, accessFlags);
                            if (constraint) {
                                if (reportErrors && originalErrorInfo) {
                                    // create a new chain for the constraint error
                                    resetErrorInfo(saveErrorInfo);
                                }
                                if (result = isRelatedTo(source, constraint, 2 /* RecursionFlags.Target */, reportErrors, /* headMessage */ undefined, intersectionState)) {
                                    return result;
                                }
                                // prefer the shorter chain of the constraint comparison chain, and the direct comparison chain
                                if (reportErrors && originalErrorInfo && errorInfo) {
                                    errorInfo = countMessageChainBreadth([originalErrorInfo]) <= countMessageChainBreadth([errorInfo]) ? originalErrorInfo : errorInfo;
                                }
                            }
                        }
                    }
                    if (reportErrors) {
                        originalErrorInfo = undefined;
                    }
                }
                else if (isGenericMappedType(target) && relation !== identityRelation) {
                    // Check if source type `S` is related to target type `{ [P in Q]: T }` or `{ [P in Q as R]: T}`.
                    var keysRemapped = !!target.declaration.nameType;
                    var templateType = getTemplateTypeFromMappedType(target);
                    var modifiers = getMappedTypeModifiers(target);
                    if (!(modifiers & 8 /* MappedTypeModifiers.ExcludeOptional */)) {
                        // If the mapped type has shape `{ [P in Q]: T[P] }`,
                        // source `S` is related to target if `T` = `S`, i.e. `S` is related to `{ [P in Q]: S[P] }`.
                        if (!keysRemapped && templateType.flags & 8388608 /* TypeFlags.IndexedAccess */ && templateType.objectType === source &&
                            templateType.indexType === getTypeParameterFromMappedType(target)) {
                            return -1 /* Ternary.True */;
                        }
                        if (!isGenericMappedType(source)) {
                            // If target has shape `{ [P in Q as R]: T}`, then its keys have type `R`.
                            // If target has shape `{ [P in Q]: T }`, then its keys have type `Q`.
                            var targetKeys = keysRemapped ? getNameTypeFromMappedType(target) : getConstraintTypeFromMappedType(target);
                            // Type of the keys of source type `S`, i.e. `keyof S`.
                            var sourceKeys = getIndexType(source, /*stringsOnly*/ undefined, /*noIndexSignatures*/ true);
                            var includeOptional = modifiers & 4 /* MappedTypeModifiers.IncludeOptional */;
                            var filteredByApplicability = includeOptional ? intersectTypes(targetKeys, sourceKeys) : undefined;
                            // A source type `S` is related to a target type `{ [P in Q]: T }` if `Q` is related to `keyof S` and `S[Q]` is related to `T`.
                            // A source type `S` is related to a target type `{ [P in Q as R]: T }` if `R` is related to `keyof S` and `S[R]` is related to `T.
                            // A source type `S` is related to a target type `{ [P in Q]?: T }` if some constituent `Q'` of `Q` is related to `keyof S` and `S[Q']` is related to `T`.
                            // A source type `S` is related to a target type `{ [P in Q as R]?: T }` if some constituent `R'` of `R` is related to `keyof S` and `S[R']` is related to `T`.
                            if (includeOptional
                                ? !(filteredByApplicability.flags & 131072 /* TypeFlags.Never */)
                                : isRelatedTo(targetKeys, sourceKeys, 3 /* RecursionFlags.Both */)) {
                                var templateType_1 = getTemplateTypeFromMappedType(target);
                                var typeParameter = getTypeParameterFromMappedType(target);
                                // Fastpath: When the template type has the form `Obj[P]` where `P` is the mapped type parameter, directly compare source `S` with `Obj`
                                // to avoid creating the (potentially very large) number of new intermediate types made by manufacturing `S[P]`.
                                var nonNullComponent = extractTypesOfKind(templateType_1, ~98304 /* TypeFlags.Nullable */);
                                if (!keysRemapped && nonNullComponent.flags & 8388608 /* TypeFlags.IndexedAccess */ && nonNullComponent.indexType === typeParameter) {
                                    if (result = isRelatedTo(source, nonNullComponent.objectType, 2 /* RecursionFlags.Target */, reportErrors)) {
                                        return result;
                                    }
                                }
                                else {
                                    // We need to compare the type of a property on the source type `S` to the type of the same property on the target type,
                                    // so we need to construct an indexing type representing a property, and then use indexing type to index the source type for comparison.
                                    // If the target type has shape `{ [P in Q]: T }`, then a property of the target has type `P`.
                                    // If the target type has shape `{ [P in Q]?: T }`, then a property of the target has type `P`,
                                    // but the property is optional, so we only want to compare properties `P` that are common between `keyof S` and `Q`.
                                    // If the target type has shape `{ [P in Q as R]: T }`, then a property of the target has type `R`.
                                    // If the target type has shape `{ [P in Q as R]?: T }`, then a property of the target has type `R`,
                                    // but the property is optional, so we only want to compare properties `R` that are common between `keyof S` and `R`.
                                    var indexingType = keysRemapped
                                        ? (filteredByApplicability || targetKeys)
                                        : filteredByApplicability
                                            ? getIntersectionType([filteredByApplicability, typeParameter])
                                            : typeParameter;
                                    var indexedAccessType = getIndexedAccessType(source, indexingType);
                                    // Compare `S[indexingType]` to `T`, where `T` is the type of a property of the target type.
                                    if (result = isRelatedTo(indexedAccessType, templateType_1, 3 /* RecursionFlags.Both */, reportErrors)) {
                                        return result;
                                    }
                                }
                            }
                            originalErrorInfo = errorInfo;
                            resetErrorInfo(saveErrorInfo);
                        }
                    }
                }
                else if (targetFlags & 16777216 /* TypeFlags.Conditional */) {
                    // If we reach 10 levels of nesting for the same conditional type, assume it is an infinitely expanding recursive
                    // conditional type and bail out with a Ternary.Maybe result.
                    if (isDeeplyNestedType(target, targetStack, targetDepth, 10)) {
                        return 3 /* Ternary.Maybe */;
                    }
                    var c = target;
                    // We check for a relationship to a conditional type target only when the conditional type has no
                    // 'infer' positions and is not distributive or is distributive but doesn't reference the check type
                    // parameter in either of the result types.
                    if (!c.root.inferTypeParameters && !isDistributionDependent(c.root)) {
                        // Check if the conditional is always true or always false but still deferred for distribution purposes.
                        var skipTrue = !isTypeAssignableTo(getPermissiveInstantiation(c.checkType), getPermissiveInstantiation(c.extendsType));
                        var skipFalse = !skipTrue && isTypeAssignableTo(getRestrictiveInstantiation(c.checkType), getRestrictiveInstantiation(c.extendsType));
                        // TODO: Find a nice way to include potential conditional type breakdowns in error output, if they seem good (they usually don't)
                        if (result = skipTrue ? -1 /* Ternary.True */ : isRelatedTo(source, getTrueTypeFromConditionalType(c), 2 /* RecursionFlags.Target */, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState)) {
                            result &= skipFalse ? -1 /* Ternary.True */ : isRelatedTo(source, getFalseTypeFromConditionalType(c), 2 /* RecursionFlags.Target */, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState);
                            if (result) {
                                return result;
                            }
                        }
                    }
                }
                else if (targetFlags & 134217728 /* TypeFlags.TemplateLiteral */) {
                    if (sourceFlags & 134217728 /* TypeFlags.TemplateLiteral */) {
                        if (relation === comparableRelation) {
                            return templateLiteralTypesDefinitelyUnrelated(source, target) ? 0 /* Ternary.False */ : -1 /* Ternary.True */;
                        }
                        // Report unreliable variance for type variables referenced in template literal type placeholders.
                        // For example, `foo-${number}` is related to `foo-${string}` even though number isn't related to string.
                        instantiateType(source, reportUnreliableMapper);
                    }
                    if (isTypeMatchedByTemplateLiteralType(source, target)) {
                        return -1 /* Ternary.True */;
                    }
                }
                else if (target.flags & 268435456 /* TypeFlags.StringMapping */) {
                    if (!(source.flags & 268435456 /* TypeFlags.StringMapping */)) {
                        if (isMemberOfStringMapping(source, target)) {
                            return -1 /* Ternary.True */;
                        }
                    }
                }
                if (sourceFlags & 8650752 /* TypeFlags.TypeVariable */) {
                    // IndexedAccess comparisons are handled above in the `targetFlags & TypeFlage.IndexedAccess` branch
                    if (!(sourceFlags & 8388608 /* TypeFlags.IndexedAccess */ && targetFlags & 8388608 /* TypeFlags.IndexedAccess */)) {
                        var constraint = getConstraintOfType(source) || unknownType;
                        // hi-speed no-this-instantiation check (less accurate, but avoids costly `this`-instantiation when the constraint will suffice), see #28231 for report on why this is needed
                        if (result = isRelatedTo(constraint, target, 1 /* RecursionFlags.Source */, /*reportErrors*/ false, /*headMessage*/ undefined, intersectionState)) {
                            return result;
                        }
                        // slower, fuller, this-instantiated check (necessary when comparing raw `this` types from base classes), see `subclassWithPolymorphicThisIsAssignable.ts` test for example
                        else if (result = isRelatedTo(getTypeWithThisArgument(constraint, source), target, 1 /* RecursionFlags.Source */, reportErrors && constraint !== unknownType && !(targetFlags & sourceFlags & 262144 /* TypeFlags.TypeParameter */), /*headMessage*/ undefined, intersectionState)) {
                            return result;
                        }
                        if (isMappedTypeGenericIndexedAccess(source)) {
                            // For an indexed access type { [P in K]: E}[X], above we have already explored an instantiation of E with X
                            // substituted for P. We also want to explore type { [P in K]: E }[C], where C is the constraint of X.
                            var indexConstraint = getConstraintOfType(source.indexType);
                            if (indexConstraint) {
                                if (result = isRelatedTo(getIndexedAccessType(source.objectType, indexConstraint), target, 1 /* RecursionFlags.Source */, reportErrors)) {
                                    return result;
                                }
                            }
                        }
                    }
                }
                else if (sourceFlags & 4194304 /* TypeFlags.Index */) {
                    if (result = isRelatedTo(keyofConstraintType, target, 1 /* RecursionFlags.Source */, reportErrors)) {
                        return result;
                    }
                }
                else if (sourceFlags & 134217728 /* TypeFlags.TemplateLiteral */ && !(targetFlags & 524288 /* TypeFlags.Object */)) {
                    if (!(targetFlags & 134217728 /* TypeFlags.TemplateLiteral */)) {
                        var constraint = getBaseConstraintOfType(source);
                        if (constraint && constraint !== source && (result = isRelatedTo(constraint, target, 1 /* RecursionFlags.Source */, reportErrors))) {
                            return result;
                        }
                    }
                }
                else if (sourceFlags & 268435456 /* TypeFlags.StringMapping */) {
                    if (targetFlags & 268435456 /* TypeFlags.StringMapping */) {
                        if (source.symbol !== target.symbol) {
                            return 0 /* Ternary.False */;
                        }
                        if (result = isRelatedTo(source.type, target.type, 3 /* RecursionFlags.Both */, reportErrors)) {
                            return result;
                        }
                    }
                    else {
                        var constraint = getBaseConstraintOfType(source);
                        if (constraint && (result = isRelatedTo(constraint, target, 1 /* RecursionFlags.Source */, reportErrors))) {
                            return result;
                        }
                    }
                }
                else if (sourceFlags & 16777216 /* TypeFlags.Conditional */) {
                    // If we reach 10 levels of nesting for the same conditional type, assume it is an infinitely expanding recursive
                    // conditional type and bail out with a Ternary.Maybe result.
                    if (isDeeplyNestedType(source, sourceStack, sourceDepth, 10)) {
                        return 3 /* Ternary.Maybe */;
                    }
                    if (targetFlags & 16777216 /* TypeFlags.Conditional */) {
                        // Two conditional types 'T1 extends U1 ? X1 : Y1' and 'T2 extends U2 ? X2 : Y2' are related if
                        // one of T1 and T2 is related to the other, U1 and U2 are identical types, X1 is related to X2,
                        // and Y1 is related to Y2.
                        var sourceParams = source.root.inferTypeParameters;
                        var sourceExtends = source.extendsType;
                        var mapper = void 0;
                        if (sourceParams) {
                            // If the source has infer type parameters, we instantiate them in the context of the target
                            var ctx = createInferenceContext(sourceParams, /*signature*/ undefined, 0 /* InferenceFlags.None */, isRelatedToWorker);
                            inferTypes(ctx.inferences, target.extendsType, sourceExtends, 512 /* InferencePriority.NoConstraints */ | 1024 /* InferencePriority.AlwaysStrict */);
                            sourceExtends = instantiateType(sourceExtends, ctx.mapper);
                            mapper = ctx.mapper;
                        }
                        if (isTypeIdenticalTo(sourceExtends, target.extendsType) &&
                            (isRelatedTo(source.checkType, target.checkType, 3 /* RecursionFlags.Both */) || isRelatedTo(target.checkType, source.checkType, 3 /* RecursionFlags.Both */))) {
                            if (result = isRelatedTo(instantiateType(getTrueTypeFromConditionalType(source), mapper), getTrueTypeFromConditionalType(target), 3 /* RecursionFlags.Both */, reportErrors)) {
                                result &= isRelatedTo(getFalseTypeFromConditionalType(source), getFalseTypeFromConditionalType(target), 3 /* RecursionFlags.Both */, reportErrors);
                            }
                            if (result) {
                                return result;
                            }
                        }
                    }
                    else {
                        // conditionals aren't related to one another via distributive constraint as it is much too inaccurate and allows way
                        // more assignments than are desirable (since it maps the source check type to its constraint, it loses information)
                        var distributiveConstraint = hasNonCircularBaseConstraint(source) ? getConstraintOfDistributiveConditionalType(source) : undefined;
                        if (distributiveConstraint) {
                            if (result = isRelatedTo(distributiveConstraint, target, 1 /* RecursionFlags.Source */, reportErrors)) {
                                return result;
                            }
                        }
                    }
                    // conditionals _can_ be related to one another via normal constraint, as, eg, `A extends B ? O : never` should be assignable to `O`
                    // when `O` is a conditional (`never` is trivially assignable to `O`, as is `O`!).
                    var defaultConstraint = getDefaultConstraintOfConditionalType(source);
                    if (defaultConstraint) {
                        if (result = isRelatedTo(defaultConstraint, target, 1 /* RecursionFlags.Source */, reportErrors)) {
                            return result;
                        }
                    }
                }
                else {
                    // An empty object type is related to any mapped type that includes a '?' modifier.
                    if (relation !== subtypeRelation && relation !== strictSubtypeRelation && isPartialMappedType(target) && isEmptyObjectType(source)) {
                        return -1 /* Ternary.True */;
                    }
                    if (isGenericMappedType(target)) {
                        if (isGenericMappedType(source)) {
                            if (result = mappedTypeRelatedTo(source, target, reportErrors)) {
                                return result;
                            }
                        }
                        return 0 /* Ternary.False */;
                    }
                    var sourceIsPrimitive = !!(sourceFlags & 131068 /* TypeFlags.Primitive */);
                    if (relation !== identityRelation) {
                        source = getApparentType(source);
                        sourceFlags = source.flags;
                    }
                    else if (isGenericMappedType(source)) {
                        return 0 /* Ternary.False */;
                    }
                    if (ts.getObjectFlags(source) & 4 /* ObjectFlags.Reference */ && ts.getObjectFlags(target) & 4 /* ObjectFlags.Reference */ && source.target === target.target &&
                        !isTupleType(source) && !(isMarkerType(source) || isMarkerType(target))) {
                        // When strictNullChecks is disabled, the element type of the empty array literal is undefinedWideningType,
                        // and an empty array literal wouldn't be assignable to a `never[]` without this check.
                        if (isEmptyArrayLiteralType(source)) {
                            return -1 /* Ternary.True */;
                        }
                        // We have type references to the same generic type, and the type references are not marker
                        // type references (which are intended by be compared structurally). Obtain the variance
                        // information for the type parameters and relate the type arguments accordingly.
                        var variances = getVariances(source.target);
                        // We return Ternary.Maybe for a recursive invocation of getVariances (signalled by emptyArray). This
                        // effectively means we measure variance only from type parameter occurrences that aren't nested in
                        // recursive instantiations of the generic type.
                        if (variances === ts.emptyArray) {
                            return 1 /* Ternary.Unknown */;
                        }
                        var varianceResult = relateVariances(getTypeArguments(source), getTypeArguments(target), variances, intersectionState);
                        if (varianceResult !== undefined) {
                            return varianceResult;
                        }
                    }
                    else if (isReadonlyArrayType(target) ? isArrayOrTupleType(source) : isArrayType(target) && isTupleType(source) && !source.target.readonly) {
                        if (relation !== identityRelation) {
                            return isRelatedTo(getIndexTypeOfType(source, numberType) || anyType, getIndexTypeOfType(target, numberType) || anyType, 3 /* RecursionFlags.Both */, reportErrors);
                        }
                        else {
                            // By flags alone, we know that the `target` is a readonly array while the source is a normal array or tuple
                            // or `target` is an array and source is a tuple - in both cases the types cannot be identical, by construction
                            return 0 /* Ternary.False */;
                        }
                    }
                    // Consider a fresh empty object literal type "closed" under the subtype relationship - this way `{} <- {[idx: string]: any} <- fresh({})`
                    // and not `{} <- fresh({}) <- {[idx: string]: any}`
                    else if ((relation === subtypeRelation || relation === strictSubtypeRelation) && isEmptyObjectType(target) && ts.getObjectFlags(target) & 8192 /* ObjectFlags.FreshLiteral */ && !isEmptyObjectType(source)) {
                        return 0 /* Ternary.False */;
                    }
                    // Even if relationship doesn't hold for unions, intersections, or generic type references,
                    // it may hold in a structural comparison.
                    // In a check of the form X = A & B, we will have previously checked if A relates to X or B relates
                    // to X. Failing both of those we want to check if the aggregation of A and B's members structurally
                    // relates to X. Thus, we include intersection types on the source side here.
                    if (sourceFlags & (524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */) && targetFlags & 524288 /* TypeFlags.Object */) {
                        // Report structural errors only if we haven't reported any errors yet
                        var reportStructuralErrors = reportErrors && errorInfo === saveErrorInfo.errorInfo && !sourceIsPrimitive;
                        result = propertiesRelatedTo(source, target, reportStructuralErrors, /*excludedProperties*/ undefined, intersectionState);
                        if (result) {
                            result &= signaturesRelatedTo(source, target, 0 /* SignatureKind.Call */, reportStructuralErrors);
                            if (result) {
                                result &= signaturesRelatedTo(source, target, 1 /* SignatureKind.Construct */, reportStructuralErrors);
                                if (result) {
                                    result &= indexSignaturesRelatedTo(source, target, sourceIsPrimitive, reportStructuralErrors, intersectionState);
                                }
                            }
                        }
                        if (varianceCheckFailed && result) {
                            errorInfo = originalErrorInfo || errorInfo || saveErrorInfo.errorInfo; // Use variance error (there is no structural one) and return false
                        }
                        else if (result) {
                            return result;
                        }
                    }
                    // If S is an object type and T is a discriminated union, S may be related to T if
                    // there exists a constituent of T for every combination of the discriminants of S
                    // with respect to T. We do not report errors here, as we will use the existing
                    // error result from checking each constituent of the union.
                    if (sourceFlags & (524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */) && targetFlags & 1048576 /* TypeFlags.Union */) {
                        var objectOnlyTarget = extractTypesOfKind(target, 524288 /* TypeFlags.Object */ | 2097152 /* TypeFlags.Intersection */ | 33554432 /* TypeFlags.Substitution */);
                        if (objectOnlyTarget.flags & 1048576 /* TypeFlags.Union */) {
                            var result_9 = typeRelatedToDiscriminatedType(source, objectOnlyTarget);
                            if (result_9) {
                                return result_9;
                            }
                        }
                    }
                }
                return 0 /* Ternary.False */;
                function countMessageChainBreadth(info) {
                    if (!info)
                        return 0;
                    return ts.reduceLeft(info, function (value, chain) { return value + 1 + countMessageChainBreadth(chain.next); }, 0);
                }
                function relateVariances(sourceTypeArguments, targetTypeArguments, variances, intersectionState) {
                    if (result = typeArgumentsRelatedTo(sourceTypeArguments, targetTypeArguments, variances, reportErrors, intersectionState)) {
                        return result;
                    }
                    if (ts.some(variances, function (v) { return !!(v & 24 /* VarianceFlags.AllowsStructuralFallback */); })) {
                        // If some type parameter was `Unmeasurable` or `Unreliable`, and we couldn't pass by assuming it was identical, then we
                        // have to allow a structural fallback check
                        // We elide the variance-based error elaborations, since those might not be too helpful, since we'll potentially
                        // be assuming identity of the type parameter.
                        originalErrorInfo = undefined;
                        resetErrorInfo(saveErrorInfo);
                        return undefined;
                    }
                    var allowStructuralFallback = targetTypeArguments && hasCovariantVoidArgument(targetTypeArguments, variances);
                    varianceCheckFailed = !allowStructuralFallback;
                    // The type arguments did not relate appropriately, but it may be because we have no variance
                    // information (in which case typeArgumentsRelatedTo defaulted to covariance for all type
                    // arguments). It might also be the case that the target type has a 'void' type argument for
                    // a covariant type parameter that is only used in return positions within the generic type
                    // (in which case any type argument is permitted on the source side). In those cases we proceed
                    // with a structural comparison. Otherwise, we know for certain the instantiations aren't
                    // related and we can return here.
                    if (variances !== ts.emptyArray && !allowStructuralFallback) {
                        // In some cases generic types that are covariant in regular type checking mode become
                        // invariant in --strictFunctionTypes mode because one or more type parameters are used in
                        // both co- and contravariant positions. In order to make it easier to diagnose *why* such
                        // types are invariant, if any of the type parameters are invariant we reset the reported
                        // errors and instead force a structural comparison (which will include elaborations that
                        // reveal the reason).
                        // We can switch on `reportErrors` here, since varianceCheckFailed guarantees we return `False`,
                        // we can return `False` early here to skip calculating the structural error message we don't need.
                        if (varianceCheckFailed && !(reportErrors && ts.some(variances, function (v) { return (v & 7 /* VarianceFlags.VarianceMask */) === 0 /* VarianceFlags.Invariant */; }))) {
                            return 0 /* Ternary.False */;
                        }
                        // We remember the original error information so we can restore it in case the structural
                        // comparison unexpectedly succeeds. This can happen when the structural comparison result
                        // is a Ternary.Maybe for example caused by the recursion depth limiter.
                        originalErrorInfo = errorInfo;
                        resetErrorInfo(saveErrorInfo);
                    }
                }
            }
            // A type [P in S]: X is related to a type [Q in T]: Y if T is related to S and X' is
            // related to Y, where X' is an instantiation of X in which P is replaced with Q. Notice
            // that S and T are contra-variant whereas X and Y are co-variant.
            function mappedTypeRelatedTo(source, target, reportErrors) {
                var modifiersRelated = relation === comparableRelation || (relation === identityRelation ? getMappedTypeModifiers(source) === getMappedTypeModifiers(target) :
                    getCombinedMappedTypeOptionality(source) <= getCombinedMappedTypeOptionality(target));
                if (modifiersRelated) {
                    var result_10;
                    var targetConstraint = getConstraintTypeFromMappedType(target);
                    var sourceConstraint = instantiateType(getConstraintTypeFromMappedType(source), getCombinedMappedTypeOptionality(source) < 0 ? reportUnmeasurableMapper : reportUnreliableMapper);
                    if (result_10 = isRelatedTo(targetConstraint, sourceConstraint, 3 /* RecursionFlags.Both */, reportErrors)) {
                        var mapper = createTypeMapper([getTypeParameterFromMappedType(source)], [getTypeParameterFromMappedType(target)]);
                        if (instantiateType(getNameTypeFromMappedType(source), mapper) === instantiateType(getNameTypeFromMappedType(target), mapper)) {
                            return result_10 & isRelatedTo(instantiateType(getTemplateTypeFromMappedType(source), mapper), getTemplateTypeFromMappedType(target), 3 /* RecursionFlags.Both */, reportErrors);
                        }
                    }
                }
                return 0 /* Ternary.False */;
            }
            function typeRelatedToDiscriminatedType(source, target) {
                // 1. Generate the combinations of discriminant properties & types 'source' can satisfy.
                //    a. If the number of combinations is above a set limit, the comparison is too complex.
                // 2. Filter 'target' to the subset of types whose discriminants exist in the matrix.
                //    a. If 'target' does not satisfy all discriminants in the matrix, 'source' is not related.
                // 3. For each type in the filtered 'target', determine if all non-discriminant properties of
                //    'target' are related to a property in 'source'.
                //
                // NOTE: See ~/tests/cases/conformance/types/typeRelationships/assignmentCompatibility/assignmentCompatWithDiscriminatedUnion.ts
                //       for examples.
                var sourceProperties = getPropertiesOfType(source);
                var sourcePropertiesFiltered = findDiscriminantProperties(sourceProperties, target);
                if (!sourcePropertiesFiltered)
                    return 0 /* Ternary.False */;
                // Though we could compute the number of combinations as we generate
                // the matrix, this would incur additional memory overhead due to
                // array allocations. To reduce this overhead, we first compute
                // the number of combinations to ensure we will not surpass our
                // fixed limit before incurring the cost of any allocations:
                var numCombinations = 1;
                for (var _i = 0, sourcePropertiesFiltered_1 = sourcePropertiesFiltered; _i < sourcePropertiesFiltered_1.length; _i++) {
                    var sourceProperty = sourcePropertiesFiltered_1[_i];
                    numCombinations *= countTypes(getNonMissingTypeOfSymbol(sourceProperty));
                    if (numCombinations > 25) {
                        // We've reached the complexity limit.
                        ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.instant("checkTypes" /* tracing.Phase.CheckTypes */, "typeRelatedToDiscriminatedType_DepthLimit", { sourceId: source.id, targetId: target.id, numCombinations: numCombinations });
                        return 0 /* Ternary.False */;
                    }
                }
                // Compute the set of types for each discriminant property.
                var sourceDiscriminantTypes = new Array(sourcePropertiesFiltered.length);
                var excludedProperties = new ts.Set();
                for (var i = 0; i < sourcePropertiesFiltered.length; i++) {
                    var sourceProperty = sourcePropertiesFiltered[i];
                    var sourcePropertyType = getNonMissingTypeOfSymbol(sourceProperty);
                    sourceDiscriminantTypes[i] = sourcePropertyType.flags & 1048576 /* TypeFlags.Union */
                        ? sourcePropertyType.types
                        : [sourcePropertyType];
                    excludedProperties.add(sourceProperty.escapedName);
                }
                // Match each combination of the cartesian product of discriminant properties to one or more
                // constituents of 'target'. If any combination does not have a match then 'source' is not relatable.
                var discriminantCombinations = ts.cartesianProduct(sourceDiscriminantTypes);
                var matchingTypes = [];
                var _loop_21 = function (combination) {
                    var hasMatch = false;
                    outer: for (var _c = 0, _d = target.types; _c < _d.length; _c++) {
                        var type = _d[_c];
                        var _loop_22 = function (i) {
                            var sourceProperty = sourcePropertiesFiltered[i];
                            var targetProperty = getPropertyOfType(type, sourceProperty.escapedName);
                            if (!targetProperty)
                                return "continue-outer";
                            if (sourceProperty === targetProperty)
                                return "continue";
                            // We compare the source property to the target in the context of a single discriminant type.
                            var related = propertyRelatedTo(source, target, sourceProperty, targetProperty, function (_) { return combination[i]; }, /*reportErrors*/ false, 0 /* IntersectionState.None */, /*skipOptional*/ strictNullChecks || relation === comparableRelation);
                            // If the target property could not be found, or if the properties were not related,
                            // then this constituent is not a match.
                            if (!related) {
                                return "continue-outer";
                            }
                        };
                        for (var i = 0; i < sourcePropertiesFiltered.length; i++) {
                            var state_8 = _loop_22(i);
                            switch (state_8) {
                                case "continue-outer": continue outer;
                            }
                        }
                        ts.pushIfUnique(matchingTypes, type, ts.equateValues);
                        hasMatch = true;
                    }
                    if (!hasMatch) {
                        return { value: 0 /* Ternary.False */ };
                    }
                };
                for (var _a = 0, discriminantCombinations_1 = discriminantCombinations; _a < discriminantCombinations_1.length; _a++) {
                    var combination = discriminantCombinations_1[_a];
                    var state_7 = _loop_21(combination);
                    if (typeof state_7 === "object")
                        return state_7.value;
                }
                // Compare the remaining non-discriminant properties of each match.
                var result = -1 /* Ternary.True */;
                for (var _b = 0, matchingTypes_1 = matchingTypes; _b < matchingTypes_1.length; _b++) {
                    var type = matchingTypes_1[_b];
                    result &= propertiesRelatedTo(source, type, /*reportErrors*/ false, excludedProperties, 0 /* IntersectionState.None */);
                    if (result) {
                        result &= signaturesRelatedTo(source, type, 0 /* SignatureKind.Call */, /*reportStructuralErrors*/ false);
                        if (result) {
                            result &= signaturesRelatedTo(source, type, 1 /* SignatureKind.Construct */, /*reportStructuralErrors*/ false);
                            if (result && !(isTupleType(source) && isTupleType(type))) {
                                // Comparing numeric index types when both `source` and `type` are tuples is unnecessary as the
                                // element types should be sufficiently covered by `propertiesRelatedTo`. It also causes problems
                                // with index type assignability as the types for the excluded discriminants are still included
                                // in the index type.
                                result &= indexSignaturesRelatedTo(source, type, /*sourceIsPrimitive*/ false, /*reportStructuralErrors*/ false, 0 /* IntersectionState.None */);
                            }
                        }
                    }
                    if (!result) {
                        return result;
                    }
                }
                return result;
            }
            function excludeProperties(properties, excludedProperties) {
                if (!excludedProperties || properties.length === 0)
                    return properties;
                var result;
                for (var i = 0; i < properties.length; i++) {
                    if (!excludedProperties.has(properties[i].escapedName)) {
                        if (result) {
                            result.push(properties[i]);
                        }
                    }
                    else if (!result) {
                        result = properties.slice(0, i);
                    }
                }
                return result || properties;
            }
            function isPropertySymbolTypeRelated(sourceProp, targetProp, getTypeOfSourceProperty, reportErrors, intersectionState) {
                var targetIsOptional = strictNullChecks && !!(ts.getCheckFlags(targetProp) & 48 /* CheckFlags.Partial */);
                var effectiveTarget = addOptionality(getNonMissingTypeOfSymbol(targetProp), /*isProperty*/ false, targetIsOptional);
                var effectiveSource = getTypeOfSourceProperty(sourceProp);
                return isRelatedTo(effectiveSource, effectiveTarget, 3 /* RecursionFlags.Both */, reportErrors, /*headMessage*/ undefined, intersectionState);
            }
            function propertyRelatedTo(source, target, sourceProp, targetProp, getTypeOfSourceProperty, reportErrors, intersectionState, skipOptional) {
                var sourcePropFlags = ts.getDeclarationModifierFlagsFromSymbol(sourceProp);
                var targetPropFlags = ts.getDeclarationModifierFlagsFromSymbol(targetProp);
                if (sourcePropFlags & 8 /* ModifierFlags.Private */ || targetPropFlags & 8 /* ModifierFlags.Private */) {
                    if (sourceProp.valueDeclaration !== targetProp.valueDeclaration) {
                        if (reportErrors) {
                            if (sourcePropFlags & 8 /* ModifierFlags.Private */ && targetPropFlags & 8 /* ModifierFlags.Private */) {
                                reportError(ts.Diagnostics.Types_have_separate_declarations_of_a_private_property_0, symbolToString(targetProp));
                            }
                            else {
                                reportError(ts.Diagnostics.Property_0_is_private_in_type_1_but_not_in_type_2, symbolToString(targetProp), typeToString(sourcePropFlags & 8 /* ModifierFlags.Private */ ? source : target), typeToString(sourcePropFlags & 8 /* ModifierFlags.Private */ ? target : source));
                            }
                        }
                        return 0 /* Ternary.False */;
                    }
                }
                else if (targetPropFlags & 16 /* ModifierFlags.Protected */) {
                    if (!isValidOverrideOf(sourceProp, targetProp)) {
                        if (reportErrors) {
                            reportError(ts.Diagnostics.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2, symbolToString(targetProp), typeToString(getDeclaringClass(sourceProp) || source), typeToString(getDeclaringClass(targetProp) || target));
                        }
                        return 0 /* Ternary.False */;
                    }
                }
                else if (sourcePropFlags & 16 /* ModifierFlags.Protected */) {
                    if (reportErrors) {
                        reportError(ts.Diagnostics.Property_0_is_protected_in_type_1_but_public_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target));
                    }
                    return 0 /* Ternary.False */;
                }
                // Ensure {readonly a: whatever} is not a subtype of {a: whatever},
                // while {a: whatever} is a subtype of {readonly a: whatever}.
                // This ensures the subtype relationship is ordered, and preventing declaration order
                // from deciding which type "wins" in union subtype reduction.
                // They're still assignable to one another, since `readonly` doesn't affect assignability.
                // This is only applied during the strictSubtypeRelation -- currently used in subtype reduction
                if (relation === strictSubtypeRelation &&
                    isReadonlySymbol(sourceProp) && !isReadonlySymbol(targetProp)) {
                    return 0 /* Ternary.False */;
                }
                // If the target comes from a partial union prop, allow `undefined` in the target type
                var related = isPropertySymbolTypeRelated(sourceProp, targetProp, getTypeOfSourceProperty, reportErrors, intersectionState);
                if (!related) {
                    if (reportErrors) {
                        reportIncompatibleError(ts.Diagnostics.Types_of_property_0_are_incompatible, symbolToString(targetProp));
                    }
                    return 0 /* Ternary.False */;
                }
                // When checking for comparability, be more lenient with optional properties.
                if (!skipOptional && sourceProp.flags & 16777216 /* SymbolFlags.Optional */ && targetProp.flags & 106500 /* SymbolFlags.ClassMember */ && !(targetProp.flags & 16777216 /* SymbolFlags.Optional */)) {
                    // TypeScript 1.0 spec (April 2014): 3.8.3
                    // S is a subtype of a type T, and T is a supertype of S if ...
                    // S' and T are object types and, for each member M in T..
                    // M is a property and S' contains a property N where
                    // if M is a required property, N is also a required property
                    // (M - property in T)
                    // (N - property in S)
                    if (reportErrors) {
                        reportError(ts.Diagnostics.Property_0_is_optional_in_type_1_but_required_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target));
                    }
                    return 0 /* Ternary.False */;
                }
                return related;
            }
            function reportUnmatchedProperty(source, target, unmatchedProperty, requireOptionalProperties) {
                var shouldSkipElaboration = false;
                // give specific error in case where private names have the same description
                if (unmatchedProperty.valueDeclaration
                    && ts.isNamedDeclaration(unmatchedProperty.valueDeclaration)
                    && ts.isPrivateIdentifier(unmatchedProperty.valueDeclaration.name)
                    && source.symbol
                    && source.symbol.flags & 32 /* SymbolFlags.Class */) {
                    var privateIdentifierDescription = unmatchedProperty.valueDeclaration.name.escapedText;
                    var symbolTableKey = ts.getSymbolNameForPrivateIdentifier(source.symbol, privateIdentifierDescription);
                    if (symbolTableKey && getPropertyOfType(source, symbolTableKey)) {
                        var sourceName = ts.factory.getDeclarationName(source.symbol.valueDeclaration);
                        var targetName = ts.factory.getDeclarationName(target.symbol.valueDeclaration);
                        reportError(ts.Diagnostics.Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2, diagnosticName(privateIdentifierDescription), diagnosticName(sourceName.escapedText === "" ? anon : sourceName), diagnosticName(targetName.escapedText === "" ? anon : targetName));
                        return;
                    }
                }
                var props = ts.arrayFrom(getUnmatchedProperties(source, target, requireOptionalProperties, /*matchDiscriminantProperties*/ false));
                if (!headMessage || (headMessage.code !== ts.Diagnostics.Class_0_incorrectly_implements_interface_1.code &&
                    headMessage.code !== ts.Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass.code)) {
                    shouldSkipElaboration = true; // Retain top-level error for interface implementing issues, otherwise omit it
                }
                if (props.length === 1) {
                    var propName = symbolToString(unmatchedProperty, /*enclosingDeclaration*/ undefined, 0 /* SymbolFlags.None */, 4 /* SymbolFormatFlags.AllowAnyNodeKind */ | 16 /* SymbolFormatFlags.WriteComputedProps */);
                    reportError.apply(void 0, __spreadArray([ts.Diagnostics.Property_0_is_missing_in_type_1_but_required_in_type_2, propName], getTypeNamesForErrorDisplay(source, target), false));
                    if (ts.length(unmatchedProperty.declarations)) {
                        associateRelatedInfo(ts.createDiagnosticForNode(unmatchedProperty.declarations[0], ts.Diagnostics._0_is_declared_here, propName));
                    }
                    if (shouldSkipElaboration && errorInfo) {
                        overrideNextErrorInfo++;
                    }
                }
                else if (tryElaborateArrayLikeErrors(source, target, /*reportErrors*/ false)) {
                    if (props.length > 5) { // arbitrary cutoff for too-long list form
                        reportError(ts.Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more, typeToString(source), typeToString(target), ts.map(props.slice(0, 4), function (p) { return symbolToString(p); }).join(", "), props.length - 4);
                    }
                    else {
                        reportError(ts.Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2, typeToString(source), typeToString(target), ts.map(props, function (p) { return symbolToString(p); }).join(", "));
                    }
                    if (shouldSkipElaboration && errorInfo) {
                        overrideNextErrorInfo++;
                    }
                }
                // No array like or unmatched property error - just issue top level error (errorInfo = undefined)
            }
            function propertiesRelatedTo(source, target, reportErrors, excludedProperties, intersectionState) {
                if (relation === identityRelation) {
                    return propertiesIdenticalTo(source, target, excludedProperties);
                }
                var result = -1 /* Ternary.True */;
                if (isTupleType(target)) {
                    if (isArrayOrTupleType(source)) {
                        if (!target.target.readonly && (isReadonlyArrayType(source) || isTupleType(source) && source.target.readonly)) {
                            return 0 /* Ternary.False */;
                        }
                        var sourceArity = getTypeReferenceArity(source);
                        var targetArity = getTypeReferenceArity(target);
                        var sourceRestFlag = isTupleType(source) ? source.target.combinedFlags & 4 /* ElementFlags.Rest */ : 4 /* ElementFlags.Rest */;
                        var targetRestFlag = target.target.combinedFlags & 4 /* ElementFlags.Rest */;
                        var sourceMinLength = isTupleType(source) ? source.target.minLength : 0;
                        var targetMinLength = target.target.minLength;
                        if (!sourceRestFlag && sourceArity < targetMinLength) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Source_has_0_element_s_but_target_requires_1, sourceArity, targetMinLength);
                            }
                            return 0 /* Ternary.False */;
                        }
                        if (!targetRestFlag && targetArity < sourceMinLength) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Source_has_0_element_s_but_target_allows_only_1, sourceMinLength, targetArity);
                            }
                            return 0 /* Ternary.False */;
                        }
                        if (!targetRestFlag && (sourceRestFlag || targetArity < sourceArity)) {
                            if (reportErrors) {
                                if (sourceMinLength < targetMinLength) {
                                    reportError(ts.Diagnostics.Target_requires_0_element_s_but_source_may_have_fewer, targetMinLength);
                                }
                                else {
                                    reportError(ts.Diagnostics.Target_allows_only_0_element_s_but_source_may_have_more, targetArity);
                                }
                            }
                            return 0 /* Ternary.False */;
                        }
                        var sourceTypeArguments = getTypeArguments(source);
                        var targetTypeArguments = getTypeArguments(target);
                        var startCount = Math.min(isTupleType(source) ? getStartElementCount(source.target, 11 /* ElementFlags.NonRest */) : 0, getStartElementCount(target.target, 11 /* ElementFlags.NonRest */));
                        var endCount = Math.min(isTupleType(source) ? getEndElementCount(source.target, 11 /* ElementFlags.NonRest */) : 0, targetRestFlag ? getEndElementCount(target.target, 11 /* ElementFlags.NonRest */) : 0);
                        var canExcludeDiscriminants = !!excludedProperties;
                        for (var i = 0; i < targetArity; i++) {
                            var sourceIndex = i < targetArity - endCount ? i : i + sourceArity - targetArity;
                            var sourceFlags = isTupleType(source) && (i < startCount || i >= targetArity - endCount) ? source.target.elementFlags[sourceIndex] : 4 /* ElementFlags.Rest */;
                            var targetFlags = target.target.elementFlags[i];
                            if (targetFlags & 8 /* ElementFlags.Variadic */ && !(sourceFlags & 8 /* ElementFlags.Variadic */)) {
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Source_provides_no_match_for_variadic_element_at_position_0_in_target, i);
                                }
                                return 0 /* Ternary.False */;
                            }
                            if (sourceFlags & 8 /* ElementFlags.Variadic */ && !(targetFlags & 12 /* ElementFlags.Variable */)) {
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target, sourceIndex, i);
                                }
                                return 0 /* Ternary.False */;
                            }
                            if (targetFlags & 1 /* ElementFlags.Required */ && !(sourceFlags & 1 /* ElementFlags.Required */)) {
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Source_provides_no_match_for_required_element_at_position_0_in_target, i);
                                }
                                return 0 /* Ternary.False */;
                            }
                            // We can only exclude discriminant properties if we have not yet encountered a variable-length element.
                            if (canExcludeDiscriminants) {
                                if (sourceFlags & 12 /* ElementFlags.Variable */ || targetFlags & 12 /* ElementFlags.Variable */) {
                                    canExcludeDiscriminants = false;
                                }
                                if (canExcludeDiscriminants && (excludedProperties === null || excludedProperties === void 0 ? void 0 : excludedProperties.has(("" + i)))) {
                                    continue;
                                }
                            }
                            var sourceType = !isTupleType(source) ? sourceTypeArguments[0] :
                                i < startCount || i >= targetArity - endCount ? removeMissingType(sourceTypeArguments[sourceIndex], !!(sourceFlags & targetFlags & 2 /* ElementFlags.Optional */)) :
                                    getElementTypeOfSliceOfTupleType(source, startCount, endCount) || neverType;
                            var targetType = targetTypeArguments[i];
                            var targetCheckType = sourceFlags & 8 /* ElementFlags.Variadic */ && targetFlags & 4 /* ElementFlags.Rest */ ? createArrayType(targetType) :
                                removeMissingType(targetType, !!(targetFlags & 2 /* ElementFlags.Optional */));
                            var related = isRelatedTo(sourceType, targetCheckType, 3 /* RecursionFlags.Both */, reportErrors, /*headMessage*/ undefined, intersectionState);
                            if (!related) {
                                if (reportErrors && (targetArity > 1 || sourceArity > 1)) {
                                    if (i < startCount || i >= targetArity - endCount || sourceArity - startCount - endCount === 1) {
                                        reportIncompatibleError(ts.Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, sourceIndex, i);
                                    }
                                    else {
                                        reportIncompatibleError(ts.Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, startCount, sourceArity - endCount - 1, i);
                                    }
                                }
                                return 0 /* Ternary.False */;
                            }
                            result &= related;
                        }
                        return result;
                    }
                    if (target.target.combinedFlags & 12 /* ElementFlags.Variable */) {
                        return 0 /* Ternary.False */;
                    }
                }
                var requireOptionalProperties = (relation === subtypeRelation || relation === strictSubtypeRelation) && !isObjectLiteralType(source) && !isEmptyArrayLiteralType(source) && !isTupleType(source);
                var unmatchedProperty = getUnmatchedProperty(source, target, requireOptionalProperties, /*matchDiscriminantProperties*/ false);
                if (unmatchedProperty) {
                    if (reportErrors && shouldReportUnmatchedPropertyError(source, target)) {
                        reportUnmatchedProperty(source, target, unmatchedProperty, requireOptionalProperties);
                    }
                    return 0 /* Ternary.False */;
                }
                if (isObjectLiteralType(target)) {
                    for (var _i = 0, _a = excludeProperties(getPropertiesOfType(source), excludedProperties); _i < _a.length; _i++) {
                        var sourceProp = _a[_i];
                        if (!getPropertyOfObjectType(target, sourceProp.escapedName)) {
                            var sourceType = getTypeOfSymbol(sourceProp);
                            if (!(sourceType.flags & 32768 /* TypeFlags.Undefined */)) {
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Property_0_does_not_exist_on_type_1, symbolToString(sourceProp), typeToString(target));
                                }
                                return 0 /* Ternary.False */;
                            }
                        }
                    }
                }
                // We only call this for union target types when we're attempting to do excess property checking - in those cases, we want to get _all possible props_
                // from the target union, across all members
                var properties = getPropertiesOfType(target);
                var numericNamesOnly = isTupleType(source) && isTupleType(target);
                for (var _b = 0, _c = excludeProperties(properties, excludedProperties); _b < _c.length; _b++) {
                    var targetProp = _c[_b];
                    var name = targetProp.escapedName;
                    if (!(targetProp.flags & 4194304 /* SymbolFlags.Prototype */) && (!numericNamesOnly || ts.isNumericLiteralName(name) || name === "length")) {
                        var sourceProp = getPropertyOfType(source, name);
                        if (sourceProp && sourceProp !== targetProp) {
                            var related = propertyRelatedTo(source, target, sourceProp, targetProp, getNonMissingTypeOfSymbol, reportErrors, intersectionState, relation === comparableRelation);
                            if (!related) {
                                return 0 /* Ternary.False */;
                            }
                            result &= related;
                        }
                    }
                }
                return result;
            }
            function propertiesIdenticalTo(source, target, excludedProperties) {
                if (!(source.flags & 524288 /* TypeFlags.Object */ && target.flags & 524288 /* TypeFlags.Object */)) {
                    return 0 /* Ternary.False */;
                }
                var sourceProperties = excludeProperties(getPropertiesOfObjectType(source), excludedProperties);
                var targetProperties = excludeProperties(getPropertiesOfObjectType(target), excludedProperties);
                if (sourceProperties.length !== targetProperties.length) {
                    return 0 /* Ternary.False */;
                }
                var result = -1 /* Ternary.True */;
                for (var _i = 0, sourceProperties_1 = sourceProperties; _i < sourceProperties_1.length; _i++) {
                    var sourceProp = sourceProperties_1[_i];
                    var targetProp = getPropertyOfObjectType(target, sourceProp.escapedName);
                    if (!targetProp) {
                        return 0 /* Ternary.False */;
                    }
                    var related = compareProperties(sourceProp, targetProp, isRelatedTo);
                    if (!related) {
                        return 0 /* Ternary.False */;
                    }
                    result &= related;
                }
                return result;
            }
            function signaturesRelatedTo(source, target, kind, reportErrors) {
                var _a, _b;
                if (relation === identityRelation) {
                    return signaturesIdenticalTo(source, target, kind);
                }
                if (target === anyFunctionType || source === anyFunctionType) {
                    return -1 /* Ternary.True */;
                }
                var sourceIsJSConstructor = source.symbol && isJSConstructor(source.symbol.valueDeclaration);
                var targetIsJSConstructor = target.symbol && isJSConstructor(target.symbol.valueDeclaration);
                var sourceSignatures = getSignaturesOfType(source, (sourceIsJSConstructor && kind === 1 /* SignatureKind.Construct */) ?
                    0 /* SignatureKind.Call */ : kind);
                var targetSignatures = getSignaturesOfType(target, (targetIsJSConstructor && kind === 1 /* SignatureKind.Construct */) ?
                    0 /* SignatureKind.Call */ : kind);
                if (kind === 1 /* SignatureKind.Construct */ && sourceSignatures.length && targetSignatures.length) {
                    var sourceIsAbstract = !!(sourceSignatures[0].flags & 4 /* SignatureFlags.Abstract */);
                    var targetIsAbstract = !!(targetSignatures[0].flags & 4 /* SignatureFlags.Abstract */);
                    if (sourceIsAbstract && !targetIsAbstract) {
                        // An abstract constructor type is not assignable to a non-abstract constructor type
                        // as it would otherwise be possible to new an abstract class. Note that the assignability
                        // check we perform for an extends clause excludes construct signatures from the target,
                        // so this check never proceeds.
                        if (reportErrors) {
                            reportError(ts.Diagnostics.Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type);
                        }
                        return 0 /* Ternary.False */;
                    }
                    if (!constructorVisibilitiesAreCompatible(sourceSignatures[0], targetSignatures[0], reportErrors)) {
                        return 0 /* Ternary.False */;
                    }
                }
                var result = -1 /* Ternary.True */;
                var incompatibleReporter = kind === 1 /* SignatureKind.Construct */ ? reportIncompatibleConstructSignatureReturn : reportIncompatibleCallSignatureReturn;
                var sourceObjectFlags = ts.getObjectFlags(source);
                var targetObjectFlags = ts.getObjectFlags(target);
                if (sourceObjectFlags & 64 /* ObjectFlags.Instantiated */ && targetObjectFlags & 64 /* ObjectFlags.Instantiated */ && source.symbol === target.symbol ||
                    sourceObjectFlags & 4 /* ObjectFlags.Reference */ && targetObjectFlags & 4 /* ObjectFlags.Reference */ && source.target === target.target) {
                    // We have instantiations of the same anonymous type (which typically will be the type of a
                    // method). Simply do a pairwise comparison of the signatures in the two signature lists instead
                    // of the much more expensive N * M comparison matrix we explore below. We erase type parameters
                    // as they are known to always be the same.
                    for (var i = 0; i < targetSignatures.length; i++) {
                        var related = signatureRelatedTo(sourceSignatures[i], targetSignatures[i], /*erase*/ true, reportErrors, incompatibleReporter(sourceSignatures[i], targetSignatures[i]));
                        if (!related) {
                            return 0 /* Ternary.False */;
                        }
                        result &= related;
                    }
                }
                else if (sourceSignatures.length === 1 && targetSignatures.length === 1) {
                    // For simple functions (functions with a single signature) we only erase type parameters for
                    // the comparable relation. Otherwise, if the source signature is generic, we instantiate it
                    // in the context of the target signature before checking the relationship. Ideally we'd do
                    // this regardless of the number of signatures, but the potential costs are prohibitive due
                    // to the quadratic nature of the logic below.
                    var eraseGenerics = relation === comparableRelation || !!compilerOptions.noStrictGenericChecks;
                    var sourceSignature = ts.first(sourceSignatures);
                    var targetSignature = ts.first(targetSignatures);
                    result = signatureRelatedTo(sourceSignature, targetSignature, eraseGenerics, reportErrors, incompatibleReporter(sourceSignature, targetSignature));
                    if (!result && reportErrors && kind === 1 /* SignatureKind.Construct */ && (sourceObjectFlags & targetObjectFlags) &&
                        (((_a = targetSignature.declaration) === null || _a === void 0 ? void 0 : _a.kind) === 173 /* SyntaxKind.Constructor */ || ((_b = sourceSignature.declaration) === null || _b === void 0 ? void 0 : _b.kind) === 173 /* SyntaxKind.Constructor */)) {
                        var constructSignatureToString = function (signature) {
                            return signatureToString(signature, /*enclosingDeclaration*/ undefined, 262144 /* TypeFormatFlags.WriteArrowStyleSignature */, kind);
                        };
                        reportError(ts.Diagnostics.Type_0_is_not_assignable_to_type_1, constructSignatureToString(sourceSignature), constructSignatureToString(targetSignature));
                        reportError(ts.Diagnostics.Types_of_construct_signatures_are_incompatible);
                        return result;
                    }
                }
                else {
                    outer: for (var _i = 0, targetSignatures_1 = targetSignatures; _i < targetSignatures_1.length; _i++) {
                        var t = targetSignatures_1[_i];
                        var saveErrorInfo = captureErrorCalculationState();
                        // Only elaborate errors from the first failure
                        var shouldElaborateErrors = reportErrors;
                        for (var _c = 0, sourceSignatures_1 = sourceSignatures; _c < sourceSignatures_1.length; _c++) {
                            var s = sourceSignatures_1[_c];
                            var related = signatureRelatedTo(s, t, /*erase*/ true, shouldElaborateErrors, incompatibleReporter(s, t));
                            if (related) {
                                result &= related;
                                resetErrorInfo(saveErrorInfo);
                                continue outer;
                            }
                            shouldElaborateErrors = false;
                        }
                        if (shouldElaborateErrors) {
                            reportError(ts.Diagnostics.Type_0_provides_no_match_for_the_signature_1, typeToString(source), signatureToString(t, /*enclosingDeclaration*/ undefined, /*flags*/ undefined, kind));
                        }
                        return 0 /* Ternary.False */;
                    }
                }
                return result;
            }
            function shouldReportUnmatchedPropertyError(source, target) {
                var typeCallSignatures = getSignaturesOfStructuredType(source, 0 /* SignatureKind.Call */);
                var typeConstructSignatures = getSignaturesOfStructuredType(source, 1 /* SignatureKind.Construct */);
                var typeProperties = getPropertiesOfObjectType(source);
                if ((typeCallSignatures.length || typeConstructSignatures.length) && !typeProperties.length) {
                    if ((getSignaturesOfType(target, 0 /* SignatureKind.Call */).length && typeCallSignatures.length) ||
                        (getSignaturesOfType(target, 1 /* SignatureKind.Construct */).length && typeConstructSignatures.length)) {
                        return true; // target has similar signature kinds to source, still focus on the unmatched property
                    }
                    return false;
                }
                return true;
            }
            function reportIncompatibleCallSignatureReturn(siga, sigb) {
                if (siga.parameters.length === 0 && sigb.parameters.length === 0) {
                    return function (source, target) { return reportIncompatibleError(ts.Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source), typeToString(target)); };
                }
                return function (source, target) { return reportIncompatibleError(ts.Diagnostics.Call_signature_return_types_0_and_1_are_incompatible, typeToString(source), typeToString(target)); };
            }
            function reportIncompatibleConstructSignatureReturn(siga, sigb) {
                if (siga.parameters.length === 0 && sigb.parameters.length === 0) {
                    return function (source, target) { return reportIncompatibleError(ts.Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source), typeToString(target)); };
                }
                return function (source, target) { return reportIncompatibleError(ts.Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible, typeToString(source), typeToString(target)); };
            }
            /**
             * See signatureAssignableTo, compareSignaturesIdentical
             */
            function signatureRelatedTo(source, target, erase, reportErrors, incompatibleReporter) {
                return compareSignaturesRelated(erase ? getErasedSignature(source) : source, erase ? getErasedSignature(target) : target, relation === strictSubtypeRelation ? 8 /* SignatureCheckMode.StrictArity */ : 0, reportErrors, reportError, incompatibleReporter, isRelatedToWorker, reportUnreliableMapper);
            }
            function signaturesIdenticalTo(source, target, kind) {
                var sourceSignatures = getSignaturesOfType(source, kind);
                var targetSignatures = getSignaturesOfType(target, kind);
                if (sourceSignatures.length !== targetSignatures.length) {
                    return 0 /* Ternary.False */;
                }
                var result = -1 /* Ternary.True */;
                for (var i = 0; i < sourceSignatures.length; i++) {
                    var related = compareSignaturesIdentical(sourceSignatures[i], targetSignatures[i], /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ false, isRelatedTo);
                    if (!related) {
                        return 0 /* Ternary.False */;
                    }
                    result &= related;
                }
                return result;
            }
            function membersRelatedToIndexInfo(source, targetInfo, reportErrors) {
                var result = -1 /* Ternary.True */;
                var keyType = targetInfo.keyType;
                var props = source.flags & 2097152 /* TypeFlags.Intersection */ ? getPropertiesOfUnionOrIntersectionType(source) : getPropertiesOfObjectType(source);
                for (var _i = 0, props_2 = props; _i < props_2.length; _i++) {
                    var prop = props_2[_i];
                    // Skip over ignored JSX and symbol-named members
                    if (isIgnoredJsxProperty(source, prop)) {
                        continue;
                    }
                    if (isApplicableIndexType(getLiteralTypeFromProperty(prop, 8576 /* TypeFlags.StringOrNumberLiteralOrUnique */), keyType)) {
                        var propType = getNonMissingTypeOfSymbol(prop);
                        var type = exactOptionalPropertyTypes || propType.flags & 32768 /* TypeFlags.Undefined */ || keyType === numberType || !(prop.flags & 16777216 /* SymbolFlags.Optional */)
                            ? propType
                            : getTypeWithFacts(propType, 524288 /* TypeFacts.NEUndefined */);
                        var related = isRelatedTo(type, targetInfo.type, 3 /* RecursionFlags.Both */, reportErrors);
                        if (!related) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Property_0_is_incompatible_with_index_signature, symbolToString(prop));
                            }
                            return 0 /* Ternary.False */;
                        }
                        result &= related;
                    }
                }
                for (var _a = 0, _b = getIndexInfosOfType(source); _a < _b.length; _a++) {
                    var info = _b[_a];
                    if (isApplicableIndexType(info.keyType, keyType)) {
                        var related = indexInfoRelatedTo(info, targetInfo, reportErrors);
                        if (!related) {
                            return 0 /* Ternary.False */;
                        }
                        result &= related;
                    }
                }
                return result;
            }
            function indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors) {
                var related = isRelatedTo(sourceInfo.type, targetInfo.type, 3 /* RecursionFlags.Both */, reportErrors);
                if (!related && reportErrors) {
                    if (sourceInfo.keyType === targetInfo.keyType) {
                        reportError(ts.Diagnostics._0_index_signatures_are_incompatible, typeToString(sourceInfo.keyType));
                    }
                    else {
                        reportError(ts.Diagnostics._0_and_1_index_signatures_are_incompatible, typeToString(sourceInfo.keyType), typeToString(targetInfo.keyType));
                    }
                }
                return related;
            }
            function indexSignaturesRelatedTo(source, target, sourceIsPrimitive, reportErrors, intersectionState) {
                if (relation === identityRelation) {
                    return indexSignaturesIdenticalTo(source, target);
                }
                var indexInfos = getIndexInfosOfType(target);
                var targetHasStringIndex = ts.some(indexInfos, function (info) { return info.keyType === stringType; });
                var result = -1 /* Ternary.True */;
                for (var _i = 0, indexInfos_5 = indexInfos; _i < indexInfos_5.length; _i++) {
                    var targetInfo = indexInfos_5[_i];
                    var related = !sourceIsPrimitive && targetHasStringIndex && targetInfo.type.flags & 1 /* TypeFlags.Any */ ? -1 /* Ternary.True */ :
                        isGenericMappedType(source) && targetHasStringIndex ? isRelatedTo(getTemplateTypeFromMappedType(source), targetInfo.type, 3 /* RecursionFlags.Both */, reportErrors) :
                            typeRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState);
                    if (!related) {
                        return 0 /* Ternary.False */;
                    }
                    result &= related;
                }
                return result;
            }
            function typeRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState) {
                var sourceInfo = getApplicableIndexInfo(source, targetInfo.keyType);
                if (sourceInfo) {
                    return indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors);
                }
                if (!(intersectionState & 1 /* IntersectionState.Source */) && isObjectTypeWithInferableIndex(source)) {
                    // Intersection constituents are never considered to have an inferred index signature
                    return membersRelatedToIndexInfo(source, targetInfo, reportErrors);
                }
                if (reportErrors) {
                    reportError(ts.Diagnostics.Index_signature_for_type_0_is_missing_in_type_1, typeToString(targetInfo.keyType), typeToString(source));
                }
                return 0 /* Ternary.False */;
            }
            function indexSignaturesIdenticalTo(source, target) {
                var sourceInfos = getIndexInfosOfType(source);
                var targetInfos = getIndexInfosOfType(target);
                if (sourceInfos.length !== targetInfos.length) {
                    return 0 /* Ternary.False */;
                }
                for (var _i = 0, targetInfos_1 = targetInfos; _i < targetInfos_1.length; _i++) {
                    var targetInfo = targetInfos_1[_i];
                    var sourceInfo = getIndexInfoOfType(source, targetInfo.keyType);
                    if (!(sourceInfo && isRelatedTo(sourceInfo.type, targetInfo.type, 3 /* RecursionFlags.Both */) && sourceInfo.isReadonly === targetInfo.isReadonly)) {
                        return 0 /* Ternary.False */;
                    }
                }
                return -1 /* Ternary.True */;
            }
            function constructorVisibilitiesAreCompatible(sourceSignature, targetSignature, reportErrors) {
                if (!sourceSignature.declaration || !targetSignature.declaration) {
                    return true;
                }
                var sourceAccessibility = ts.getSelectedEffectiveModifierFlags(sourceSignature.declaration, 24 /* ModifierFlags.NonPublicAccessibilityModifier */);
                var targetAccessibility = ts.getSelectedEffectiveModifierFlags(targetSignature.declaration, 24 /* ModifierFlags.NonPublicAccessibilityModifier */);
                // A public, protected and private signature is assignable to a private signature.
                if (targetAccessibility === 8 /* ModifierFlags.Private */) {
                    return true;
                }
                // A public and protected signature is assignable to a protected signature.
                if (targetAccessibility === 16 /* ModifierFlags.Protected */ && sourceAccessibility !== 8 /* ModifierFlags.Private */) {
                    return true;
                }
                // Only a public signature is assignable to public signature.
                if (targetAccessibility !== 16 /* ModifierFlags.Protected */ && !sourceAccessibility) {
                    return true;
                }
                if (reportErrors) {
                    reportError(ts.Diagnostics.Cannot_assign_a_0_constructor_type_to_a_1_constructor_type, visibilityToString(sourceAccessibility), visibilityToString(targetAccessibility));
                }
                return false;
            }
        }
        function typeCouldHaveTopLevelSingletonTypes(type) {
            // Okay, yes, 'boolean' is a union of 'true | false', but that's not useful
            // in error reporting scenarios. If you need to use this function but that detail matters,
            // feel free to add a flag.
            if (type.flags & 16 /* TypeFlags.Boolean */) {
                return false;
            }
            if (type.flags & 3145728 /* TypeFlags.UnionOrIntersection */) {
                return !!ts.forEach(type.types, typeCouldHaveTopLevelSingletonTypes);
            }
            if (type.flags & 465829888 /* TypeFlags.Instantiable */) {
                var constraint = getConstraintOfType(type);
                if (constraint && constraint !== type) {
                    return typeCouldHaveTopLevelSingletonTypes(constraint);
                }
            }
            return isUnitType(type) || !!(type.flags & 134217728 /* TypeFlags.TemplateLiteral */) || !!(type.flags & 268435456 /* TypeFlags.StringMapping */);
        }
        function getExactOptionalUnassignableProperties(source, target) {
            if (isTupleType(source) && isTupleType(target))
                return ts.emptyArray;
            return getPropertiesOfType(target)
                .filter(function (targetProp) { return isExactOptionalPropertyMismatch(getTypeOfPropertyOfType(source, targetProp.escapedName), getTypeOfSymbol(targetProp)); });
        }
        function isExactOptionalPropertyMismatch(source, target) {
            return !!source && !!target && maybeTypeOfKind(source, 32768 /* TypeFlags.Undefined */) && !!containsMissingType(target);
        }
        function getExactOptionalProperties(type) {
            return getPropertiesOfType(type).filter(function (targetProp) { return containsMissingType(getTypeOfSymbol(targetProp)); });
        }
        function getBestMatchingType(source, target, isRelatedTo) {
            if (isRelatedTo === void 0) { isRelatedTo = compareTypesAssignable; }
            return findMatchingDiscriminantType(source, target, isRelatedTo, /*skipPartial*/ true) ||
                findMatchingTypeReferenceOrTypeAliasReference(source, target) ||
                findBestTypeForObjectLiteral(source, target) ||
                findBestTypeForInvokable(source, target) ||
                findMostOverlappyType(source, target);
        }
        function discriminateTypeByDiscriminableItems(target, discriminators, related, defaultValue, skipPartial) {
            // undefined=unknown, true=discriminated, false=not discriminated
            // The state of each type progresses from left to right. Discriminated types stop at 'true'.
            var discriminable = target.types.map(function (_) { return undefined; });
            for (var _i = 0, discriminators_1 = discriminators; _i < discriminators_1.length; _i++) {
                var _a = discriminators_1[_i], getDiscriminatingType = _a[0], propertyName = _a[1];
                var targetProp = getUnionOrIntersectionProperty(target, propertyName);
                if (skipPartial && targetProp && ts.getCheckFlags(targetProp) & 16 /* CheckFlags.ReadPartial */) {
                    continue;
                }
                var i = 0;
                for (var _b = 0, _c = target.types; _b < _c.length; _b++) {
                    var type = _c[_b];
                    var targetType = getTypeOfPropertyOfType(type, propertyName);
                    if (targetType && related(getDiscriminatingType(), targetType)) {
                        discriminable[i] = discriminable[i] === undefined ? true : discriminable[i];
                    }
                    else {
                        discriminable[i] = false;
                    }
                    i++;
                }
            }
            var match = discriminable.indexOf(/*searchElement*/ true);
            if (match === -1) {
                return defaultValue;
            }
            // make sure exactly 1 matches before returning it
            var nextMatch = discriminable.indexOf(/*searchElement*/ true, match + 1);
            while (nextMatch !== -1) {
                if (!isTypeIdenticalTo(target.types[match], target.types[nextMatch])) {
                    return defaultValue;
                }
                nextMatch = discriminable.indexOf(/*searchElement*/ true, nextMatch + 1);
            }
            return target.types[match];
        }
        /**
         * A type is 'weak' if it is an object type with at least one optional property
         * and no required properties, call/construct signatures or index signatures
         */
        function isWeakType(type) {
            if (type.flags & 524288 /* TypeFlags.Object */) {
                var resolved = resolveStructuredTypeMembers(type);
                return resolved.callSignatures.length === 0 && resolved.constructSignatures.length === 0 && resolved.indexInfos.length === 0 &&
                    resolved.properties.length > 0 && ts.every(resolved.properties, function (p) { return !!(p.flags & 16777216 /* SymbolFlags.Optional */); });
            }
            if (type.flags & 2097152 /* TypeFlags.Intersection */) {
                return ts.every(type.types, isWeakType);
            }
            return false;
        }
        function hasCommonProperties(source, target, isComparingJsxAttributes) {
            for (var _i = 0, _a = getPropertiesOfType(source); _i < _a.length; _i++) {
                var prop = _a[_i];
                if (isKnownProperty(target, prop.escapedName, isComparingJsxAttributes)) {
                    return true;
                }
            }
            return false;
        }
        function getVariances(type) {
            // Arrays and tuples are known to be covariant, no need to spend time computing this.
            return type === globalArrayType || type === globalReadonlyArrayType || type.objectFlags & 8 /* ObjectFlags.Tuple */ ?
                arrayVariances :
                getVariancesWorker(type.symbol, type.typeParameters);
        }
        function getAliasVariances(symbol) {
            return getVariancesWorker(symbol, getSymbolLinks(symbol).typeParameters);
        }
        // Return an array containing the variance of each type parameter. The variance is effectively
        // a digest of the type comparisons that occur for each type argument when instantiations of the
        // generic type are structurally compared. We infer the variance information by comparing
        // instantiations of the generic type for type arguments with known relations. The function
        // returns the emptyArray singleton when invoked recursively for the given generic type.
        function getVariancesWorker(symbol, typeParameters) {
            if (typeParameters === void 0) { typeParameters = ts.emptyArray; }
            var links = getSymbolLinks(symbol);
            if (!links.variances) {
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("checkTypes" /* tracing.Phase.CheckTypes */, "getVariancesWorker", { arity: typeParameters.length, id: getTypeId(getDeclaredTypeOfSymbol(symbol)) });
                links.variances = ts.emptyArray;
                var variances = [];
                var _loop_23 = function (tp) {
                    var modifiers = getVarianceModifiers(tp);
                    var variance = modifiers & 65536 /* ModifierFlags.Out */ ?
                        modifiers & 32768 /* ModifierFlags.In */ ? 0 /* VarianceFlags.Invariant */ : 1 /* VarianceFlags.Covariant */ :
                        modifiers & 32768 /* ModifierFlags.In */ ? 2 /* VarianceFlags.Contravariant */ : undefined;
                    if (variance === undefined) {
                        var unmeasurable_1 = false;
                        var unreliable_1 = false;
                        var oldHandler = outofbandVarianceMarkerHandler;
                        outofbandVarianceMarkerHandler = function (onlyUnreliable) { return onlyUnreliable ? unreliable_1 = true : unmeasurable_1 = true; };
                        // We first compare instantiations where the type parameter is replaced with
                        // marker types that have a known subtype relationship. From this we can infer
                        // invariance, covariance, contravariance or bivariance.
                        var typeWithSuper = createMarkerType(symbol, tp, markerSuperType);
                        var typeWithSub = createMarkerType(symbol, tp, markerSubType);
                        variance = (isTypeAssignableTo(typeWithSub, typeWithSuper) ? 1 /* VarianceFlags.Covariant */ : 0) |
                            (isTypeAssignableTo(typeWithSuper, typeWithSub) ? 2 /* VarianceFlags.Contravariant */ : 0);
                        // If the instantiations appear to be related bivariantly it may be because the
                        // type parameter is independent (i.e. it isn't witnessed anywhere in the generic
                        // type). To determine this we compare instantiations where the type parameter is
                        // replaced with marker types that are known to be unrelated.
                        if (variance === 3 /* VarianceFlags.Bivariant */ && isTypeAssignableTo(createMarkerType(symbol, tp, markerOtherType), typeWithSuper)) {
                            variance = 4 /* VarianceFlags.Independent */;
                        }
                        outofbandVarianceMarkerHandler = oldHandler;
                        if (unmeasurable_1 || unreliable_1) {
                            if (unmeasurable_1) {
                                variance |= 8 /* VarianceFlags.Unmeasurable */;
                            }
                            if (unreliable_1) {
                                variance |= 16 /* VarianceFlags.Unreliable */;
                            }
                        }
                    }
                    variances.push(variance);
                };
                for (var _i = 0, typeParameters_2 = typeParameters; _i < typeParameters_2.length; _i++) {
                    var tp = typeParameters_2[_i];
                    _loop_23(tp);
                }
                links.variances = variances;
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop({ variances: variances.map(ts.Debug.formatVariance) });
            }
            return links.variances;
        }
        function createMarkerType(symbol, source, target) {
            var mapper = makeUnaryTypeMapper(source, target);
            var type = getDeclaredTypeOfSymbol(symbol);
            if (isErrorType(type)) {
                return type;
            }
            var result = symbol.flags & 524288 /* SymbolFlags.TypeAlias */ ?
                getTypeAliasInstantiation(symbol, instantiateTypes(getSymbolLinks(symbol).typeParameters, mapper)) :
                createTypeReference(type, instantiateTypes(type.typeParameters, mapper));
            markerTypes.add(getTypeId(result));
            return result;
        }
        function isMarkerType(type) {
            return markerTypes.has(getTypeId(type));
        }
        function getVarianceModifiers(tp) {
            var _a, _b;
            return (ts.some((_a = tp.symbol) === null || _a === void 0 ? void 0 : _a.declarations, function (d) { return ts.hasSyntacticModifier(d, 32768 /* ModifierFlags.In */); }) ? 32768 /* ModifierFlags.In */ : 0) |
                (ts.some((_b = tp.symbol) === null || _b === void 0 ? void 0 : _b.declarations, function (d) { return ts.hasSyntacticModifier(d, 65536 /* ModifierFlags.Out */); }) ? 65536 /* ModifierFlags.Out */ : 0);
        }
        // Return true if the given type reference has a 'void' type argument for a covariant type parameter.
        // See comment at call in recursiveTypeRelatedTo for when this case matters.
        function hasCovariantVoidArgument(typeArguments, variances) {
            for (var i = 0; i < variances.length; i++) {
                if ((variances[i] & 7 /* VarianceFlags.VarianceMask */) === 1 /* VarianceFlags.Covariant */ && typeArguments[i].flags & 16384 /* TypeFlags.Void */) {
                    return true;
                }
            }
            return false;
        }
        function isUnconstrainedTypeParameter(type) {
            return type.flags & 262144 /* TypeFlags.TypeParameter */ && !getConstraintOfTypeParameter(type);
        }
        function isNonDeferredTypeReference(type) {
            return !!(ts.getObjectFlags(type) & 4 /* ObjectFlags.Reference */) && !type.node;
        }
        function isTypeReferenceWithGenericArguments(type) {
            return isNonDeferredTypeReference(type) && ts.some(getTypeArguments(type), function (t) { return !!(t.flags & 262144 /* TypeFlags.TypeParameter */) || isTypeReferenceWithGenericArguments(t); });
        }
        function getGenericTypeReferenceRelationKey(source, target, postFix, ignoreConstraints) {
            var typeParameters = [];
            var constraintMarker = "";
            var sourceId = getTypeReferenceId(source, 0);
            var targetId = getTypeReferenceId(target, 0);
            return "".concat(constraintMarker).concat(sourceId, ",").concat(targetId).concat(postFix);
            // getTypeReferenceId(A<T, number, U>) returns "111=0-12=1"
            // where A.id=111 and number.id=12
            function getTypeReferenceId(type, depth) {
                if (depth === void 0) { depth = 0; }
                var result = "" + type.target.id;
                for (var _i = 0, _a = getTypeArguments(type); _i < _a.length; _i++) {
                    var t = _a[_i];
                    if (t.flags & 262144 /* TypeFlags.TypeParameter */) {
                        if (ignoreConstraints || isUnconstrainedTypeParameter(t)) {
                            var index = typeParameters.indexOf(t);
                            if (index < 0) {
                                index = typeParameters.length;
                                typeParameters.push(t);
                            }
                            result += "=" + index;
                            continue;
                        }
                        // We mark type references that reference constrained type parameters such that we know to obtain
                        // and look for a "broadest equivalent key" in the cache.
                        constraintMarker = "*";
                    }
                    else if (depth < 4 && isTypeReferenceWithGenericArguments(t)) {
                        result += "<" + getTypeReferenceId(t, depth + 1) + ">";
                        continue;
                    }
                    result += "-" + t.id;
                }
                return result;
            }
        }
        /**
         * To improve caching, the relation key for two generic types uses the target's id plus ids of the type parameters.
         * For other cases, the types ids are used.
         */
        function getRelationKey(source, target, intersectionState, relation, ignoreConstraints) {
            if (relation === identityRelation && source.id > target.id) {
                var temp = source;
                source = target;
                target = temp;
            }
            var postFix = intersectionState ? ":" + intersectionState : "";
            return isTypeReferenceWithGenericArguments(source) && isTypeReferenceWithGenericArguments(target) ?
                getGenericTypeReferenceRelationKey(source, target, postFix, ignoreConstraints) :
                "".concat(source.id, ",").concat(target.id).concat(postFix);
        }
        // Invoke the callback for each underlying property symbol of the given symbol and return the first
        // value that isn't undefined.
        function forEachProperty(prop, callback) {
            if (ts.getCheckFlags(prop) & 6 /* CheckFlags.Synthetic */) {
                for (var _i = 0, _a = prop.containingType.types; _i < _a.length; _i++) {
                    var t = _a[_i];
                    var p = getPropertyOfType(t, prop.escapedName);
                    var result = p && forEachProperty(p, callback);
                    if (result) {
                        return result;
                    }
                }
                return undefined;
            }
            return callback(prop);
        }
        // Return the declaring class type of a property or undefined if property not declared in class
        function getDeclaringClass(prop) {
            return prop.parent && prop.parent.flags & 32 /* SymbolFlags.Class */ ? getDeclaredTypeOfSymbol(getParentOfSymbol(prop)) : undefined;
        }
        // Return the inherited type of the given property or undefined if property doesn't exist in a base class.
        function getTypeOfPropertyInBaseClass(property) {
            var classType = getDeclaringClass(property);
            var baseClassType = classType && getBaseTypes(classType)[0];
            return baseClassType && getTypeOfPropertyOfType(baseClassType, property.escapedName);
        }
        // Return true if some underlying source property is declared in a class that derives
        // from the given base class.
        function isPropertyInClassDerivedFrom(prop, baseClass) {
            return forEachProperty(prop, function (sp) {
                var sourceClass = getDeclaringClass(sp);
                return sourceClass ? hasBaseType(sourceClass, baseClass) : false;
            });
        }
        // Return true if source property is a valid override of protected parts of target property.
        function isValidOverrideOf(sourceProp, targetProp) {
            return !forEachProperty(targetProp, function (tp) { return ts.getDeclarationModifierFlagsFromSymbol(tp) & 16 /* ModifierFlags.Protected */ ?
                !isPropertyInClassDerivedFrom(sourceProp, getDeclaringClass(tp)) : false; });
        }
        // Return true if the given class derives from each of the declaring classes of the protected
        // constituents of the given property.
        function isClassDerivedFromDeclaringClasses(checkClass, prop, writing) {
            return forEachProperty(prop, function (p) { return ts.getDeclarationModifierFlagsFromSymbol(p, writing) & 16 /* ModifierFlags.Protected */ ?
                !hasBaseType(checkClass, getDeclaringClass(p)) : false; }) ? undefined : checkClass;
        }
        // Return true if the given type is deeply nested. We consider this to be the case when structural type comparisons
        // for maxDepth or more occurrences or instantiations of the type have been recorded on the given stack. It is possible,
        // though highly unlikely, for this test to be true in a situation where a chain of instantiations is not infinitely
        // expanding. Effectively, we will generate a false positive when two types are structurally equal to at least maxDepth
        // levels, but unequal at some level beyond that.
        // In addition, this will also detect when an indexed access has been chained off of maxDepth more times (which is
        // essentially the dual of the structural comparison), and likewise mark the type as deeply nested, potentially adding
        // false positives for finite but deeply expanding indexed accesses (eg, for `Q[P1][P2][P3][P4][P5]`).
        // It also detects when a recursive type reference has expanded maxDepth or more times, e.g. if the true branch of
        // `type A<T> = null extends T ? [A<NonNullable<T>>] : [T]`
        // has expanded into `[A<NonNullable<NonNullable<NonNullable<NonNullable<NonNullable<T>>>>>>]`. In such cases we need
        // to terminate the expansion, and we do so here.
        function isDeeplyNestedType(type, stack, depth, maxDepth) {
            if (maxDepth === void 0) { maxDepth = 3; }
            if (depth >= maxDepth) {
                var identity_2 = getRecursionIdentity(type);
                var count = 0;
                var lastTypeId = 0;
                for (var i = 0; i < depth; i++) {
                    var t = stack[i];
                    if (getRecursionIdentity(t) === identity_2) {
                        // We only count occurrences with a higher type id than the previous occurrence, since higher
                        // type ids are an indicator of newer instantiations caused by recursion.
                        if (t.id >= lastTypeId) {
                            count++;
                            if (count >= maxDepth) {
                                return true;
                            }
                        }
                        lastTypeId = t.id;
                    }
                }
            }
            return false;
        }
        // The recursion identity of a type is an object identity that is shared among multiple instantiations of the type.
        // We track recursion identities in order to identify deeply nested and possibly infinite type instantiations with
        // the same origin. For example, when type parameters are in scope in an object type such as { x: T }, all
        // instantiations of that type have the same recursion identity. The default recursion identity is the object
        // identity of the type, meaning that every type is unique. Generally, types with constituents that could circularly
        // reference the type have a recursion identity that differs from the object identity.
        function getRecursionIdentity(type) {
            // Object and array literals are known not to contain recursive references and don't need a recursion identity.
            if (type.flags & 524288 /* TypeFlags.Object */ && !isObjectOrArrayLiteralType(type)) {
                if (ts.getObjectFlags(type) && 4 /* ObjectFlags.Reference */ && type.node) {
                    // Deferred type references are tracked through their associated AST node. This gives us finer
                    // granularity than using their associated target because each manifest type reference has a
                    // unique AST node.
                    return type.node;
                }
                if (type.symbol && !(ts.getObjectFlags(type) & 16 /* ObjectFlags.Anonymous */ && type.symbol.flags & 32 /* SymbolFlags.Class */)) {
                    // We track all object types that have an associated symbol (representing the origin of the type), but
                    // exclude the static side of classes from this check since it shares its symbol with the instance side.
                    return type.symbol;
                }
                if (isTupleType(type)) {
                    // Tuple types are tracked through their target type
                    return type.target;
                }
            }
            if (type.flags & 262144 /* TypeFlags.TypeParameter */) {
                return type.symbol;
            }
            if (type.flags & 8388608 /* TypeFlags.IndexedAccess */) {
                // Identity is the leftmost object type in a chain of indexed accesses, eg, in A[P][Q] it is A
                do {
                    type = type.objectType;
                } while (type.flags & 8388608 /* TypeFlags.IndexedAccess */);
                return type;
            }
            if (type.flags & 16777216 /* TypeFlags.Conditional */) {
                // The root object represents the origin of the conditional type
                return type.root;
            }
            return type;
        }
        function isPropertyIdenticalTo(sourceProp, targetProp) {
            return compareProperties(sourceProp, targetProp, compareTypesIdentical) !== 0 /* Ternary.False */;
        }
        function compareProperties(sourceProp, targetProp, compareTypes) {
            // Two members are considered identical when
            // - they are public properties with identical names, optionality, and types,
            // - they are private or protected properties originating in the same declaration and having identical types
            if (sourceProp === targetProp) {
                return -1 /* Ternary.True */;
            }
            var sourcePropAccessibility = ts.getDeclarationModifierFlagsFromSymbol(sourceProp) & 24 /* ModifierFlags.NonPublicAccessibilityModifier */;
            var targetPropAccessibility = ts.getDeclarationModifierFlagsFromSymbol(targetProp) & 24 /* ModifierFlags.NonPublicAccessibilityModifier */;
            if (sourcePropAccessibility !== targetPropAccessibility) {
                return 0 /* Ternary.False */;
            }
            if (sourcePropAccessibility) {
                if (getTargetSymbol(sourceProp) !== getTargetSymbol(targetProp)) {
                    return 0 /* Ternary.False */;
                }
            }
            else {
                if ((sourceProp.flags & 16777216 /* SymbolFlags.Optional */) !== (targetProp.flags & 16777216 /* SymbolFlags.Optional */)) {
                    return 0 /* Ternary.False */;
                }
            }
            if (isReadonlySymbol(sourceProp) !== isReadonlySymbol(targetProp)) {
                return 0 /* Ternary.False */;
            }
            return compareTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));
        }
        function isMatchingSignature(source, target, partialMatch) {
            var sourceParameterCount = getParameterCount(source);
            var targetParameterCount = getParameterCount(target);
            var sourceMinArgumentCount = getMinArgumentCount(source);
            var targetMinArgumentCount = getMinArgumentCount(target);
            var sourceHasRestParameter = hasEffectiveRestParameter(source);
            var targetHasRestParameter = hasEffectiveRestParameter(target);
            // A source signature matches a target signature if the two signatures have the same number of required,
            // optional, and rest parameters.
            if (sourceParameterCount === targetParameterCount &&
                sourceMinArgumentCount === targetMinArgumentCount &&
                sourceHasRestParameter === targetHasRestParameter) {
                return true;
            }
            // A source signature partially matches a target signature if the target signature has no fewer required
            // parameters
            if (partialMatch && sourceMinArgumentCount <= targetMinArgumentCount) {
                return true;
            }
            return false;
        }
        /**
         * See signatureRelatedTo, compareSignaturesIdentical
         */
        function compareSignaturesIdentical(source, target, partialMatch, ignoreThisTypes, ignoreReturnTypes, compareTypes) {
            // TODO (drosen): De-duplicate code between related functions.
            if (source === target) {
                return -1 /* Ternary.True */;
            }
            if (!(isMatchingSignature(source, target, partialMatch))) {
                return 0 /* Ternary.False */;
            }
            // Check that the two signatures have the same number of type parameters.
            if (ts.length(source.typeParameters) !== ts.length(target.typeParameters)) {
                return 0 /* Ternary.False */;
            }
            // Check that type parameter constraints and defaults match. If they do, instantiate the source
            // signature with the type parameters of the target signature and continue the comparison.
            if (target.typeParameters) {
                var mapper = createTypeMapper(source.typeParameters, target.typeParameters);
                for (var i = 0; i < target.typeParameters.length; i++) {
                    var s = source.typeParameters[i];
                    var t = target.typeParameters[i];
                    if (!(s === t || compareTypes(instantiateType(getConstraintFromTypeParameter(s), mapper) || unknownType, getConstraintFromTypeParameter(t) || unknownType) &&
                        compareTypes(instantiateType(getDefaultFromTypeParameter(s), mapper) || unknownType, getDefaultFromTypeParameter(t) || unknownType))) {
                        return 0 /* Ternary.False */;
                    }
                }
                source = instantiateSignature(source, mapper, /*eraseTypeParameters*/ true);
            }
            var result = -1 /* Ternary.True */;
            if (!ignoreThisTypes) {
                var sourceThisType = getThisTypeOfSignature(source);
                if (sourceThisType) {
                    var targetThisType = getThisTypeOfSignature(target);
                    if (targetThisType) {
                        var related = compareTypes(sourceThisType, targetThisType);
                        if (!related) {
                            return 0 /* Ternary.False */;
                        }
                        result &= related;
                    }
                }
            }
            var targetLen = getParameterCount(target);
            for (var i = 0; i < targetLen; i++) {
                var s = getTypeAtPosition(source, i);
                var t = getTypeAtPosition(target, i);
                var related = compareTypes(t, s);
                if (!related) {
                    return 0 /* Ternary.False */;
                }
                result &= related;
            }
            if (!ignoreReturnTypes) {
                var sourceTypePredicate = getTypePredicateOfSignature(source);
                var targetTypePredicate = getTypePredicateOfSignature(target);
                result &= sourceTypePredicate || targetTypePredicate ?
                    compareTypePredicatesIdentical(sourceTypePredicate, targetTypePredicate, compareTypes) :
                    compareTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
            }
            return result;
        }
        function compareTypePredicatesIdentical(source, target, compareTypes) {
            return !(source && target && typePredicateKindsMatch(source, target)) ? 0 /* Ternary.False */ :
                source.type === target.type ? -1 /* Ternary.True */ :
                    source.type && target.type ? compareTypes(source.type, target.type) :
                        0 /* Ternary.False */;
        }
        function literalTypesWithSameBaseType(types) {
            var commonBaseType;
            for (var _i = 0, types_13 = types; _i < types_13.length; _i++) {
                var t = types_13[_i];
                if (!(t.flags & 131072 /* TypeFlags.Never */)) {
                    var baseType = getBaseTypeOfLiteralType(t);
                    commonBaseType !== null && commonBaseType !== void 0 ? commonBaseType : (commonBaseType = baseType);
                    if (baseType === t || baseType !== commonBaseType) {
                        return false;
                    }
                }
            }
            return true;
        }
        function getCombinedTypeFlags(types) {
            return ts.reduceLeft(types, function (flags, t) { return flags | (t.flags & 1048576 /* TypeFlags.Union */ ? getCombinedTypeFlags(t.types) : t.flags); }, 0);
        }
        function getCommonSupertype(types) {
            if (types.length === 1) {
                return types[0];
            }
            // Remove nullable types from each of the candidates.
            var primaryTypes = strictNullChecks ? ts.sameMap(types, function (t) { return filterType(t, function (u) { return !(u.flags & 98304 /* TypeFlags.Nullable */); }); }) : types;
            // When the candidate types are all literal types with the same base type, return a union
            // of those literal types. Otherwise, return the leftmost type for which no type to the
            // right is a supertype.
            var superTypeOrUnion = literalTypesWithSameBaseType(primaryTypes) ?
                getUnionType(primaryTypes) :
                ts.reduceLeft(primaryTypes, function (s, t) { return isTypeSubtypeOf(s, t) ? t : s; });
            // Add any nullable types that occurred in the candidates back to the result.
            return primaryTypes === types ? superTypeOrUnion : getNullableType(superTypeOrUnion, getCombinedTypeFlags(types) & 98304 /* TypeFlags.Nullable */);
        }
        // Return the leftmost type for which no type to the right is a subtype.
        function getCommonSubtype(types) {
            return ts.reduceLeft(types, function (s, t) { return isTypeSubtypeOf(t, s) ? t : s; });
        }
        function isArrayType(type) {
            return !!(ts.getObjectFlags(type) & 4 /* ObjectFlags.Reference */) && (type.target === globalArrayType || type.target === globalReadonlyArrayType);
        }
        function isReadonlyArrayType(type) {
            return !!(ts.getObjectFlags(type) & 4 /* ObjectFlags.Reference */) && type.target === globalReadonlyArrayType;
        }
        function isArrayOrTupleType(type) {
            return isArrayType(type) || isTupleType(type);
        }
        function isMutableArrayOrTuple(type) {
            return isArrayType(type) && !isReadonlyArrayType(type) || isTupleType(type) && !type.target.readonly;
        }
        function getElementTypeOfArrayType(type) {
            return isArrayType(type) ? getTypeArguments(type)[0] : undefined;
        }
        function isArrayLikeType(type) {
            // A type is array-like if it is a reference to the global Array or global ReadonlyArray type,
            // or if it is not the undefined or null type and if it is assignable to ReadonlyArray<any>
            return isArrayType(type) || !(type.flags & 98304 /* TypeFlags.Nullable */) && isTypeAssignableTo(type, anyReadonlyArrayType);
        }
        function getSingleBaseForNonAugmentingSubtype(type) {
            if (!(ts.getObjectFlags(type) & 4 /* ObjectFlags.Reference */) || !(ts.getObjectFlags(type.target) & 3 /* ObjectFlags.ClassOrInterface */)) {
                return undefined;
            }
            if (ts.getObjectFlags(type) & 33554432 /* ObjectFlags.IdenticalBaseTypeCalculated */) {
                return ts.getObjectFlags(type) & 67108864 /* ObjectFlags.IdenticalBaseTypeExists */ ? type.cachedEquivalentBaseType : undefined;
            }
            type.objectFlags |= 33554432 /* ObjectFlags.IdenticalBaseTypeCalculated */;
            var target = type.target;
            if (ts.getObjectFlags(target) & 1 /* ObjectFlags.Class */) {
                var baseTypeNode = getBaseTypeNodeOfClass(target);
                // A base type expression may circularly reference the class itself (e.g. as an argument to function call), so we only
                // check for base types specified as simple qualified names.
                if (baseTypeNode && baseTypeNode.expression.kind !== 79 /* SyntaxKind.Identifier */ && baseTypeNode.expression.kind !== 208 /* SyntaxKind.PropertyAccessExpression */) {
                    return undefined;
                }
            }
            var bases = getBaseTypes(target);
            if (bases.length !== 1) {
                return undefined;
            }
            if (getMembersOfSymbol(type.symbol).size) {
                return undefined; // If the interface has any members, they may subtype members in the base, so we should do a full structural comparison
            }
            var instantiatedBase = !ts.length(target.typeParameters) ? bases[0] : instantiateType(bases[0], createTypeMapper(target.typeParameters, getTypeArguments(type).slice(0, target.typeParameters.length)));
            if (ts.length(getTypeArguments(type)) > ts.length(target.typeParameters)) {
                instantiatedBase = getTypeWithThisArgument(instantiatedBase, ts.last(getTypeArguments(type)));
            }
            type.objectFlags |= 67108864 /* ObjectFlags.IdenticalBaseTypeExists */;
            return type.cachedEquivalentBaseType = instantiatedBase;
        }
        function isEmptyLiteralType(type) {
            return strictNullChecks ? type === implicitNeverType : type === undefinedWideningType;
        }
        function isEmptyArrayLiteralType(type) {
            var elementType = getElementTypeOfArrayType(type);
            return !!elementType && isEmptyLiteralType(elementType);
        }
        function isTupleLikeType(type) {
            return isTupleType(type) || !!getPropertyOfType(type, "0");
        }
        function isArrayOrTupleLikeType(type) {
            return isArrayLikeType(type) || isTupleLikeType(type);
        }
        function getTupleElementType(type, index) {
            var propType = getTypeOfPropertyOfType(type, "" + index);
            if (propType) {
                return propType;
            }
            if (everyType(type, isTupleType)) {
                return mapType(type, function (t) { return getRestTypeOfTupleType(t) || undefinedType; });
            }
            return undefined;
        }
        function isNeitherUnitTypeNorNever(type) {
            return !(type.flags & (109440 /* TypeFlags.Unit */ | 131072 /* TypeFlags.Never */));
        }
        function isUnitType(type) {
            return !!(type.flags & 109440 /* TypeFlags.Unit */);
        }
        function isUnitLikeType(type) {
            // Intersections that reduce to 'never' (e.g. 'T & null' where 'T extends {}') are not unit types.
            var t = getBaseConstraintOrType(type);
            // Scan intersections such that tagged literal types are considered unit types.
            return t.flags & 2097152 /* TypeFlags.Intersection */ ? ts.some(t.types, isUnitType) : isUnitType(t);
        }
        function extractUnitType(type) {
            return type.flags & 2097152 /* TypeFlags.Intersection */ ? ts.find(type.types, isUnitType) || type : type;
        }
        function isLiteralType(type) {
            return type.flags & 16 /* TypeFlags.Boolean */ ? true :
                type.flags & 1048576 /* TypeFlags.Union */ ? type.flags & 1024 /* TypeFlags.EnumLiteral */ ? true : ts.every(type.types, isUnitType) :
                    isUnitType(type);
        }
        function getBaseTypeOfLiteralType(type) {
            return type.flags & 1024 /* TypeFlags.EnumLiteral */ ? getBaseTypeOfEnumLiteralType(type) :
                type.flags & (128 /* TypeFlags.StringLiteral */ | 134217728 /* TypeFlags.TemplateLiteral */ | 268435456 /* TypeFlags.StringMapping */) ? stringType :
                    type.flags & 256 /* TypeFlags.NumberLiteral */ ? numberType :
                        type.flags & 2048 /* TypeFlags.BigIntLiteral */ ? bigintType :
                            type.flags & 512 /* TypeFlags.BooleanLiteral */ ? booleanType :
                                type.flags & 1048576 /* TypeFlags.Union */ ? getBaseTypeOfLiteralTypeUnion(type) :
                                    type;
        }
        function getBaseTypeOfLiteralTypeUnion(type) {
            var _a;
            var key = "B".concat(getTypeId(type));
            return (_a = getCachedType(key)) !== null && _a !== void 0 ? _a : setCachedType(key, mapType(type, getBaseTypeOfLiteralType));
        }
        function getWidenedLiteralType(type) {
            return type.flags & 1024 /* TypeFlags.EnumLiteral */ && isFreshLiteralType(type) ? getBaseTypeOfEnumLiteralType(type) :
                type.flags & 128 /* TypeFlags.StringLiteral */ && isFreshLiteralType(type) ? stringType :
                    type.flags & 256 /* TypeFlags.NumberLiteral */ && isFreshLiteralType(type) ? numberType :
                        type.flags & 2048 /* TypeFlags.BigIntLiteral */ && isFreshLiteralType(type) ? bigintType :
                            type.flags & 512 /* TypeFlags.BooleanLiteral */ && isFreshLiteralType(type) ? booleanType :
                                type.flags & 1048576 /* TypeFlags.Union */ ? mapType(type, getWidenedLiteralType) :
                                    type;
        }
        function getWidenedUniqueESSymbolType(type) {
            return type.flags & 8192 /* TypeFlags.UniqueESSymbol */ ? esSymbolType :
                type.flags & 1048576 /* TypeFlags.Union */ ? mapType(type, getWidenedUniqueESSymbolType) :
                    type;
        }
        function getWidenedLiteralLikeTypeForContextualType(type, contextualType) {
            if (!isLiteralOfContextualType(type, contextualType)) {
                type = getWidenedUniqueESSymbolType(getWidenedLiteralType(type));
            }
            return getRegularTypeOfLiteralType(type);
        }
        function getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(type, contextualSignatureReturnType, isAsync) {
            if (type && isUnitType(type)) {
                var contextualType = !contextualSignatureReturnType ? undefined :
                    isAsync ? getPromisedTypeOfPromise(contextualSignatureReturnType) :
                        contextualSignatureReturnType;
                type = getWidenedLiteralLikeTypeForContextualType(type, contextualType);
            }
            return type;
        }
        function getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(type, contextualSignatureReturnType, kind, isAsyncGenerator) {
            if (type && isUnitType(type)) {
                var contextualType = !contextualSignatureReturnType ? undefined :
                    getIterationTypeOfGeneratorFunctionReturnType(kind, contextualSignatureReturnType, isAsyncGenerator);
                type = getWidenedLiteralLikeTypeForContextualType(type, contextualType);
            }
            return type;
        }
        /**
         * Check if a Type was written as a tuple type literal.
         * Prefer using isTupleLikeType() unless the use of `elementTypes`/`getTypeArguments` is required.
         */
        function isTupleType(type) {
            return !!(ts.getObjectFlags(type) & 4 /* ObjectFlags.Reference */ && type.target.objectFlags & 8 /* ObjectFlags.Tuple */);
        }
        function isGenericTupleType(type) {
            return isTupleType(type) && !!(type.target.combinedFlags & 8 /* ElementFlags.Variadic */);
        }
        function isSingleElementGenericTupleType(type) {
            return isGenericTupleType(type) && type.target.elementFlags.length === 1;
        }
        function getRestTypeOfTupleType(type) {
            return getElementTypeOfSliceOfTupleType(type, type.target.fixedLength);
        }
        function getRestArrayTypeOfTupleType(type) {
            var restType = getRestTypeOfTupleType(type);
            return restType && createArrayType(restType);
        }
        function getElementTypeOfSliceOfTupleType(type, index, endSkipCount, writing) {
            if (endSkipCount === void 0) { endSkipCount = 0; }
            if (writing === void 0) { writing = false; }
            var length = getTypeReferenceArity(type) - endSkipCount;
            if (index < length) {
                var typeArguments = getTypeArguments(type);
                var elementTypes = [];
                for (var i = index; i < length; i++) {
                    var t = typeArguments[i];
                    elementTypes.push(type.target.elementFlags[i] & 8 /* ElementFlags.Variadic */ ? getIndexedAccessType(t, numberType) : t);
                }
                return writing ? getIntersectionType(elementTypes) : getUnionType(elementTypes);
            }
            return undefined;
        }
        function isTupleTypeStructureMatching(t1, t2) {
            return getTypeReferenceArity(t1) === getTypeReferenceArity(t2) &&
                ts.every(t1.target.elementFlags, function (f, i) { return (f & 12 /* ElementFlags.Variable */) === (t2.target.elementFlags[i] & 12 /* ElementFlags.Variable */); });
        }
        function isZeroBigInt(_a) {
            var value = _a.value;
            return value.base10Value === "0";
        }
        function removeDefinitelyFalsyTypes(type) {
            return filterType(type, function (t) { return !!(getTypeFacts(t) & 4194304 /* TypeFacts.Truthy */); });
        }
        function extractDefinitelyFalsyTypes(type) {
            return mapType(type, getDefinitelyFalsyPartOfType);
        }
        function getDefinitelyFalsyPartOfType(type) {
            return type.flags & 4 /* TypeFlags.String */ ? emptyStringType :
                type.flags & 8 /* TypeFlags.Number */ ? zeroType :
                    type.flags & 64 /* TypeFlags.BigInt */ ? zeroBigIntType :
                        type === regularFalseType ||
                            type === falseType ||
                            type.flags & (16384 /* TypeFlags.Void */ | 32768 /* TypeFlags.Undefined */ | 65536 /* TypeFlags.Null */ | 3 /* TypeFlags.AnyOrUnknown */) ||
                            type.flags & 128 /* TypeFlags.StringLiteral */ && type.value === "" ||
                            type.flags & 256 /* TypeFlags.NumberLiteral */ && type.value === 0 ||
                            type.flags & 2048 /* TypeFlags.BigIntLiteral */ && isZeroBigInt(type) ? type :
                            neverType;
        }
        /**
         * Add undefined or null or both to a type if they are missing.
         * @param type - type to add undefined and/or null to if not present
         * @param flags - Either TypeFlags.Undefined or TypeFlags.Null, or both
         */
        function getNullableType(type, flags) {
            var missing = (flags & ~type.flags) & (32768 /* TypeFlags.Undefined */ | 65536 /* TypeFlags.Null */);
            return missing === 0 ? type :
                missing === 32768 /* TypeFlags.Undefined */ ? getUnionType([type, undefinedType]) :
                    missing === 65536 /* TypeFlags.Null */ ? getUnionType([type, nullType]) :
                        getUnionType([type, undefinedType, nullType]);
        }
        function getOptionalType(type, isProperty) {
            if (isProperty === void 0) { isProperty = false; }
            ts.Debug.assert(strictNullChecks);
            var missingOrUndefined = isProperty ? missingType : undefinedType;
            return type.flags & 32768 /* TypeFlags.Undefined */ || type.flags & 1048576 /* TypeFlags.Union */ && type.types[0] === missingOrUndefined ? type : getUnionType([type, missingOrUndefined]);
        }
        function getGlobalNonNullableTypeInstantiation(type) {
            if (!deferredGlobalNonNullableTypeAlias) {
                deferredGlobalNonNullableTypeAlias = getGlobalSymbol("NonNullable", 524288 /* SymbolFlags.TypeAlias */, /*diagnostic*/ undefined) || unknownSymbol;
            }
            return deferredGlobalNonNullableTypeAlias !== unknownSymbol ?
                getTypeAliasInstantiation(deferredGlobalNonNullableTypeAlias, [type]) :
                getIntersectionType([type, emptyObjectType]);
        }
        function getNonNullableType(type) {
            return strictNullChecks ? getAdjustedTypeWithFacts(type, 2097152 /* TypeFacts.NEUndefinedOrNull */) : type;
        }
        function addOptionalTypeMarker(type) {
            return strictNullChecks ? getUnionType([type, optionalType]) : type;
        }
        function removeOptionalTypeMarker(type) {
            return strictNullChecks ? removeType(type, optionalType) : type;
        }
        function propagateOptionalTypeMarker(type, node, wasOptional) {
            return wasOptional ? ts.isOutermostOptionalChain(node) ? getOptionalType(type) : addOptionalTypeMarker(type) : type;
        }
        function getOptionalExpressionType(exprType, expression) {
            return ts.isExpressionOfOptionalChainRoot(expression) ? getNonNullableType(exprType) :
                ts.isOptionalChain(expression) ? removeOptionalTypeMarker(exprType) :
                    exprType;
        }
        function removeMissingType(type, isOptional) {
            return exactOptionalPropertyTypes && isOptional ? removeType(type, missingType) : type;
        }
        function containsMissingType(type) {
            return exactOptionalPropertyTypes && (type === missingType || type.flags & 1048576 /* TypeFlags.Union */ && containsType(type.types, missingType));
        }
        function removeMissingOrUndefinedType(type) {
            return exactOptionalPropertyTypes ? removeType(type, missingType) : getTypeWithFacts(type, 524288 /* TypeFacts.NEUndefined */);
        }
        /**
         * Is source potentially coercible to target type under `==`.
         * Assumes that `source` is a constituent of a union, hence
         * the boolean literal flag on the LHS, but not on the RHS.
         *
         * This does not fully replicate the semantics of `==`. The
         * intention is to catch cases that are clearly not right.
         *
         * Comparing (string | number) to number should not remove the
         * string element.
         *
         * Comparing (string | number) to 1 will remove the string
         * element, though this is not sound. This is a pragmatic
         * choice.
         *
         * @see narrowTypeByEquality
         *
         * @param source
         * @param target
         */
        function isCoercibleUnderDoubleEquals(source, target) {
            return ((source.flags & (8 /* TypeFlags.Number */ | 4 /* TypeFlags.String */ | 512 /* TypeFlags.BooleanLiteral */)) !== 0)
                && ((target.flags & (8 /* TypeFlags.Number */ | 4 /* TypeFlags.String */ | 16 /* TypeFlags.Boolean */)) !== 0);
        }
        /**
         * Return true if type was inferred from an object literal, written as an object type literal, or is the shape of a module
         * with no call or construct signatures.
         */
        function isObjectTypeWithInferableIndex(type) {
            var objectFlags = ts.getObjectFlags(type);
            return type.flags & 2097152 /* TypeFlags.Intersection */
                ? ts.every(type.types, isObjectTypeWithInferableIndex)
                : !!(type.symbol
                    && (type.symbol.flags & (4096 /* SymbolFlags.ObjectLiteral */ | 2048 /* SymbolFlags.TypeLiteral */ | 384 /* SymbolFlags.Enum */ | 512 /* SymbolFlags.ValueModule */)) !== 0
                    && !(type.symbol.flags & 32 /* SymbolFlags.Class */)
                    && !typeHasCallOrConstructSignatures(type)) || !!(objectFlags & 4194304 /* ObjectFlags.ObjectRestType */) || !!(objectFlags & 1024 /* ObjectFlags.ReverseMapped */ && isObjectTypeWithInferableIndex(type.source));
        }
        function createSymbolWithType(source, type) {
            var symbol = createSymbol(source.flags, source.escapedName, ts.getCheckFlags(source) & 8 /* CheckFlags.Readonly */);
            symbol.declarations = source.declarations;
            symbol.parent = source.parent;
            symbol.type = type;
            symbol.target = source;
            if (source.valueDeclaration) {
                symbol.valueDeclaration = source.valueDeclaration;
            }
            var nameType = getSymbolLinks(source).nameType;
            if (nameType) {
                symbol.nameType = nameType;
            }
            return symbol;
        }
        function transformTypeOfMembers(type, f) {
            var members = ts.createSymbolTable();
            for (var _i = 0, _a = getPropertiesOfObjectType(type); _i < _a.length; _i++) {
                var property = _a[_i];
                var original = getTypeOfSymbol(property);
                var updated = f(original);
                members.set(property.escapedName, updated === original ? property : createSymbolWithType(property, updated));
            }
            return members;
        }
        /**
         * If the the provided object literal is subject to the excess properties check,
         * create a new that is exempt. Recursively mark object literal members as exempt.
         * Leave signatures alone since they are not subject to the check.
         */
        function getRegularTypeOfObjectLiteral(type) {
            if (!(isObjectLiteralType(type) && ts.getObjectFlags(type) & 8192 /* ObjectFlags.FreshLiteral */)) {
                return type;
            }
            var regularType = type.regularType;
            if (regularType) {
                return regularType;
            }
            var resolved = type;
            var members = transformTypeOfMembers(type, getRegularTypeOfObjectLiteral);
            var regularNew = createAnonymousType(resolved.symbol, members, resolved.callSignatures, resolved.constructSignatures, resolved.indexInfos);
            regularNew.flags = resolved.flags;
            regularNew.objectFlags |= resolved.objectFlags & ~8192 /* ObjectFlags.FreshLiteral */;
            type.regularType = regularNew;
            return regularNew;
        }
        function createWideningContext(parent, propertyName, siblings) {
            return { parent: parent, propertyName: propertyName, siblings: siblings, resolvedProperties: undefined };
        }
        function getSiblingsOfContext(context) {
            if (!context.siblings) {
                var siblings_1 = [];
                for (var _i = 0, _a = getSiblingsOfContext(context.parent); _i < _a.length; _i++) {
                    var type = _a[_i];
                    if (isObjectLiteralType(type)) {
                        var prop = getPropertyOfObjectType(type, context.propertyName);
                        if (prop) {
                            forEachType(getTypeOfSymbol(prop), function (t) {
                                siblings_1.push(t);
                            });
                        }
                    }
                }
                context.siblings = siblings_1;
            }
            return context.siblings;
        }
        function getPropertiesOfContext(context) {
            if (!context.resolvedProperties) {
                var names = new ts.Map();
                for (var _i = 0, _a = getSiblingsOfContext(context); _i < _a.length; _i++) {
                    var t = _a[_i];
                    if (isObjectLiteralType(t) && !(ts.getObjectFlags(t) & 2097152 /* ObjectFlags.ContainsSpread */)) {
                        for (var _b = 0, _c = getPropertiesOfType(t); _b < _c.length; _b++) {
                            var prop = _c[_b];
                            names.set(prop.escapedName, prop);
                        }
                    }
                }
                context.resolvedProperties = ts.arrayFrom(names.values());
            }
            return context.resolvedProperties;
        }
        function getWidenedProperty(prop, context) {
            if (!(prop.flags & 4 /* SymbolFlags.Property */)) {
                // Since get accessors already widen their return value there is no need to
                // widen accessor based properties here.
                return prop;
            }
            var original = getTypeOfSymbol(prop);
            var propContext = context && createWideningContext(context, prop.escapedName, /*siblings*/ undefined);
            var widened = getWidenedTypeWithContext(original, propContext);
            return widened === original ? prop : createSymbolWithType(prop, widened);
        }
        function getUndefinedProperty(prop) {
            var cached = undefinedProperties.get(prop.escapedName);
            if (cached) {
                return cached;
            }
            var result = createSymbolWithType(prop, missingType);
            result.flags |= 16777216 /* SymbolFlags.Optional */;
            undefinedProperties.set(prop.escapedName, result);
            return result;
        }
        function getWidenedTypeOfObjectLiteral(type, context) {
            var members = ts.createSymbolTable();
            for (var _i = 0, _a = getPropertiesOfObjectType(type); _i < _a.length; _i++) {
                var prop = _a[_i];
                members.set(prop.escapedName, getWidenedProperty(prop, context));
            }
            if (context) {
                for (var _b = 0, _c = getPropertiesOfContext(context); _b < _c.length; _b++) {
                    var prop = _c[_b];
                    if (!members.has(prop.escapedName)) {
                        members.set(prop.escapedName, getUndefinedProperty(prop));
                    }
                }
            }
            var result = createAnonymousType(type.symbol, members, ts.emptyArray, ts.emptyArray, ts.sameMap(getIndexInfosOfType(type), function (info) { return createIndexInfo(info.keyType, getWidenedType(info.type), info.isReadonly); }));
            result.objectFlags |= (ts.getObjectFlags(type) & (4096 /* ObjectFlags.JSLiteral */ | 262144 /* ObjectFlags.NonInferrableType */)); // Retain js literal flag through widening
            return result;
        }
        function getWidenedType(type) {
            return getWidenedTypeWithContext(type, /*context*/ undefined);
        }
        function getWidenedTypeWithContext(type, context) {
            if (ts.getObjectFlags(type) & 196608 /* ObjectFlags.RequiresWidening */) {
                if (context === undefined && type.widened) {
                    return type.widened;
                }
                var result = void 0;
                if (type.flags & (1 /* TypeFlags.Any */ | 98304 /* TypeFlags.Nullable */)) {
                    result = anyType;
                }
                else if (isObjectLiteralType(type)) {
                    result = getWidenedTypeOfObjectLiteral(type, context);
                }
                else if (type.flags & 1048576 /* TypeFlags.Union */) {
                    var unionContext_1 = context || createWideningContext(/*parent*/ undefined, /*propertyName*/ undefined, type.types);
                    var widenedTypes = ts.sameMap(type.types, function (t) { return t.flags & 98304 /* TypeFlags.Nullable */ ? t : getWidenedTypeWithContext(t, unionContext_1); });
                    // Widening an empty object literal transitions from a highly restrictive type to
                    // a highly inclusive one. For that reason we perform subtype reduction here if the
                    // union includes empty object types (e.g. reducing {} | string to just {}).
                    result = getUnionType(widenedTypes, ts.some(widenedTypes, isEmptyObjectType) ? 2 /* UnionReduction.Subtype */ : 1 /* UnionReduction.Literal */);
                }
                else if (type.flags & 2097152 /* TypeFlags.Intersection */) {
                    result = getIntersectionType(ts.sameMap(type.types, getWidenedType));
                }
                else if (isArrayOrTupleType(type)) {
                    result = createTypeReference(type.target, ts.sameMap(getTypeArguments(type), getWidenedType));
                }
                if (result && context === undefined) {
                    type.widened = result;
                }
                return result || type;
            }
            return type;
        }
        /**
         * Reports implicit any errors that occur as a result of widening 'null' and 'undefined'
         * to 'any'. A call to reportWideningErrorsInType is normally accompanied by a call to
         * getWidenedType. But in some cases getWidenedType is called without reporting errors
         * (type argument inference is an example).
         *
         * The return value indicates whether an error was in fact reported. The particular circumstances
         * are on a best effort basis. Currently, if the null or undefined that causes widening is inside
         * an object literal property (arbitrarily deeply), this function reports an error. If no error is
         * reported, reportImplicitAnyError is a suitable fallback to report a general error.
         */
        function reportWideningErrorsInType(type) {
            var errorReported = false;
            if (ts.getObjectFlags(type) & 65536 /* ObjectFlags.ContainsWideningType */) {
                if (type.flags & 1048576 /* TypeFlags.Union */) {
                    if (ts.some(type.types, isEmptyObjectType)) {
                        errorReported = true;
                    }
                    else {
                        for (var _i = 0, _a = type.types; _i < _a.length; _i++) {
                            var t = _a[_i];
                            if (reportWideningErrorsInType(t)) {
                                errorReported = true;
                            }
                        }
                    }
                }
                if (isArrayOrTupleType(type)) {
                    for (var _b = 0, _c = getTypeArguments(type); _b < _c.length; _b++) {
                        var t = _c[_b];
                        if (reportWideningErrorsInType(t)) {
                            errorReported = true;
                        }
                    }
                }
                if (isObjectLiteralType(type)) {
                    for (var _d = 0, _e = getPropertiesOfObjectType(type); _d < _e.length; _d++) {
                        var p = _e[_d];
                        var t = getTypeOfSymbol(p);
                        if (ts.getObjectFlags(t) & 65536 /* ObjectFlags.ContainsWideningType */) {
                            if (!reportWideningErrorsInType(t)) {
                                error(p.valueDeclaration, ts.Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type, symbolToString(p), typeToString(getWidenedType(t)));
                            }
                            errorReported = true;
                        }
                    }
                }
            }
            return errorReported;
        }
        function reportImplicitAny(declaration, type, wideningKind) {
            var typeAsString = typeToString(getWidenedType(type));
            if (ts.isInJSFile(declaration) && !ts.isCheckJsEnabledForFile(ts.getSourceFileOfNode(declaration), compilerOptions)) {
                // Only report implicit any errors/suggestions in TS and ts-check JS files
                return;
            }
            var diagnostic;
            switch (declaration.kind) {
                case 223 /* SyntaxKind.BinaryExpression */:
                case 169 /* SyntaxKind.PropertyDeclaration */:
                case 168 /* SyntaxKind.PropertySignature */:
                    diagnostic = noImplicitAny ? ts.Diagnostics.Member_0_implicitly_has_an_1_type : ts.Diagnostics.Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
                    break;
                case 166 /* SyntaxKind.Parameter */:
                    var param = declaration;
                    if (ts.isIdentifier(param.name) &&
                        (ts.isCallSignatureDeclaration(param.parent) || ts.isMethodSignature(param.parent) || ts.isFunctionTypeNode(param.parent)) &&
                        param.parent.parameters.indexOf(param) > -1 &&
                        (resolveName(param, param.name.escapedText, 788968 /* SymbolFlags.Type */, undefined, param.name.escapedText, /*isUse*/ true) ||
                            param.name.originalKeywordKind && ts.isTypeNodeKind(param.name.originalKeywordKind))) {
                        var newName = "arg" + param.parent.parameters.indexOf(param);
                        var typeName = ts.declarationNameToString(param.name) + (param.dotDotDotToken ? "[]" : "");
                        errorOrSuggestion(noImplicitAny, declaration, ts.Diagnostics.Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1, newName, typeName);
                        return;
                    }
                    diagnostic = declaration.dotDotDotToken ?
                        noImplicitAny ? ts.Diagnostics.Rest_parameter_0_implicitly_has_an_any_type : ts.Diagnostics.Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage :
                        noImplicitAny ? ts.Diagnostics.Parameter_0_implicitly_has_an_1_type : ts.Diagnostics.Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
                    break;
                case 205 /* SyntaxKind.BindingElement */:
                    diagnostic = ts.Diagnostics.Binding_element_0_implicitly_has_an_1_type;
                    if (!noImplicitAny) {
                        // Don't issue a suggestion for binding elements since the codefix doesn't yet support them.
                        return;
                    }
                    break;
                case 320 /* SyntaxKind.JSDocFunctionType */:
                    error(declaration, ts.Diagnostics.Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);
                    return;
                case 259 /* SyntaxKind.FunctionDeclaration */:
                case 171 /* SyntaxKind.MethodDeclaration */:
                case 170 /* SyntaxKind.MethodSignature */:
                case 174 /* SyntaxKind.GetAccessor */:
                case 175 /* SyntaxKind.SetAccessor */:
                case 215 /* SyntaxKind.FunctionExpression */:
                case 216 /* SyntaxKind.ArrowFunction */:
                    if (noImplicitAny && !declaration.name) {
                        if (wideningKind === 3 /* WideningKind.GeneratorYield */) {
                            error(declaration, ts.Diagnostics.Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation, typeAsString);
                        }
                        else {
                            error(declaration, ts.Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);
                        }
                        return;
                    }
                    diagnostic = !noImplicitAny ? ts.Diagnostics._0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage :
                        wideningKind === 3 /* WideningKind.GeneratorYield */ ? ts.Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type :
                            ts.Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type;
                    break;
                case 197 /* SyntaxKind.MappedType */:
                    if (noImplicitAny) {
                        error(declaration, ts.Diagnostics.Mapped_object_type_implicitly_has_an_any_template_type);
                    }
                    return;
                default:
                    diagnostic = noImplicitAny ? ts.Diagnostics.Variable_0_implicitly_has_an_1_type : ts.Diagnostics.Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
            }
            errorOrSuggestion(noImplicitAny, declaration, diagnostic, ts.declarationNameToString(ts.getNameOfDeclaration(declaration)), typeAsString);
        }
        function reportErrorsFromWidening(declaration, type, wideningKind) {
            addLazyDiagnostic(function () {
                if (noImplicitAny && ts.getObjectFlags(type) & 65536 /* ObjectFlags.ContainsWideningType */ && (!wideningKind || !getContextualSignatureForFunctionLikeDeclaration(declaration))) {
                    // Report implicit any error within type if possible, otherwise report error on declaration
                    if (!reportWideningErrorsInType(type)) {
                        reportImplicitAny(declaration, type, wideningKind);
                    }
                }
            });
        }
        function applyToParameterTypes(source, target, callback) {
            var sourceCount = getParameterCount(source);
            var targetCount = getParameterCount(target);
            var sourceRestType = getEffectiveRestType(source);
            var targetRestType = getEffectiveRestType(target);
            var targetNonRestCount = targetRestType ? targetCount - 1 : targetCount;
            var paramCount = sourceRestType ? targetNonRestCount : Math.min(sourceCount, targetNonRestCount);
            var sourceThisType = getThisTypeOfSignature(source);
            if (sourceThisType) {
                var targetThisType = getThisTypeOfSignature(target);
                if (targetThisType) {
                    callback(sourceThisType, targetThisType);
                }
            }
            for (var i = 0; i < paramCount; i++) {
                callback(getTypeAtPosition(source, i), getTypeAtPosition(target, i));
            }
            if (targetRestType) {
                callback(getRestTypeAtPosition(source, paramCount), targetRestType);
            }
        }
        function applyToReturnTypes(source, target, callback) {
            var sourceTypePredicate = getTypePredicateOfSignature(source);
            var targetTypePredicate = getTypePredicateOfSignature(target);
            if (sourceTypePredicate && targetTypePredicate && typePredicateKindsMatch(sourceTypePredicate, targetTypePredicate) && sourceTypePredicate.type && targetTypePredicate.type) {
                callback(sourceTypePredicate.type, targetTypePredicate.type);
            }
            else {
                callback(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
            }
        }
        function createInferenceContext(typeParameters, signature, flags, compareTypes) {
            return createInferenceContextWorker(typeParameters.map(createInferenceInfo), signature, flags, compareTypes || compareTypesAssignable);
        }
        function cloneInferenceContext(context, extraFlags) {
            if (extraFlags === void 0) { extraFlags = 0; }
            return context && createInferenceContextWorker(ts.map(context.inferences, cloneInferenceInfo), context.signature, context.flags | extraFlags, context.compareTypes);
        }
        function createInferenceContextWorker(inferences, signature, flags, compareTypes) {
            var context = {
                inferences: inferences,
                signature: signature,
                flags: flags,
                compareTypes: compareTypes,
                mapper: reportUnmeasurableMapper,
                nonFixingMapper: reportUnmeasurableMapper,
            };
            context.mapper = makeFixingMapperForContext(context);
            context.nonFixingMapper = makeNonFixingMapperForContext(context);
            return context;
        }
        function makeFixingMapperForContext(context) {
            return makeDeferredTypeMapper(ts.map(context.inferences, function (i) { return i.typeParameter; }), ts.map(context.inferences, function (inference, i) { return function () {
                if (!inference.isFixed) {
                    // Before we commit to a particular inference (and thus lock out any further inferences),
                    // we infer from any intra-expression inference sites we have collected.
                    inferFromIntraExpressionSites(context);
                    clearCachedInferences(context.inferences);
                    inference.isFixed = true;
                }
                return getInferredType(context, i);
            }; }));
        }
        function makeNonFixingMapperForContext(context) {
            return makeDeferredTypeMapper(ts.map(context.inferences, function (i) { return i.typeParameter; }), ts.map(context.inferences, function (_, i) { return function () {
                return getInferredType(context, i);
            }; }));
        }
        function clearCachedInferences(inferences) {
            for (var _i = 0, inferences_1 = inferences; _i < inferences_1.length; _i++) {
                var inference = inferences_1[_i];
                if (!inference.isFixed) {
                    inference.inferredType = undefined;
                }
            }
        }
        function addIntraExpressionInferenceSite(context, node, type) {
            var _a;
            ((_a = context.intraExpressionInferenceSites) !== null && _a !== void 0 ? _a : (context.intraExpressionInferenceSites = [])).push({ node: node, type: type });
        }
        // We collect intra-expression inference sites within object and array literals to handle cases where
        // inferred types flow between context sensitive element expressions. For example:
        //
        //   declare function foo<T>(arg: [(n: number) => T, (x: T) => void]): void;
        //   foo([_a => 0, n => n.toFixed()]);
        //
        // Above, both arrow functions in the tuple argument are context sensitive, thus both are omitted from the
        // pass that collects inferences from the non-context sensitive parts of the arguments. In the subsequent
        // pass where nothing is omitted, we need to commit to an inference for T in order to contextually type the
        // parameter in the second arrow function, but we want to first infer from the return type of the first
        // arrow function. This happens automatically when the arrow functions are discrete arguments (because we
        // infer from each argument before processing the next), but when the arrow functions are elements of an
        // object or array literal, we need to perform intra-expression inferences early.
        function inferFromIntraExpressionSites(context) {
            if (context.intraExpressionInferenceSites) {
                for (var _i = 0, _a = context.intraExpressionInferenceSites; _i < _a.length; _i++) {
                    var _b = _a[_i], node = _b.node, type = _b.type;
                    var contextualType = node.kind === 171 /* SyntaxKind.MethodDeclaration */ ?
                        getContextualTypeForObjectLiteralMethod(node, 2 /* ContextFlags.NoConstraints */) :
                        getContextualType(node, 2 /* ContextFlags.NoConstraints */);
                    if (contextualType) {
                        inferTypes(context.inferences, type, contextualType);
                    }
                }
                context.intraExpressionInferenceSites = undefined;
            }
        }
        function createInferenceInfo(typeParameter) {
            return {
                typeParameter: typeParameter,
                candidates: undefined,
                contraCandidates: undefined,
                inferredType: undefined,
                priority: undefined,
                topLevel: true,
                isFixed: false,
                impliedArity: undefined
            };
        }
        function cloneInferenceInfo(inference) {
            return {
                typeParameter: inference.typeParameter,
                candidates: inference.candidates && inference.candidates.slice(),
                contraCa