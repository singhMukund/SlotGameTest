tContainer;
        var delayedTypeAliases;
        var seenThisKeyword;
        // state used by control flow analysis
        var currentFlow;
        var currentBreakTarget;
        var currentContinueTarget;
        var currentReturnTarget;
        var currentTrueTarget;
        var currentFalseTarget;
        var currentExceptionTarget;
        var preSwitchCaseFlow;
        var activeLabelList;
        var hasExplicitReturn;
        // state used for emit helpers
        var emitFlags;
        // If this file is an external module, then it is automatically in strict-mode according to
        // ES6.  If it is not an external module, then we'll determine if it is in strict mode or
        // not depending on if we see "use strict" in certain places or if we hit a class/namespace
        // or if compiler options contain alwaysStrict.
        var inStrictMode;
        // If we are binding an assignment pattern, we will bind certain expressions differently.
        var inAssignmentPattern = false;
        var symbolCount = 0;
        var Symbol;
        var classifiableNames;
        var unreachableFlow = { flags: 1 /* FlowFlags.Unreachable */ };
        var reportedUnreachableFlow = { flags: 1 /* FlowFlags.Unreachable */ };
        var bindBinaryExpressionFlow = createBindBinaryExpressionFlow();
        /**
         * Inside the binder, we may create a diagnostic for an as-yet unbound node (with potentially no parent pointers, implying no accessible source file)
         * If so, the node _must_ be in the current file (as that's the only way anything could have traversed to it to yield it as the error node)
         * This version of `createDiagnosticForNode` uses the binder's context to account for this, and always yields correct diagnostics even in these situations.
         */
        function createDiagnosticForNode(node, message, arg0, arg1, arg2) {
            return ts.createDiagnosticForNodeInSourceFile(ts.getSourceFileOfNode(node) || file, node, message, arg0, arg1, arg2);
        }
        function bindSourceFile(f, opts) {
            file = f;
            options = opts;
            languageVersion = ts.getEmitScriptTarget(options);
            inStrictMode = bindInStrictMode(file, opts);
            classifiableNames = new ts.Set();
            symbolCount = 0;
            Symbol = ts.objectAllocator.getSymbolConstructor();
            // Attach debugging information if necessary
            ts.Debug.attachFlowNodeDebugInfo(unreachableFlow);
            ts.Debug.attachFlowNodeDebugInfo(reportedUnreachableFlow);
            if (!file.locals) {
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("bind" /* tracing.Phase.Bind */, "bindSourceFile", { path: file.path }, /*separateBeginAndEnd*/ true);
                bind(file);
                ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
                file.symbolCount = symbolCount;
                file.classifiableNames = classifiableNames;
                delayedBindJSDocTypedefTag();
            }
            file = undefined;
            options = undefined;
            languageVersion = undefined;
            parent = undefined;
            container = undefined;
            thisParentContainer = undefined;
            blockScopeContainer = undefined;
            lastContainer = undefined;
            delayedTypeAliases = undefined;
            seenThisKeyword = false;
            currentFlow = undefined;
            currentBreakTarget = undefined;
            currentContinueTarget = undefined;
            currentReturnTarget = undefined;
            currentTrueTarget = undefined;
            currentFalseTarget = undefined;
            currentExceptionTarget = undefined;
            activeLabelList = undefined;
            hasExplicitReturn = false;
            inAssignmentPattern = false;
            emitFlags = 0 /* NodeFlags.None */;
        }
        return bindSourceFile;
        function bindInStrictMode(file, opts) {
            if (ts.getStrictOptionValue(opts, "alwaysStrict") && !file.isDeclarationFile) {
                // bind in strict mode source files with alwaysStrict option
                return true;
            }
            else {
                return !!file.externalModuleIndicator;
            }
        }
        function createSymbol(flags, name) {
            symbolCount++;
            return new Symbol(flags, name);
        }
        function addDeclarationToSymbol(symbol, node, symbolFlags) {
            symbol.flags |= symbolFlags;
            node.symbol = symbol;
            symbol.declarations = ts.appendIfUnique(symbol.declarations, node);
            if (symbolFlags & (32 /* SymbolFlags.Class */ | 384 /* SymbolFlags.Enum */ | 1536 /* SymbolFlags.Module */ | 3 /* SymbolFlags.Variable */) && !symbol.exports) {
                symbol.exports = ts.createSymbolTable();
            }
            if (symbolFlags & (32 /* SymbolFlags.Class */ | 64 /* SymbolFlags.Interface */ | 2048 /* SymbolFlags.TypeLiteral */ | 4096 /* SymbolFlags.ObjectLiteral */) && !symbol.members) {
                symbol.members = ts.createSymbolTable();
            }
            // On merge of const enum module with class or function, reset const enum only flag (namespaces will already recalculate)
            if (symbol.constEnumOnlyModule && (symbol.flags & (16 /* SymbolFlags.Function */ | 32 /* SymbolFlags.Class */ | 256 /* SymbolFlags.RegularEnum */))) {
                symbol.constEnumOnlyModule = false;
            }
            if (symbolFlags & 111551 /* SymbolFlags.Value */) {
                ts.setValueDeclaration(symbol, node);
            }
        }
        // Should not be called on a declaration with a computed property name,
        // unless it is a well known Symbol.
        function getDeclarationName(node) {
            if (node.kind === 274 /* SyntaxKind.ExportAssignment */) {
                return node.isExportEquals ? "export=" /* InternalSymbolName.ExportEquals */ : "default" /* InternalSymbolName.Default */;
            }
            var name = ts.getNameOfDeclaration(node);
            if (name) {
                if (ts.isAmbientModule(node)) {
                    var moduleName = ts.getTextOfIdentifierOrLiteral(name);
                    return (ts.isGlobalScopeAugmentation(node) ? "__global" : "\"".concat(moduleName, "\""));
                }
                if (name.kind === 164 /* SyntaxKind.ComputedPropertyName */) {
                    var nameExpression = name.expression;
                    // treat computed property names where expression is string/numeric literal as just string/numeric literal
                    if (ts.isStringOrNumericLiteralLike(nameExpression)) {
                        return ts.escapeLeadingUnderscores(nameExpression.text);
                    }
                    if (ts.isSignedNumericLiteral(nameExpression)) {
                        return ts.tokenToString(nameExpression.operator) + nameExpression.operand.text;
                    }
                    else {
                        ts.Debug.fail("Only computed properties with literal names have declaration names");
                    }
                }
                if (ts.isPrivateIdentifier(name)) {
                    // containingClass exists because private names only allowed inside classes
                    var containingClass = ts.getContainingClass(node);
                    if (!containingClass) {
                        // we can get here in cases where there is already a parse error.
                        return undefined;
                    }
                    var containingClassSymbol = containingClass.symbol;
                    return ts.getSymbolNameForPrivateIdentifier(containingClassSymbol, name.escapedText);
                }
                return ts.isPropertyNameLiteral(name) ? ts.getEscapedTextOfIdentifierOrLiteral(name) : undefined;
            }
            switch (node.kind) {
                case 173 /* SyntaxKind.Constructor */:
                    return "__constructor" /* InternalSymbolName.Constructor */;
                case 181 /* SyntaxKind.FunctionType */:
                case 176 /* SyntaxKind.CallSignature */:
                case 326 /* SyntaxKind.JSDocSignature */:
                    return "__call" /* InternalSymbolName.Call */;
                case 182 /* SyntaxKind.ConstructorType */:
                case 177 /* SyntaxKind.ConstructSignature */:
                    return "__new" /* InternalSymbolName.New */;
                case 178 /* SyntaxKind.IndexSignature */:
                    return "__index" /* InternalSymbolName.Index */;
                case 275 /* SyntaxKind.ExportDeclaration */:
                    return "__export" /* InternalSymbolName.ExportStar */;
                case 308 /* SyntaxKind.SourceFile */:
                    // json file should behave as
                    // module.exports = ...
                    return "export=" /* InternalSymbolName.ExportEquals */;
                case 223 /* SyntaxKind.BinaryExpression */:
                    if (ts.getAssignmentDeclarationKind(node) === 2 /* AssignmentDeclarationKind.ModuleExports */) {
                        // module.exports = ...
                        return "export=" /* InternalSymbolName.ExportEquals */;
                    }
                    ts.Debug.fail("Unknown binary declaration kind");
                    break;
                case 320 /* SyntaxKind.JSDocFunctionType */:
                    return (ts.isJSDocConstructSignature(node) ? "__new" /* InternalSymbolName.New */ : "__call" /* InternalSymbolName.Call */);
                case 166 /* SyntaxKind.Parameter */:
                    // Parameters with names are handled at the top of this function.  Parameters
                    // without names can only come from JSDocFunctionTypes.
                    ts.Debug.assert(node.parent.kind === 320 /* SyntaxKind.JSDocFunctionType */, "Impossible parameter parent kind", function () { return "parent is: ".concat(ts.Debug.formatSyntaxKind(node.parent.kind), ", expected JSDocFunctionType"); });
                    var functionType = node.parent;
                    var index = functionType.parameters.indexOf(node);
                    return "arg" + index;
            }
        }
        function getDisplayName(node) {
            return ts.isNamedDeclaration(node) ? ts.declarationNameToString(node.name) : ts.unescapeLeadingUnderscores(ts.Debug.checkDefined(getDeclarationName(node)));
        }
        /**
         * Declares a Symbol for the node and adds it to symbols. Reports errors for conflicting identifier names.
         * @param symbolTable - The symbol table which node will be added to.
         * @param parent - node's parent declaration.
         * @param node - The declaration to be added to the symbol table
         * @param includes - The SymbolFlags that node has in addition to its declaration type (eg: export, ambient, etc.)
         * @param excludes - The flags which node cannot be declared alongside in a symbol table. Used to report forbidden declarations.
         */
        function declareSymbol(symbolTable, parent, node, includes, excludes, isReplaceableByMethod, isComputedName) {
            ts.Debug.assert(isComputedName || !ts.hasDynamicName(node));
            var isDefaultExport = ts.hasSyntacticModifier(node, 1024 /* ModifierFlags.Default */) || ts.isExportSpecifier(node) && node.name.escapedText === "default";
            // The exported symbol for an export default function/class node is always named "default"
            var name = isComputedName ? "__computed" /* InternalSymbolName.Computed */
                : isDefaultExport && parent ? "default" /* InternalSymbolName.Default */
                    : getDeclarationName(node);
            var symbol;
            if (name === undefined) {
                symbol = createSymbol(0 /* SymbolFlags.None */, "__missing" /* InternalSymbolName.Missing */);
            }
            else {
                // Check and see if the symbol table already has a symbol with this name.  If not,
                // create a new symbol with this name and add it to the table.  Note that we don't
                // give the new symbol any flags *yet*.  This ensures that it will not conflict
                // with the 'excludes' flags we pass in.
                //
                // If we do get an existing symbol, see if it conflicts with the new symbol we're
                // creating.  For example, a 'var' symbol and a 'class' symbol will conflict within
                // the same symbol table.  If we have a conflict, report the issue on each
                // declaration we have for this symbol, and then create a new symbol for this
                // declaration.
                //
                // Note that when properties declared in Javascript constructors
                // (marked by isReplaceableByMethod) conflict with another symbol, the property loses.
                // Always. This allows the common Javascript pattern of overwriting a prototype method
                // with an bound instance method of the same type: `this.method = this.method.bind(this)`
                //
                // If we created a new symbol, either because we didn't have a symbol with this name
                // in the symbol table, or we conflicted with an existing symbol, then just add this
                // node as the sole declaration of the new symbol.
                //
                // Otherwise, we'll be merging into a compatible existing symbol (for example when
                // you have multiple 'vars' with the same name in the same container).  In this case
                // just add this node into the declarations list of the symbol.
                symbol = symbolTable.get(name);
                if (includes & 2885600 /* SymbolFlags.Classifiable */) {
                    classifiableNames.add(name);
                }
                if (!symbol) {
                    symbolTable.set(name, symbol = createSymbol(0 /* SymbolFlags.None */, name));
                    if (isReplaceableByMethod)
                        symbol.isReplaceableByMethod = true;
                }
                else if (isReplaceableByMethod && !symbol.isReplaceableByMethod) {
                    // A symbol already exists, so don't add this as a declaration.
                    return symbol;
                }
                else if (symbol.flags & excludes) {
                    if (symbol.isReplaceableByMethod) {
                        // Javascript constructor-declared symbols can be discarded in favor of
                        // prototype symbols like methods.
                        symbolTable.set(name, symbol = createSymbol(0 /* SymbolFlags.None */, name));
                    }
                    else if (!(includes & 3 /* SymbolFlags.Variable */ && symbol.flags & 67108864 /* SymbolFlags.Assignment */)) {
                        // Assignment declarations are allowed to merge with variables, no matter what other flags they have.
                        if (ts.isNamedDeclaration(node)) {
                            ts.setParent(node.name, node);
                        }
                        // Report errors every position with duplicate declaration
                        // Report errors on previous encountered declarations
                        var message_1 = symbol.flags & 2 /* SymbolFlags.BlockScopedVariable */
                            ? ts.Diagnostics.Cannot_redeclare_block_scoped_variable_0
                            : ts.Diagnostics.Duplicate_identifier_0;
                        var messageNeedsName_1 = true;
                        if (symbol.flags & 384 /* SymbolFlags.Enum */ || includes & 384 /* SymbolFlags.Enum */) {
                            message_1 = ts.Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations;
                            messageNeedsName_1 = false;
                        }
                        var multipleDefaultExports_1 = false;
                        if (ts.length(symbol.declarations)) {
                            // If the current node is a default export of some sort, then check if
                            // there are any other default exports that we need to error on.
                            // We'll know whether we have other default exports depending on if `symbol` already has a declaration list set.
                            if (isDefaultExport) {
                                message_1 = ts.Diagnostics.A_module_cannot_have_multiple_default_exports;
                                messageNeedsName_1 = false;
                                multipleDefaultExports_1 = true;
                            }
                            else {
                                // This is to properly report an error in the case "export default { }" is after export default of class declaration or function declaration.
                                // Error on multiple export default in the following case:
                                // 1. multiple export default of class declaration or function declaration by checking NodeFlags.Default
                                // 2. multiple export default of export assignment. This one doesn't have NodeFlags.Default on (as export default doesn't considered as modifiers)
                                if (symbol.declarations && symbol.declarations.length &&
                                    (node.kind === 274 /* SyntaxKind.ExportAssignment */ && !node.isExportEquals)) {
                                    message_1 = ts.Diagnostics.A_module_cannot_have_multiple_default_exports;
                                    messageNeedsName_1 = false;
                                    multipleDefaultExports_1 = true;
                                }
                            }
                        }
                        var relatedInformation_1 = [];
                        if (ts.isTypeAliasDeclaration(node) && ts.nodeIsMissing(node.type) && ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */) && symbol.flags & (2097152 /* SymbolFlags.Alias */ | 788968 /* SymbolFlags.Type */ | 1920 /* SymbolFlags.Namespace */)) {
                            // export type T; - may have meant export type { T }?
                            relatedInformation_1.push(createDiagnosticForNode(node, ts.Diagnostics.Did_you_mean_0, "export type { ".concat(ts.unescapeLeadingUnderscores(node.name.escapedText), " }")));
                        }
                        var declarationName_1 = ts.getNameOfDeclaration(node) || node;
                        ts.forEach(symbol.declarations, function (declaration, index) {
                            var decl = ts.getNameOfDeclaration(declaration) || declaration;
                            var diag = createDiagnosticForNode(decl, message_1, messageNeedsName_1 ? getDisplayName(declaration) : undefined);
                            file.bindDiagnostics.push(multipleDefaultExports_1 ? ts.addRelatedInfo(diag, createDiagnosticForNode(declarationName_1, index === 0 ? ts.Diagnostics.Another_export_default_is_here : ts.Diagnostics.and_here)) : diag);
                            if (multipleDefaultExports_1) {
                                relatedInformation_1.push(createDiagnosticForNode(decl, ts.Diagnostics.The_first_export_default_is_here));
                            }
                        });
                        var diag = createDiagnosticForNode(declarationName_1, message_1, messageNeedsName_1 ? getDisplayName(node) : undefined);
                        file.bindDiagnostics.push(ts.addRelatedInfo.apply(void 0, __spreadArray([diag], relatedInformation_1, false)));
                        symbol = createSymbol(0 /* SymbolFlags.None */, name);
                    }
                }
            }
            addDeclarationToSymbol(symbol, node, includes);
            if (symbol.parent) {
                ts.Debug.assert(symbol.parent === parent, "Existing symbol parent should match new one");
            }
            else {
                symbol.parent = parent;
            }
            return symbol;
        }
        function declareModuleMember(node, symbolFlags, symbolExcludes) {
            var hasExportModifier = !!(ts.getCombinedModifierFlags(node) & 1 /* ModifierFlags.Export */) || jsdocTreatAsExported(node);
            if (symbolFlags & 2097152 /* SymbolFlags.Alias */) {
                if (node.kind === 278 /* SyntaxKind.ExportSpecifier */ || (node.kind === 268 /* SyntaxKind.ImportEqualsDeclaration */ && hasExportModifier)) {
                    return declareSymbol(container.symbol.exports, container.symbol, node, symbolFlags, symbolExcludes);
                }
                else {
                    return declareSymbol(container.locals, /*parent*/ undefined, node, symbolFlags, symbolExcludes);
                }
            }
            else {
                // Exported module members are given 2 symbols: A local symbol that is classified with an ExportValue flag,
                // and an associated export symbol with all the correct flags set on it. There are 2 main reasons:
                //
                //   1. We treat locals and exports of the same name as mutually exclusive within a container.
                //      That means the binder will issue a Duplicate Identifier error if you mix locals and exports
                //      with the same name in the same container.
                //      TODO: Make this a more specific error and decouple it from the exclusion logic.
                //   2. When we checkIdentifier in the checker, we set its resolved symbol to the local symbol,
                //      but return the export symbol (by calling getExportSymbolOfValueSymbolIfExported). That way
                //      when the emitter comes back to it, it knows not to qualify the name if it was found in a containing scope.
                // NOTE: Nested ambient modules always should go to to 'locals' table to prevent their automatic merge
                //       during global merging in the checker. Why? The only case when ambient module is permitted inside another module is module augmentation
                //       and this case is specially handled. Module augmentations should only be merged with original module definition
                //       and should never be merged directly with other augmentation, and the latter case would be possible if automatic merge is allowed.
                if (ts.isJSDocTypeAlias(node))
                    ts.Debug.assert(ts.isInJSFile(node)); // We shouldn't add symbols for JSDoc nodes if not in a JS file.
                if (!ts.isAmbientModule(node) && (hasExportModifier || container.flags & 64 /* NodeFlags.ExportContext */)) {
                    if (!container.locals || (ts.hasSyntacticModifier(node, 1024 /* ModifierFlags.Default */) && !getDeclarationName(node))) {
                        return declareSymbol(container.symbol.exports, container.symbol, node, symbolFlags, symbolExcludes); // No local symbol for an unnamed default!
                    }
                    var exportKind = symbolFlags & 111551 /* SymbolFlags.Value */ ? 1048576 /* SymbolFlags.ExportValue */ : 0;
                    var local = declareSymbol(container.locals, /*parent*/ undefined, node, exportKind, symbolExcludes);
                    local.exportSymbol = declareSymbol(container.symbol.exports, container.symbol, node, symbolFlags, symbolExcludes);
                    node.localSymbol = local;
                    return local;
                }
                else {
                    return declareSymbol(container.locals, /*parent*/ undefined, node, symbolFlags, symbolExcludes);
                }
            }
        }
        function jsdocTreatAsExported(node) {
            if (node.parent && ts.isModuleDeclaration(node)) {
                node = node.parent;
            }
            if (!ts.isJSDocTypeAlias(node))
                return false;
            // jsdoc typedef handling is a bit of a doozy, but to summarize, treat the typedef as exported if:
            // 1. It has an explicit name (since by default typedefs are always directly exported, either at the top level or in a container), or
            if (!ts.isJSDocEnumTag(node) && !!node.fullName)
                return true;
            // 2. The thing a nameless typedef pulls its name from is implicitly a direct export (either by assignment or actual export flag).
            var declName = ts.getNameOfDeclaration(node);
            if (!declName)
                return false;
            if (ts.isPropertyAccessEntityNameExpression(declName.parent) && isTopLevelNamespaceAssignment(declName.parent))
                return true;
            if (ts.isDeclaration(declName.parent) && ts.getCombinedModifierFlags(declName.parent) & 1 /* ModifierFlags.Export */)
                return true;
            // This could potentially be simplified by having `delayedBindJSDocTypedefTag` pass in an override for `hasExportModifier`, since it should
            // already have calculated and branched on most of this.
            return false;
        }
        // All container nodes are kept on a linked list in declaration order. This list is used by
        // the getLocalNameOfContainer function in the type checker to validate that the local name
        // used for a container is unique.
        function bindContainer(node, containerFlags) {
            // Before we recurse into a node's children, we first save the existing parent, container
            // and block-container.  Then after we pop out of processing the children, we restore
            // these saved values.
            var saveContainer = container;
            var saveThisParentContainer = thisParentContainer;
            var savedBlockScopeContainer = blockScopeContainer;
            // Depending on what kind of node this is, we may have to adjust the current container
            // and block-container.   If the current node is a container, then it is automatically
            // considered the current block-container as well.  Also, for containers that we know
            // may contain locals, we eagerly initialize the .locals field. We do this because
            // it's highly likely that the .locals will be needed to place some child in (for example,
            // a parameter, or variable declaration).
            //
            // However, we do not proactively create the .locals for block-containers because it's
            // totally normal and common for block-containers to never actually have a block-scoped
            // variable in them.  We don't want to end up allocating an object for every 'block' we
            // run into when most of them won't be necessary.
            //
            // Finally, if this is a block-container, then we clear out any existing .locals object
            // it may contain within it.  This happens in incremental scenarios.  Because we can be
            // reusing a node from a previous compilation, that node may have had 'locals' created
            // for it.  We must clear this so we don't accidentally move any stale data forward from
            // a previous compilation.
            if (containerFlags & 1 /* ContainerFlags.IsContainer */) {
                if (node.kind !== 216 /* SyntaxKind.ArrowFunction */) {
                    thisParentContainer = container;
                }
                container = blockScopeContainer = node;
                if (containerFlags & 32 /* ContainerFlags.HasLocals */) {
                    container.locals = ts.createSymbolTable();
                }
                addToContainerChain(container);
            }
            else if (containerFlags & 2 /* ContainerFlags.IsBlockScopedContainer */) {
                blockScopeContainer = node;
                blockScopeContainer.locals = undefined;
            }
            if (containerFlags & 4 /* ContainerFlags.IsControlFlowContainer */) {
                var saveCurrentFlow = currentFlow;
                var saveBreakTarget = currentBreakTarget;
                var saveContinueTarget = currentContinueTarget;
                var saveReturnTarget = currentReturnTarget;
                var saveExceptionTarget = currentExceptionTarget;
                var saveActiveLabelList = activeLabelList;
                var saveHasExplicitReturn = hasExplicitReturn;
                var isImmediatelyInvoked = (containerFlags & 16 /* ContainerFlags.IsFunctionExpression */ &&
                    !ts.hasSyntacticModifier(node, 512 /* ModifierFlags.Async */) &&
                    !node.asteriskToken &&
                    !!ts.getImmediatelyInvokedFunctionExpression(node)) ||
                    node.kind === 172 /* SyntaxKind.ClassStaticBlockDeclaration */;
                // A non-async, non-generator IIFE is considered part of the containing control flow. Return statements behave
                // similarly to break statements that exit to a label just past the statement body.
                if (!isImmediatelyInvoked) {
                    currentFlow = initFlowNode({ flags: 2 /* FlowFlags.Start */ });
                    if (containerFlags & (16 /* ContainerFlags.IsFunctionExpression */ | 128 /* ContainerFlags.IsObjectLiteralOrClassExpressionMethodOrAccessor */)) {
                        currentFlow.node = node;
                    }
                }
                // We create a return control flow graph for IIFEs and constructors. For constructors
                // we use the return control flow graph in strict property initialization checks.
                currentReturnTarget = isImmediatelyInvoked || node.kind === 173 /* SyntaxKind.Constructor */ || (ts.isInJSFile(node) && (node.kind === 259 /* SyntaxKind.FunctionDeclaration */ || node.kind === 215 /* SyntaxKind.FunctionExpression */)) ? createBranchLabel() : undefined;
                currentExceptionTarget = undefined;
                currentBreakTarget = undefined;
                currentContinueTarget = undefined;
                activeLabelList = undefined;
                hasExplicitReturn = false;
                bindChildren(node);
                // Reset all reachability check related flags on node (for incremental scenarios)
                node.flags &= ~2816 /* NodeFlags.ReachabilityAndEmitFlags */;
                if (!(currentFlow.flags & 1 /* FlowFlags.Unreachable */) && containerFlags & 8 /* ContainerFlags.IsFunctionLike */ && ts.nodeIsPresent(node.body)) {
                    node.flags |= 256 /* NodeFlags.HasImplicitReturn */;
                    if (hasExplicitReturn)
                        node.flags |= 512 /* NodeFlags.HasExplicitReturn */;
                    node.endFlowNode = currentFlow;
                }
                if (node.kind === 308 /* SyntaxKind.SourceFile */) {
                    node.flags |= emitFlags;
                    node.endFlowNode = currentFlow;
                }
                if (currentReturnTarget) {
                    addAntecedent(currentReturnTarget, currentFlow);
                    currentFlow = finishFlowLabel(currentReturnTarget);
                    if (node.kind === 173 /* SyntaxKind.Constructor */ || node.kind === 172 /* SyntaxKind.ClassStaticBlockDeclaration */ || (ts.isInJSFile(node) && (node.kind === 259 /* SyntaxKind.FunctionDeclaration */ || node.kind === 215 /* SyntaxKind.FunctionExpression */))) {
                        node.returnFlowNode = currentFlow;
                    }
                }
                if (!isImmediatelyInvoked) {
                    currentFlow = saveCurrentFlow;
                }
                currentBreakTarget = saveBreakTarget;
                currentContinueTarget = saveContinueTarget;
                currentReturnTarget = saveReturnTarget;
                currentExceptionTarget = saveExceptionTarget;
                activeLabelList = saveActiveLabelList;
                hasExplicitReturn = saveHasExplicitReturn;
            }
            else if (containerFlags & 64 /* ContainerFlags.IsInterface */) {
                seenThisKeyword = false;
                bindChildren(node);
                node.flags = seenThisKeyword ? node.flags | 128 /* NodeFlags.ContainsThis */ : node.flags & ~128 /* NodeFlags.ContainsThis */;
            }
            else {
                bindChildren(node);
            }
            container = saveContainer;
            thisParentContainer = saveThisParentContainer;
            blockScopeContainer = savedBlockScopeContainer;
        }
        function bindEachFunctionsFirst(nodes) {
            bindEach(nodes, function (n) { return n.kind === 259 /* SyntaxKind.FunctionDeclaration */ ? bind(n) : undefined; });
            bindEach(nodes, function (n) { return n.kind !== 259 /* SyntaxKind.FunctionDeclaration */ ? bind(n) : undefined; });
        }
        function bindEach(nodes, bindFunction) {
            if (bindFunction === void 0) { bindFunction = bind; }
            if (nodes === undefined) {
                return;
            }
            ts.forEach(nodes, bindFunction);
        }
        function bindEachChild(node) {
            ts.forEachChild(node, bind, bindEach);
        }
        function bindChildren(node) {
            var saveInAssignmentPattern = inAssignmentPattern;
            // Most nodes aren't valid in an assignment pattern, so we clear the value here
            // and set it before we descend into nodes that could actually be part of an assignment pattern.
            inAssignmentPattern = false;
            if (checkUnreachable(node)) {
                bindEachChild(node);
                bindJSDoc(node);
                inAssignmentPattern = saveInAssignmentPattern;
                return;
            }
            if (node.kind >= 240 /* SyntaxKind.FirstStatement */ && node.kind <= 256 /* SyntaxKind.LastStatement */ && !options.allowUnreachableCode) {
                node.flowNode = currentFlow;
            }
            switch (node.kind) {
                case 244 /* SyntaxKind.WhileStatement */:
                    bindWhileStatement(node);
                    break;
                case 243 /* SyntaxKind.DoStatement */:
                    bindDoStatement(node);
                    break;
                case 245 /* SyntaxKind.ForStatement */:
                    bindForStatement(node);
                    break;
                case 246 /* SyntaxKind.ForInStatement */:
                case 247 /* SyntaxKind.ForOfStatement */:
                    bindForInOrForOfStatement(node);
                    break;
                case 242 /* SyntaxKind.IfStatement */:
                    bindIfStatement(node);
                    break;
                case 250 /* SyntaxKind.ReturnStatement */:
                case 254 /* SyntaxKind.ThrowStatement */:
                    bindReturnOrThrow(node);
                    break;
                case 249 /* SyntaxKind.BreakStatement */:
                case 248 /* SyntaxKind.ContinueStatement */:
                    bindBreakOrContinueStatement(node);
                    break;
                case 255 /* SyntaxKind.TryStatement */:
                    bindTryStatement(node);
                    break;
                case 252 /* SyntaxKind.SwitchStatement */:
                    bindSwitchStatement(node);
                    break;
                case 266 /* SyntaxKind.CaseBlock */:
                    bindCaseBlock(node);
                    break;
                case 292 /* SyntaxKind.CaseClause */:
                    bindCaseClause(node);
                    break;
                case 241 /* SyntaxKind.ExpressionStatement */:
                    bindExpressionStatement(node);
                    break;
                case 253 /* SyntaxKind.LabeledStatement */:
                    bindLabeledStatement(node);
                    break;
                case 221 /* SyntaxKind.PrefixUnaryExpression */:
                    bindPrefixUnaryExpressionFlow(node);
                    break;
                case 222 /* SyntaxKind.PostfixUnaryExpression */:
                    bindPostfixUnaryExpressionFlow(node);
                    break;
                case 223 /* SyntaxKind.BinaryExpression */:
                    if (ts.isDestructuringAssignment(node)) {
                        // Carry over whether we are in an assignment pattern to
                        // binary expressions that could actually be an initializer
                        inAssignmentPattern = saveInAssignmentPattern;
                        bindDestructuringAssignmentFlow(node);
                        return;
                    }
                    bindBinaryExpressionFlow(node);
                    break;
                case 217 /* SyntaxKind.DeleteExpression */:
                    bindDeleteExpressionFlow(node);
                    break;
                case 224 /* SyntaxKind.ConditionalExpression */:
                    bindConditionalExpressionFlow(node);
                    break;
                case 257 /* SyntaxKind.VariableDeclaration */:
                    bindVariableDeclarationFlow(node);
                    break;
                case 208 /* SyntaxKind.PropertyAccessExpression */:
                case 209 /* SyntaxKind.ElementAccessExpression */:
                    bindAccessExpressionFlow(node);
                    break;
                case 210 /* SyntaxKind.CallExpression */:
                    bindCallExpressionFlow(node);
                    break;
                case 232 /* SyntaxKind.NonNullExpression */:
                    bindNonNullExpressionFlow(node);
                    break;
                case 348 /* SyntaxKind.JSDocTypedefTag */:
                case 341 /* SyntaxKind.JSDocCallbackTag */:
                case 342 /* SyntaxKind.JSDocEnumTag */:
                    bindJSDocTypeAlias(node);
                    break;
                // In source files and blocks, bind functions first to match hoisting that occurs at runtime
                case 308 /* SyntaxKind.SourceFile */: {
                    bindEachFunctionsFirst(node.statements);
                    bind(node.endOfFileToken);
                    break;
                }
                case 238 /* SyntaxKind.Block */:
                case 265 /* SyntaxKind.ModuleBlock */:
                    bindEachFunctionsFirst(node.statements);
                    break;
                case 205 /* SyntaxKind.BindingElement */:
                    bindBindingElementFlow(node);
                    break;
                case 166 /* SyntaxKind.Parameter */:
                    bindParameterFlow(node);
                    break;
                case 207 /* SyntaxKind.ObjectLiteralExpression */:
                case 206 /* SyntaxKind.ArrayLiteralExpression */:
                case 299 /* SyntaxKind.PropertyAssignment */:
                case 227 /* SyntaxKind.SpreadElement */:
                    // Carry over whether we are in an assignment pattern of Object and Array literals
                    // as well as their children that are valid assignment targets.
                    inAssignmentPattern = saveInAssignmentPattern;
                // falls through
                default:
                    bindEachChild(node);
                    break;
            }
            bindJSDoc(node);
            inAssignmentPattern = saveInAssignmentPattern;
        }
        function isNarrowingExpression(expr) {
            switch (expr.kind) {
                case 79 /* SyntaxKind.Identifier */:
                case 80 /* SyntaxKind.PrivateIdentifier */:
                case 108 /* SyntaxKind.ThisKeyword */:
                case 208 /* SyntaxKind.PropertyAccessExpression */:
                case 209 /* SyntaxKind.ElementAccessExpression */:
                    return containsNarrowableReference(expr);
                case 210 /* SyntaxKind.CallExpression */:
                    return hasNarrowableArgument(expr);
                case 214 /* SyntaxKind.ParenthesizedExpression */:
                case 232 /* SyntaxKind.NonNullExpression */:
                    return isNarrowingExpression(expr.expression);
                case 223 /* SyntaxKind.BinaryExpression */:
                    return isNarrowingBinaryExpression(expr);
                case 221 /* SyntaxKind.PrefixUnaryExpression */:
                    return expr.operator === 53 /* SyntaxKind.ExclamationToken */ && isNarrowingExpression(expr.operand);
                case 218 /* SyntaxKind.TypeOfExpression */:
                    return isNarrowingExpression(expr.expression);
            }
            return false;
        }
        function isNarrowableReference(expr) {
            return ts.isDottedName(expr)
                || (ts.isPropertyAccessExpression(expr) || ts.isNonNullExpression(expr) || ts.isParenthesizedExpression(expr)) && isNarrowableReference(expr.expression)
                || ts.isBinaryExpression(expr) && expr.operatorToken.kind === 27 /* SyntaxKind.CommaToken */ && isNarrowableReference(expr.right)
                || ts.isElementAccessExpression(expr) && (ts.isStringOrNumericLiteralLike(expr.argumentExpression) || ts.isEntityNameExpression(expr.argumentExpression)) && isNarrowab