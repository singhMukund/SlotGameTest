nts, antecedent: antecedent });
        }
        function setFlowNodeReferenced(flow) {
            // On first reference we set the Referenced flag, thereafter we set the Shared flag
            flow.flags |= flow.flags & 2048 /* FlowFlags.Referenced */ ? 4096 /* FlowFlags.Shared */ : 2048 /* FlowFlags.Referenced */;
        }
        function addAntecedent(label, antecedent) {
            if (!(antecedent.flags & 1 /* FlowFlags.Unreachable */) && !ts.contains(label.antecedents, antecedent)) {
                (label.antecedents || (label.antecedents = [])).push(antecedent);
                setFlowNodeReferenced(antecedent);
            }
        }
        function createFlowCondition(flags, antecedent, expression) {
            if (antecedent.flags & 1 /* FlowFlags.Unreachable */) {
                return antecedent;
            }
            if (!expression) {
                return flags & 32 /* FlowFlags.TrueCondition */ ? antecedent : unreachableFlow;
            }
            if ((expression.kind === 110 /* SyntaxKind.TrueKeyword */ && flags & 64 /* FlowFlags.FalseCondition */ ||
                expression.kind === 95 /* SyntaxKind.FalseKeyword */ && flags & 32 /* FlowFlags.TrueCondition */) &&
                !ts.isExpressionOfOptionalChainRoot(expression) && !ts.isNullishCoalesce(expression.parent)) {
                return unreachableFlow;
            }
            if (!isNarrowingExpression(expression)) {
                return antecedent;
            }
            setFlowNodeReferenced(antecedent);
            return initFlowNode({ flags: flags, antecedent: antecedent, node: expression });
        }
        function createFlowSwitchClause(antecedent, switchStatement, clauseStart, clauseEnd) {
            setFlowNodeReferenced(antecedent);
            return initFlowNode({ flags: 128 /* FlowFlags.SwitchClause */, antecedent: antecedent, switchStatement: switchStatement, clauseStart: clauseStart, clauseEnd: clauseEnd });
        }
        function createFlowMutation(flags, antecedent, node) {
            setFlowNodeReferenced(antecedent);
            var result = initFlowNode({ flags: flags, antecedent: antecedent, node: node });
            if (currentExceptionTarget) {
                addAntecedent(currentExceptionTarget, result);
            }
            return result;
        }
        function createFlowCall(antecedent, node) {
            setFlowNodeReferenced(antecedent);
            return initFlowNode({ flags: 512 /* FlowFlags.Call */, antecedent: antecedent, node: node });
        }
        function finishFlowLabel(flow) {
            var antecedents = flow.antecedents;
            if (!antecedents) {
                return unreachableFlow;
            }
            if (antecedents.length === 1) {
                return antecedents[0];
            }
            return flow;
        }
        function isStatementCondition(node) {
            var parent = node.parent;
            switch (parent.kind) {
                case 242 /* SyntaxKind.IfStatement */:
                case 244 /* SyntaxKind.WhileStatement */:
                case 243 /* SyntaxKind.DoStatement */:
                    return parent.expression === node;
                case 245 /* SyntaxKind.ForStatement */:
                case 224 /* SyntaxKind.ConditionalExpression */:
                    return parent.condition === node;
            }
            return false;
        }
        function isLogicalExpression(node) {
            while (true) {
                if (node.kind === 214 /* SyntaxKind.ParenthesizedExpression */) {
                    node = node.expression;
                }
                else if (node.kind === 221 /* SyntaxKind.PrefixUnaryExpression */ && node.operator === 53 /* SyntaxKind.ExclamationToken */) {
                    node = node.operand;
                }
                else {
                    return node.kind === 223 /* SyntaxKind.BinaryExpression */ && (node.operatorToken.kind === 55 /* SyntaxKind.AmpersandAmpersandToken */ ||
                        node.operatorToken.kind === 56 /* SyntaxKind.BarBarToken */ ||
                        node.operatorToken.kind === 60 /* SyntaxKind.QuestionQuestionToken */);
                }
            }
        }
        function isLogicalAssignmentExpression(node) {
            node = ts.skipParentheses(node);
            return ts.isBinaryExpression(node) && ts.isLogicalOrCoalescingAssignmentOperator(node.operatorToken.kind);
        }
        function isTopLevelLogicalExpression(node) {
            while (ts.isParenthesizedExpression(node.parent) ||
                ts.isPrefixUnaryExpression(node.parent) && node.parent.operator === 53 /* SyntaxKind.ExclamationToken */) {
                node = node.parent;
            }
            return !isStatementCondition(node) &&
                !isLogicalExpression(node.parent) &&
                !(ts.isOptionalChain(node.parent) && node.parent.expression === node);
        }
        function doWithConditionalBranches(action, value, trueTarget, falseTarget) {
            var savedTrueTarget = currentTrueTarget;
            var savedFalseTarget = currentFalseTarget;
            currentTrueTarget = trueTarget;
            currentFalseTarget = falseTarget;
            action(value);
            currentTrueTarget = savedTrueTarget;
            currentFalseTarget = savedFalseTarget;
        }
        function bindCondition(node, trueTarget, falseTarget) {
            doWithConditionalBranches(bind, node, trueTarget, falseTarget);
            if (!node || !isLogicalAssignmentExpression(node) && !isLogicalExpression(node) && !(ts.isOptionalChain(node) && ts.isOutermostOptionalChain(node))) {
                addAntecedent(trueTarget, createFlowCondition(32 /* FlowFlags.TrueCondition */, currentFlow, node));
                addAntecedent(falseTarget, createFlowCondition(64 /* FlowFlags.FalseCondition */, currentFlow, node));
            }
        }
        function bindIterativeStatement(node, breakTarget, continueTarget) {
            var saveBreakTarget = currentBreakTarget;
            var saveContinueTarget = currentContinueTarget;
            currentBreakTarget = breakTarget;
            currentContinueTarget = continueTarget;
            bind(node);
            currentBreakTarget = saveBreakTarget;
            currentContinueTarget = saveContinueTarget;
        }
        function setContinueTarget(node, target) {
            var label = activeLabelList;
            while (label && node.parent.kind === 253 /* SyntaxKind.LabeledStatement */) {
                label.continueTarget = target;
                label = label.next;
                node = node.parent;
            }
            return target;
        }
        function bindWhileStatement(node) {
            var preWhileLabel = setContinueTarget(node, createLoopLabel());
            var preBodyLabel = createBranchLabel();
            var postWhileLabel = createBranchLabel();
            addAntecedent(preWhileLabel, currentFlow);
            currentFlow = preWhileLabel;
            bindCondition(node.expression, preBodyLabel, postWhileLabel);
            currentFlow = finishFlowLabel(preBodyLabel);
            bindIterativeStatement(node.statement, postWhileLabel, preWhileLabel);
            addAntecedent(preWhileLabel, currentFlow);
            currentFlow = finishFlowLabel(postWhileLabel);
        }
        function bindDoStatement(node) {
            var preDoLabel = createLoopLabel();
            var preConditionLabel = setContinueTarget(node, createBranchLabel());
            var postDoLabel = createBranchLabel();
            addAntecedent(preDoLabel, currentFlow);
            currentFlow = preDoLabel;
            bindIterativeStatement(node.statement, postDoLabel, preConditionLabel);
            addAntecedent(preConditionLabel, currentFlow);
            currentFlow = finishFlowLabel(preConditionLabel);
            bindCondition(node.expression, preDoLabel, postDoLabel);
            currentFlow = finishFlowLabel(postDoLabel);
        }
        function bindForStatement(node) {
            var preLoopLabel = setContinueTarget(node, createLoopLabel());
            var preBodyLabel = createBranchLabel();
            var postLoopLabel = createBranchLabel();
            bind(node.initializer);
            addAntecedent(preLoopLabel, currentFlow);
            currentFlow = preLoopLabel;
            bindCondition(node.condition, preBodyLabel, postLoopLabel);
            currentFlow = finishFlowLabel(preBodyLabel);
            bindIterativeStatement(node.statement, postLoopLabel, preLoopLabel);
            bind(node.incrementor);
            addAntecedent(preLoopLabel, currentFlow);
            currentFlow = finishFlowLabel(postLoopLabel);
        }
        function bindForInOrForOfStatement(node) {
            var preLoopLabel = setContinueTarget(node, createLoopLabel());
            var postLoopLabel = createBranchLabel();
            bind(node.expression);
            addAntecedent(preLoopLabel, currentFlow);
            currentFlow = preLoopLabel;
            if (node.kind === 247 /* SyntaxKind.ForOfStatement */) {
                bind(node.awaitModifier);
            }
            addAntecedent(postLoopLabel, currentFlow);
            bind(node.initializer);
            if (node.initializer.kind !== 258 /* SyntaxKind.VariableDeclarationList */) {
                bindAssignmentTargetFlow(node.initializer);
            }
            bindIterativeStatement(node.statement, postLoopLabel, preLoopLabel);
            addAntecedent(preLoopLabel, currentFlow);
            currentFlow = finishFlowLabel(postLoopLabel);
        }
        function bindIfStatement(node) {
            var thenLabel = createBranchLabel();
            var elseLabel = createBranchLabel();
            var postIfLabel = createBranchLabel();
            bindCondition(node.expression, thenLabel, elseLabel);
            currentFlow = finishFlowLabel(thenLabel);
            bind(node.thenStatement);
            addAntecedent(postIfLabel, currentFlow);
            currentFlow = finishFlowLabel(elseLabel);
            bind(node.elseStatement);
            addAntecedent(postIfLabel, currentFlow);
            currentFlow = finishFlowLabel(postIfLabel);
        }
        function bindReturnOrThrow(node) {
            bind(node.expression);
            if (node.kind === 250 /* SyntaxKind.ReturnStatement */) {
                hasExplicitReturn = true;
                if (currentReturnTarget) {
                    addAntecedent(currentReturnTarget, currentFlow);
                }
            }
            currentFlow = unreachableFlow;
        }
        function findActiveLabel(name) {
            for (var label = activeLabelList; label; label = label.next) {
                if (label.name === name) {
                    return label;
                }
            }
            return undefined;
        }
        function bindBreakOrContinueFlow(node, breakTarget, continueTarget) {
            var flowLabel = node.kind === 249 /* SyntaxKind.BreakStatement */ ? breakTarget : continueTarget;
            if (flowLabel) {
                addAntecedent(flowLabel, currentFlow);
                currentFlow = unreachableFlow;
            }
        }
        function bindBreakOrContinueStatement(node) {
            bind(node.label);
            if (node.label) {
                var activeLabel = findActiveLabel(node.label.escapedText);
                if (activeLabel) {
                    activeLabel.referenced = true;
                    bindBreakOrContinueFlow(node, activeLabel.breakTarget, activeLabel.continueTarget);
                }
            }
            else {
                bindBreakOrContinueFlow(node, currentBreakTarget, currentContinueTarget);
            }
        }
        function bindTryStatement(node) {
            // We conservatively assume that *any* code in the try block can cause an exception, but we only need
            // to track code that causes mutations (because only mutations widen the possible control flow type of
            // a variable). The exceptionLabel is the target label for control flows that result from exceptions.
            // We add all mutation flow nodes as antecedents of this label such that we can analyze them as possible
            // antecedents of the start of catch or finally blocks. Furthermore, we add the current control flow to
            // represent exceptions that occur before any mutations.
            var saveReturnTarget = currentReturnTarget;
            var saveExceptionTarget = currentExceptionTarget;
            var normalExitLabel = createBranchLabel();
            var returnLabel = createBranchLabel();
            var exceptionLabel = createBranchLabel();
            if (node.finallyBlock) {
                currentReturnTarget = returnLabel;
            }
            addAntecedent(exceptionLabel, currentFlow);
            currentExceptionTarget = exceptionLabel;
            bind(node.tryBlock);
            addAntecedent(normalExitLabel, currentFlow);
            if (node.catchClause) {
                // Start of catch clause is the target of exceptions from try block.
                currentFlow = finishFlowLabel(exceptionLabel);
                // The currentExceptionTarget now represents control flows from exceptions in the catch clause.
                // Effectively, in a try-catch-finally, if an exception occurs in the try block, the catch block
                // acts like a second try block.
                exceptionLabel = createBranchLabel();
                addAntecedent(exceptionLabel, currentFlow);
                currentExceptionTarget = exceptionLabel;
                bind(node.catchClause);
                addAntecedent(normalExitLabel, currentFlow);
            }
            currentReturnTarget = saveReturnTarget;
            currentExceptionTarget = saveExceptionTarget;
            if (node.finallyBlock) {
                // Possible ways control can reach the finally block:
                // 1) Normal completion of try block of a try-finally or try-catch-finally
                // 2) Normal completion of catch block (following exception in try block) of a try-catch-finally
                // 3) Return in try or catch block of a try-finally or try-catch-finally
                // 4) Exception in try block of a try-finally
                // 5) Exception in catch block of a try-catch-finally
                // When analyzing a control flow graph that starts inside a finally block we want to consider all
                // five possibilities above. However, when analyzing a control flow graph that starts outside (past)
                // the finally block, we only want to consider the first two (if we're past a finally block then it
                // must have completed normally). Likewise, when analyzing a control flow graph from return statements
                // in try or catch blocks in an IIFE, we only want to consider the third. To make this possible, we
                // inject a ReduceLabel node into the control flow graph. This node contains an alternate reduced
                // set of antecedents for the pre-finally label. As control flow analysis passes by a ReduceLabel
                // node, the pre-finally label is temporarily switched to the reduced antecedent set.
                var finallyLabel = createBranchLabel();
                finallyLabel.antecedents = ts.concatenate(ts.concatenate(normalExitLabel.antecedents, exceptionLabel.antecedents), returnLabel.antecedents);
                currentFlow = finallyLabel;
                bind(node.finallyBlock);
                if (currentFlow.flags & 1 /* FlowFlags.Unreachable */) {
                    // If the end of the finally block is unreachable, the end of the entire try statement is unreachable.
                    currentFlow = unreachableFlow;
                }
                else {
                    // If we have an IIFE return target and return statements in the try or catch blocks, add a control
                    // flow that goes back through the finally block and back through only the return statements.
                    if (currentReturnTarget && returnLabel.antecedents) {
                        addAntecedent(currentReturnTarget, createReduceLabel(finallyLabel, returnLabel.antecedents, currentFlow));
                    }
                    // If we have an outer exception target (i.e. a containing try-finally or try-catch-finally), add a
                    // control flow that goes back through the finally blok and back through each possible exception source.
                    if (currentExceptionTarget && exceptionLabel.antecedents) {
                        addAntecedent(currentExceptionTarget, createReduceLabel(finallyLabel, exceptionLabel.antecedents, currentFlow));
                    }
                    // If the end of the finally block is reachable, but the end of the try and catch blocks are not,
                    // convert the current flow to unreachable. For example, 'try { return 1; } finally { ... }' should
                    // result in an unreachable current control flow.
                    currentFlow = normalExitLabel.antecedents ? createReduceLabel(finallyLabel, normalExitLabel.antecedents, currentFlow) : unreachableFlow;
                }
            }
            else {
                currentFlow = finishFlowLabel(normalExitLabel);
            }
        }
        function bindSwitchStatement(node) {
            var postSwitchLabel = createBranchLabel();
            bind(node.expression);
            var saveBreakTarget = currentBreakTarget;
            var savePreSwitchCaseFlow = preSwitchCaseFlow;
            currentBreakTarget = postSwitchLabel;
            preSwitchCaseFlow = currentFlow;
            bind(node.caseBlock);
            addAntecedent(postSwitchLabel, currentFlow);
            var hasDefault = ts.forEach(node.caseBlock.clauses, function (c) { return c.kind === 293 /* SyntaxKind.DefaultClause */; });
            // We mark a switch statement as possibly exhaustive if it has no default clause and if all
            // case clauses have unreachable end points (e.g. they all return). Note, we no longer need
            // this property in control flow analysis, it's there only for backwards compatibility.
            node.possiblyExhaustive = !hasDefault && !postSwitchLabel.antecedents;
            if (!hasDefault) {
                addAntecedent(postSwitchLabel, createFlowSwitchClause(preSwitchCaseFlow, node, 0, 0));
            }
            currentBreakTarget = saveBreakTarget;
            preSwitchCaseFlow = savePreSwitchCaseFlow;
            currentFlow = finishFlowLabel(postSwitchLabel);
        }
        function bindCaseBlock(node) {
            var clauses = node.clauses;
            var isNarrowingSwitch = isNarrowingExpression(node.parent.expression);
            var fallthroughFlow = unreachableFlow;
            for (var i = 0; i < clauses.length; i++) {
                var clauseStart = i;
                while (!clauses[i].statements.length && i + 1 < clauses.length) {
                    bind(clauses[i]);
                    i++;
                }
                var preCaseLabel = createBranchLabel();
                addAntecedent(preCaseLabel, isNarrowingSwitch ? createFlowSwitchClause(preSwitchCaseFlow, node.parent, clauseStart, i + 1) : preSwitchCaseFlow);
                addAntecedent(preCaseLabel, fallthroughFlow);
                currentFlow = finishFlowLabel(preCaseLabel);
                var clause = clauses[i];
                bind(clause);
                fallthroughFlow = currentFlow;
                if (!(currentFlow.flags & 1 /* FlowFlags.Unreachable */) && i !== clauses.length - 1 && options.noFallthroughCasesInSwitch) {
                    clause.fallthroughFlowNode = currentFlow;
                }
            }
        }
        function bindCaseClause(node) {
            var saveCurrentFlow = currentFlow;
            currentFlow = preSwitchCaseFlow;
            bind(node.expression);
            currentFlow = saveCurrentFlow;
            bindEach(node.statements);
        }
        function bindExpressionStatement(node) {
            bind(node.expression);
            maybeBindExpressionFlowIfCall(node.expression);
        }
        function maybeBindExpressionFlowIfCall(node) {
            // A top level or comma expression call expression with a dotted function name and at least one argument
            // is potentially an assertion and is therefore included in the control flow.
            if (node.kind === 210 /* SyntaxKind.CallExpression */) {
                var call = node;
                if (call.expression.kind !== 106 /* SyntaxKind.SuperKeyword */ && ts.isDottedName(call.expression)) {
                    currentFlow = createFlowCall(currentFlow, call);
                }
            }
        }
        function bindLabeledStatement(node) {
            var postStatementLabel = createBranchLabel();
            activeLabelList = {
                next: activeLabelList,
                name: node.label.escapedText,
                breakTarget: postStatementLabel,
                continueTarget: undefined,
                referenced: false
            };
            bind(node.label);
            bind(node.statement);
            if (!activeLabelList.referenced && !options.allowUnusedLabels) {
                errorOrSuggestionOnNode(ts.unusedLabelIsError(options), node.label, ts.Diagnostics.Unused_label);
            }
            activeLabelList = activeLabelList.next;
            addAntecedent(postStatementLabel, currentFlow);
            currentFlow = finishFlowLabel(postStatementLabel);
        }
        function bindDestructuringTargetFlow(node) {
            if (node.kind === 223 /* SyntaxKind.BinaryExpression */ && node.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */) {
                bindAssignmentTargetFlow(node.left);
            }
            else {
                bindAssignmentTargetFlow(node);
            }
        }
        function bindAssignmentTargetFlow(node) {
            if (isNarrowableReference(node)) {
                currentFlow = createFlowMutation(16 /* FlowFlags.Assignment */, currentFlow, node);
            }
            else if (node.kind === 206 /* SyntaxKind.ArrayLiteralExpression */) {
                for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
                    var e = _a[_i];
                    if (e.kind === 227 /* SyntaxKind.SpreadElement */) {
                        bindAssignmentTargetFlow(e.expression);
                    }
                    else {
                        bindDestructuringTargetFlow(e);
                    }
                }
            }
            else if (node.kind === 207 /* SyntaxKind.ObjectLiteralExpression */) {
                for (var _b = 0, _c = node.properties; _b < _c.length; _b++) {
                    var p = _c[_b];
                    if (p.kind === 299 /* SyntaxKind.PropertyAssignment */) {
                        bindDestructuringTargetFlow(p.initializer);
                    }
                    else if (p.kind === 300 /* SyntaxKind.ShorthandPropertyAssignment */) {
                        bindAssignmentTargetFlow(p.name);
                    }
                    else if (p.kind === 301 /* SyntaxKind.SpreadAssignment */) {
                        bindAssignmentTargetFlow(p.expression);
                    }
                }
            }
        }
        function bindLogicalLikeExpression(node, trueTarget, falseTarget) {
            var preRightLabel = createBranchLabel();
            if (node.operatorToken.kind === 55 /* SyntaxKind.AmpersandAmpersandToken */ || node.operatorToken.kind === 76 /* SyntaxKind.AmpersandAmpersandEqualsToken */) {
                bindCondition(node.left, preRightLabel, falseTarget);
            }
            else {
                bindCondition(node.left, trueTarget, preRightLabel);
            }
            currentFlow = finishFlowLabel(preRightLabel);
            bind(node.operatorToken);
            if (ts.isLogicalOrCoalescingAssignmentOperator(node.operatorToken.kind)) {
                doWithConditionalBranches(bind, node.right, trueTarget, falseTarget);
                bindAssignmentTargetFlow(node.left);
                addAntecedent(trueTarget, createFlowCondition(32 /* FlowFlags.TrueCondition */, currentFlow, node));
                addAntecedent(falseTarget, createFlowCondition(64 /* FlowFlags.FalseCondition */, currentFlow, node));
            }
            else {
                bindCondition(node.right, trueTarget, falseTarget);
            }
        }
        function bindPrefixUnaryExpressionFlow(node) {
            if (node.operator === 53 /* SyntaxKind.ExclamationToken */) {
                var saveTrueTarget = currentTrueTarget;
                currentTrueTarget = currentFalseTarget;
                currentFalseTarget = saveTrueTarget;
                bindEachChild(node);
                currentFalseTarget = currentTrueTarget;
                currentTrueTarget = saveTrueTarget;
            }
            else {
                bindEachChild(node);
                if (node.operator === 45 /* SyntaxKind.PlusPlusToken */ || node.operator === 46 /* SyntaxKind.MinusMinusToken */) {
                    bindAssignmentTargetFlow(node.operand);
                }
            }
        }
        function bindPostfixUnaryExpressionFlow(node) {
            bindEachChild(node);
            if (node.operator === 45 /* SyntaxKind.PlusPlusToken */ || node.operator === 46 /* SyntaxKind.MinusMinusToken */) {
                bindAssignmentTargetFlow(node.operand);
            }
        }
        function bindDestructuringAssignmentFlow(node) {
            if (inAssignmentPattern) {
                inAssignmentPattern = false;
                bind(node.operatorToken);
                bind(node.right);
                inAssignmentPattern = true;
                bind(node.left);
            }
            else {
                inAssignmentPattern = true;
                bind(node.left);
                inAssignmentPattern = false;
                bind(node.operatorToken);
                bind(node.right);
            }
            bindAssignmentTargetFlow(node.left);
        }
        function createBindBinaryExpressionFlow() {
            return ts.createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, /*foldState*/ undefined);
            function onEnter(node, state) {
                if (state) {
                    state.stackIndex++;
                    // Emulate the work that `bind` does before reaching `bindChildren`. A normal call to
                    // `bindBinaryExpressionFlow` will already have done this work.
                    ts.setParent(node, parent);
                    var saveInStrictMode = inStrictMode;
                    bindWorker(node);
                    var saveParent = parent;
                    parent = node;
                    state.skip = false;
                    state.inStrictModeStack[state.stackIndex] = saveInStrictMode;
                    state.parentStack[state.stackIndex] = saveParent;
                }
                else {
                    state = {
                        stackIndex: 0,
                        skip: false,
                        inStrictModeStack: [undefined],
                        parentStack: [undefined]
                    };
                }
                // TODO: bindLogicalExpression is recursive - if we want to handle deeply nested `&&` expressions
                // we'll need to handle the `bindLogicalExpression` scenarios in this state machine, too
                // For now, though, since the common cases are chained `+`, leaving it recursive is fine
                var operator = node.operatorToken.kind;
                if (operator === 55 /* SyntaxKind.AmpersandAmpersandToken */ ||
                    operator === 56 /* SyntaxKind.BarBarToken */ ||
                    operator === 60 /* SyntaxKind.QuestionQuestionToken */ ||
                    ts.isLogicalOrCoalescingAssignmentOperator(operator)) {
                    if (isTopLevelLogicalExpression(node)) {
                        var postExpressionLabel = createBranchLabel();
                        bindLogicalLikeExpression(node, postExpressionLabel, postExpressionLabel);
                        currentFlow = finishFlowLabel(postExpressionLabel);
                    }
                    else {
                        bindLogicalLikeExpression(node, currentTrueTarget, currentFalseTarget);
                    }
                    state.skip = true;
                }
                return state;
            }
            function onLeft(left, state, node) {
                if (!state.skip) {
                    var maybeBound = maybeBind(left);
                    if (node.operatorToken.kind === 27 /* SyntaxKind.CommaToken */) {
                        maybeBindExpressionFlowIfCall(left);
                    }
                    return maybeBound;
                }
            }
            function onOperator(operatorToken, state, _node) {
                if (!state.skip) {
                    bind(operatorToken);
                }
            }
            function onRight(right, state, node) {
                if (!state.skip) {
                    var maybeBound = maybeBind(right);
                    if (node.operatorToken.kind === 27 /* SyntaxKind.CommaToken */) {
                        maybeBindExpressionFlowIfCall(right);
                    }
                    return maybeBound;
                }
            }
            function onExit(node, state) {
                if (!state.skip) {
                    var operator = node.operatorToken.kind;
                    if (ts.isAssignmentOperator(operator) && !ts.isAssignmentTarget(node)) {
                        bindAssignmentTargetFlow(node.left);
                        if (operator === 63 /* SyntaxKind.EqualsToken */ && node.left.kind === 209 /* SyntaxKind.ElementAccessExpression */) {
                            var elementAccess = node.left;
                            if (isNarrowableOperand(elementAccess.expression)) {
                                currentFlow = createFlowMutation(256 /* FlowFlags.ArrayMutation */, currentFlow, node);
                            }
                        }
                    }
                }
                var savedInStrictMode = state.inStrictModeStack[state.stackIndex];
                var savedParent = state.parentStack[state.stackIndex];
                if (savedInStrictMode !== undefined) {
                    inStrictMode = savedInStrictMode;
                }
                if (savedParent !== undefined) {
                    parent = savedParent;
                }
                state.skip = false;
                state.stackIndex--;
            }
            function maybeBind(node) {
                if (node && ts.isBinaryExpression(node) && !ts.isDestructuringAssignment(node)) {
                    return node;
                }
                bind(node);
            }
        }
        function bindDeleteExpressionFlow(node) {
            bindEachChild(node);
            if (node.expression.kind === 208 /* SyntaxKind.PropertyAccessExpression */) {
                bindAssignmentTargetFlow(node.expression);
            }
        }
        function bindConditionalExpressionFlow(node) {
            var trueLabel = createBranchLabel();
            var falseLabel = createBranchLabel();
            var postExpressionLabel = createBranchLabel();
            bindCondition(node.condition, trueLabel, falseLabel);
            currentFlow = finishFlowLabel(trueLabel);
            bind(node.questionToken);
            bind(node.whenTrue);
            addAntecedent(postExpressionLabel, currentFlow);
            currentFlow = finishFlowLabel(falseLabel);
            bind(node.colonToken);
            bind(node.whenFalse);
            addAntecedent(postExpressionLabel, currentFlow);
            currentFlow = finishFlowLabel(postExpressionLabel);
        }
        function bindInitializedVariableFlow(node) {
            var name = !ts.isOmittedExpression(node) ? node.name : undefined;
            if (ts.isBindingPattern(name)) {
                for (var _i = 0, _a = name.elements; _i < _a.length; _i++) {
                    var child = _a[_i];
                    bindInitializedVariableFlow(child);
                }
            }
            else {
                currentFlow = createFlowMutation(16 /* FlowFlags.Assignment */, currentFlow, node);
            }
        }
        function bindVariableDeclarationFlow(node) {
            bindEachChild(node);
            if (node.initializer || ts.isForInOrOfStatement(node.parent.parent)) {
                bindInitializedVariableFlow(node);
            }
        }
        function bindBindingElementFlow(node) {
            // When evaluating a binding pattern, the initializer is evaluated before the binding pattern, per:
            // - https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
            //   - `BindingElement: BindingPattern Initializer?`
            // - https://tc39.es/ecma262/#sec-runtime-semantics-keyedbindinginitialization
            //   - `BindingElement: BindingPattern Initializer?`
            bind(node.dotDotDotToken);
            bind(node.propertyName);
            bindInitializer(node.initializer);
            bind(node.name);
        }
        function bindParameterFlow(node) {
            bindEach(node.modifiers);
            bind(node.dotDotDotToken);
            bind(node.questionToken);
            bind(node.type);
            bindInitializer(node.initializer);
            bind(node.name);
        }
        // a BindingElement/Parameter does not have side effects if initializers are not evaluated and used. (see GH#49759)
        function bindInitializer(node) {
            if (!node) {
                return;
            }
            var entryFlow = currentFlow;
            bind(node);
            if (entryFlow === unreachableFlow || entryFlow === currentFlow) {
                return;
            }
            var exitFlow = createBranchLabel();
            addAntecedent(exitFlow, entryFlow);
            addAntecedent(exitFlow, currentFlow);
            currentFlow = finishFlowLabel(exitFlow);
        }
        function bindJSDocTypeAlias(node) {
            bind(node.tagName);
            if (node.kind !== 342 /* SyntaxKind.JSDocEnumTag */ && node.fullName) {
                // don't bind the type name yet; that's delayed until delayedBindJSDocTypedefTag
                ts.setParent(node.fullName, node);
                ts.setParentRecursive(node.fullName, /*incremental*/ false);
            }
            if (typeof node.comment !== "string") {
                bindEach(node.comment);
            }
        }
        function bindJSDocClassTag(node) {
            bindEachChild(node);
            var host = ts.getHostSignatureFromJSDoc(node);
            if (host && host.kind !== 171 /* SyntaxKind.MethodDeclaration */) {
                addDeclarationToSymbol(host.symbol, host, 32 /* SymbolFlags.Class */);
            }
        }
        function bindOptionalExpression(node, trueTarget, falseTarget) {
            doWithConditionalBranches(bind, node, trueTarget, falseTarget);
            if (!ts.isOptionalChain(node) || ts.isOutermostOptionalChain(node)) {
                addAntecedent(trueTarget, createFlowCondition(32 /* FlowFlags.TrueCondition */, currentFlow, node));
                addAntecedent(falseTarget, createFlowCondition(64 /* FlowFlags.FalseCondition */, currentFlow, node));
            }
        }
        function bindOptionalChainRest(node) {
            switch (node.kind) {
                case 208 /* SyntaxKind.PropertyAccessExpression */:
                    bind(node.questionDotToken);
                    bind(node.name);
                    break;
                case 209 /* SyntaxKind.ElementAccessExpression */:
                    bind(node.questionDotToken);
                    bind(node.argumentExpression);
                    break;
                case 210 /* SyntaxKind.CallExpression */:
                    bind(node.questionDotToken);
                    bindEach(node.typeArguments);
                    bindEach(node.arguments);
                    break;
            }
        }
        function bindOptionalChain(node, trueTarget, falseTarget) {
            // For an optional chain, we emulate the behavior of a logical expression:
            //
            // a?.b         -> a && a.b
            // a?.b.c       -> a && a.b.c
            // a?.b?.c      -> a && a.b && a.b.c
            // a?.[x = 1]   -> a && a[x = 1]
            //
            // To do this we descend through the chain until we reach the root of a chain (the expression with a `?.`)
            // and build it's CFA graph as if it were the first condition (`a && ...`). Then we bind the rest
            // of the node as part of the "true" branch, and continue to do so as we ascend back up to the outermost
            // chain node. We then treat the entire node as the right side of the expression.
            var preChainLabel = ts.isOptionalChainRoot(node) ? createBranchLabel() : undefined;
            bindOptionalExpression(node.expression, preChainLabel || trueTarget, falseTarget);
            if (preChainLabel) {
                currentFlow = finishFlowLabel(preChainLabel);
            }
            doWithConditionalBranches(bindOptionalChainRest, node, trueTarget, falseTarget);
            if (ts.isOutermostOptionalChain(node)) {
                addAntecedent(trueTarget, createFlowCondition(32 /* FlowFlags.TrueCondition */, currentFlow, node));
                addAntecedent(falseTarget, createFlowCondition(64 /* FlowFlags.FalseCondition */, currentFlow, node));
            }
        }
        function bindOptionalChainFlow(node) {
            if (isTopLevelLogicalExpression(node)) {
                var postExpressionLabel = createBranchLabel();
                bindOptionalChain(node, postExpressionLabel, postExpressionLabel);
                currentFlow = finishFlowLabel(postExpressionLabel);
            }
            else {
                bindOptionalChain(node, currentTrueTarget, currentFalseTarget);
            }
        }
        function bindNonNullExpressionFlow(node) {
            if (ts.isOptionalChain(node)) {
                bindOptionalChainFlow(node);
            }
            else {
                bindEachChild(node);
            }
        }
        function bindAccessExpressionFlow(node) {
            if (ts.isOptionalChain(node)) {
                bindOptionalChainFlow(node);
            }
            else {
                bindEachChild(node);
            }
        }
        function bindCallExpressionFlow(node) {
            if (ts.isOptionalChain(node)) {
                bindOptionalChainFlow(node);
            